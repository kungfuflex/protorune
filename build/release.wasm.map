{"version":3,"sources":["~lib/rt/common.ts","~lib/metashrew-as/assembly/utils/hex.ts","~lib/metashrew-as/assembly/utils/xxh32.ts","~lib/rt/stub.ts","~lib/util/error.ts","~lib/metashrew-as/assembly/utils/logging.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/fast-sha256-as/assembly/hex.ts","~lib/fast-sha256-as/assembly/sha256.ts","~lib/shared/runtime.ts","~lib/arraybuffer.ts","~lib/util/hash.ts","~lib/map.ts","~lib/metashrew-as/assembly/indexer/index.ts","~lib/metashrew-as/assembly/utils/yabsp.ts","~lib/metashrew-as/assembly/utils/b32.ts","~lib/util/sort.ts","~lib/string.ts","~lib/metashrew-as/assembly/utils/b58.ts","~lib/staticarray.ts","~lib/metashrew-runes/assembly/indexer/Field.ts","~lib/metashrew-runes/assembly/indexer/constants/index.ts","~lib/metashrew-as/assembly/indexer/tables.ts","~lib/as-bignum/assembly/integer/u128.ts","~lib/as-bignum/assembly/utils.ts","~lib/as-bignum/assembly/globals.ts","~lib/metashrew-as/assembly/utils/constant.ts","~lib/metashrew-as/assembly/utils/opcodes.ts","~lib/metashrew-runes/assembly/indexer/Flag.ts","assembly/indexer/fields/ProtoruneField.ts","~lib/set.ts","assembly/indexer/tables/protorune.ts","assembly/constants.ts","assembly/indexer/ProtoruneRuneId.ts","~lib/metashrew-spendables/assembly/tables.ts","~lib/metashrew-spendables/assembly/protobuf.ts","~lib/metashrew-runes/assembly/proto/metashrew-runes.ts","assembly/proto/protorune.ts","assembly/test.ts","assembly/index.ts","~lib/metashrew-as/assembly/utils/box.ts","~lib/metashrew-as/assembly/utils/utils.ts","~lib/array.ts","~lib/metashrew-as/assembly/proto/metashrew.ts","~lib/metashrew-as/assembly/utils/pointer.ts","~lib/metashrew-as/assembly/blockdata/block.ts","~lib/metashrew-as/assembly/blockdata/transaction.ts","~lib/metashrew-as/assembly/blockdata/witness.ts","~lib/metashrew-spendables/assembly/indexer.ts","~lib/metashrew-as/assembly/utils/memcpy.ts","~lib/shared/typeinfo.ts","~lib/rt.ts","~lib/metashrew-as/assembly/utils/sha256.ts","~lib/typedarray.ts","~lib/builtins.ts","~lib/metashrew-as/assembly/blockdata/address.ts","~lib/util/bytes.ts","~lib/number.ts","assembly/indexer/Indexer.ts","assembly/indexer/protomessage/MessageContext.ts","~lib/metashrew-runes/assembly/indexer/Indexer.ts","~lib/metashrew-runes/assembly/indexer/RunestoneMessage.ts","~lib/metashrew-runes/assembly/utils.ts","~lib/polyfills.ts","~lib/metashrew-runes/assembly/indexer/RuneId.ts","~lib/metashrew-runes/assembly/indexer/RunesBlock.ts","~lib/metashrew-runes/assembly/indexer/RunesTransaction.ts","~lib/metashrew-runes/assembly/leb128.ts","~lib/metashrew-runes/assembly/indexer/BalanceSheet.ts","~lib/metashrew-runes/assembly/indexer/Edict.ts","assembly/view/outpoint.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/dataview.ts","assembly/view/runes.ts","assembly/view/wallet.ts","assembly/indexer/ProtoruneBalanceSheet.ts","assembly/view/runtime.ts","assembly/utils.ts","assembly/indexer/Protostone.ts","assembly/indexer/Protoburn.ts","assembly/indexer/protomessage/ProtoMessage.ts","assembly/indexer/protomessage/IncomingRune.ts","~lib/metashrew-as/assembly/indexer/atomic.ts"],"names":[],"mappings":"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,E,EjBmgDK,E,GAAV,EACoB,E,GAAf,E,EAA6B,EAAI,EAAJ,C,EACe,EAAP,GAAR,G,MAAd,EAAc,EAA2C,EAAG,EAA/D,I,GAAA,GAAf,EADuC,E,GAAA,E,MAGlC,E,GiBtgDL,EAAoB,E,GACpB,EAAmB,E,GAAoB,EAApB,EAAL,G,GACd,EAAe,E,GAAqB,EAArB,I,GACf,EAAW,E,GApB2B,E,GAAA,E,IAsBvB,E,GAA8B,IAA9B,GAAjB,EAGqB,GAArB,E,EACgB,EAAI,E,GAAJ,CAAI,EACJ,GAAd,EACa,EAAM,EAAN,E,GACb,EAAgB,EAAS,EAAT,E,GAChB,E,GAA0B,E,GAJS,E,GAAA,E,IAM9B,O,uB5BpDmB,ENu+BC,E,wCAwJO,G,KACJ,G,0BMhoCJ,ENmjCG,E,uCkC1/BO,E,GAEL,GADnB,EACyB,GAApB,E,G9BvDqB,E,GAArB,EAAf,EACkC,ESqFlB,GTrF8B,ESqFzB,GAAvB,IqB7BW,E9BvDF,E8BuDE,EAAX,EAEW,EAA0B,EAA1B,I9BnDM,EAAyB,E9BpBY,EAA7C,C,G8BoBA,EMwBgC,EwB0B1B,EAAf,EAG8D,EAAlB,EAAvB,GAArB,EAEgB,GAAhB,EACmB,E,GACnB,E,KAA2C,E,G9BjEL,E,GAArB,EAAf,EACkC,ESqFlB,GTrF8B,ESqFzB,GAAvB,I,ETpFS,E8B+De,E,GACxB,E,GAAuB,E,MACvB,EAAmB,E,GACnB,EAAiB,EAA0B,EAA1B,I,GACjB,EAAqC,EAAnB,G,GACX,Q,mFvCzGL,EAAW,E,OACX,EAAyB,ETSa,ILyoBqB,EKzoBxC,EAAZ,E,OSRP,EAAiC,ETQK,GLyoBqB,EKzoBxC,EAAZ,E,OSPP,EAAc,ETOwB,ILyoBqB,EKzoBxC,EAAZ,E,OSNP,EAAe,ETMuB,ILyoBqB,EKzoBxC,EAAZ,E,OSLP,EAAoB,ETKkB,ILyoBqB,EKzoBxC,EAAZ,E,OSJP,EAAgB,ETIsB,ILyoBqB,EKzoBxC,EAAZ,E,OSHP,EAA0B,ETGY,GLyoBqB,EKzoBxC,EAAZ,E,OSFP,EAA0B,ETEY,GLyoBqB,EKzoBxC,EAAZ,E,OSDP,EAAuB,ETCe,ILyoBqB,EKzoBxC,EA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GAAQ,E,GAAR,GAAgB,E,GAAQ,E,GAAR,E,GAKhB,C,GoC9c0C,E,GAAA,E,OAkD7C,CAAJ,EACE,EwBtHF,G,GAAA,GxBwHA,E,GAAA,GACA,E,KAAiC,E,YiBtFhB,EtD1BqB,ILyoBqB,EKzoBxC,EAAZ,E,IAuCA,IAvC+B,GLyoBqB,EKzoBxC,EAAZ,EsD0BP,E,IACoB,EtD3BkB,ILyoBqB,EKzoBxC,EAAZ,E,IAuCA,IAvC+B,GLyoBqB,EKzoBxC,EAAZ,EsD2BP,EtDF8B,EAAhB,EAAd,E,EACA,GAII,ET5BI,EAAV,EACA,EAAa,ESwBF,E,ETvBX,EAAgB,EAAG,E,ESqBa,EAAhB,EAAd,E,EACA,GAII,ET5BI,EAAV,EACA,EAAa,ESwBF,E,ETvBX,EAAgB,EAAG,E,E+D2BjB,EAAU,EAG+B,EAHzC,GjBkFA,E,GwBtIa,E,GAAA,EAAb,E1BoDc,GAAP,G,MtDvEkB,EAAG,EAAtB,EAAN,E,EgFqBgB,EAAI,E,GAAJ,CAAI,EACA,E,GAAmB,EAAK,EAAL,EAAnB,E,EAChB,E,GAAe,EAAK,EAAL,EAAf,E,E7D+CA,ET5BI,EAAV,EACA,EAAa,ES2BQ,E,ET1BrB,EAAgB,EAAG,E,EsEvBgB,E,GAAA,E,IAMjC,E,GAAA,OJuPM,E,KAEI,E,QjCxMW,E,GF/EJ,GAiEc,EAAxB,EJG6B,E,GAArB,EAAf,EACkC,ESqFlB,GTrF8B,ESqFzB,GAAvB,ITpFS,EMYL,EACA,E,GAFK,E,GNb6B,E,GAArB,EAAf,EACkC,ESqFlB,GTrF8B,ESqFzB,GAAvB,I,ITpFS,EuCiNG,EADF,E,GAMK,UGzIK,E,QAChB,E,GpCnHK,G,GNmC6B,E,GAArB,EAAf,EACkC,ESqFlB,GTrF8B,ESqFzB,GAAvB,I,ETpFS,E0C6EW,E,M5DxGX,EAA+B,ILyoBqB,EKzoBxC,EAAZ,E4DwGP,EAGgB,E,QACd,E,GpCtHK,G,GNmC6B,E,GAArB,EAAf,EACkC,ESqFlB,GTrF8B,ESqFzB,GAAvB,I,ETpFS,E0CgFS,E,M5D3GT,EAA+B,ILyoBqB,EKzoBxC,EAAZ,E4D2GP,EAGI,E,GAA6B,EAA7B,CAAJ,E,EACoB,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B,GAAvB,I,ETpFS,E0CYS,E,M5DvCT,EAA+B,ILyoBqB,EKzoBxC,EAAZ,E4D2CQ,E,GAJC,EAAhB,EAMe,E,MAAyB,EAAzB,GAAf,EACqB,E,MAAgC,EAAhC,EAArB,E3DqeS,E,GACF,EADa,E,GACP,EAAN,GAAW,E,GAAO,E,GAAP,EAAc,EAAK,EAAL,E2Dre5B,E,G3DkSM,E,GAAV,EACe,E,GAAN,CAAT,EACgC,EAAL,E,CAAJ,CAAd,E,GAAO,E,GAAP,E,UADT,E,UAiMS,E,GACF,E2Dre4C,E,G3Doe/B,E,GACP,EAAN,GAAW,E,GAAO,E,GAAP,EAAc,EAAK,EAAL,G2DrehC,E,EAEA,E,MAAqC,EAAQ,E,GAErC,EAAsB,E,GAAtB,EAAR,EACA,E,G3D6RU,E,GAAV,EACe,E,GAAN,CAAT,EACgC,EAAL,E,CAAJ,CAAd,E,GAAO,E,GAAP,E,UADT,E,YAEO,E,G2D/RP,E,G3DoSU,E,GAAV,EACe,E,GAAN,CAAT,EACS,E,GAAO,E,GAAP,CAAuB,EAAL,E,CAAJ,CAAd,C,UADT,E,YAEO,E,G2DtSP,E,MAAyB,EAAqB,EAAd,EAAhC,S5C7CqB,E,GAAnB,E,oBfkWa,E,GAAM,E,GAAM,E,GAAM,E,GAA/B,E,EACA,E,sBelWA,EfgWK,E,uBe/ViB,E,GfgWH,E,GAAM,E,GAAM,E,GAA/B,E,EACA,E,sBejWA,Ef+VK,E,uBe9VgB,E,Gf+VF,E,GAAM,E,GAAM,E,GAA/B,E,EACA,E,sBehWA,Ef8VK,E,uBe7VgB,E,Gf8VF,E,GAAM,E,GAAM,E,GAA/B,E,EACA,E,sBe/VA,Ef6VK,E,uBe5VuB,E,Gf6VT,E,GAAM,E,GAAM,E,GAA/B,E,EACA,E,sBe9VA,Ef4VK,E,Ge3VE,K,oFzB7BI,E,EAEG,E,uBE5BW,GEirBgC,EFjrBnD,E,EGKY,EAAT,E,IIoBJ,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,ECEV,GAAR,E,sBAyBA,E,EAzBQ,GAAR,E,8BOsBsC,EAAhB,E,KACJ,E,KAGoB,EAAhB,E,KACA,E,KACF,E,KACD,E,gBR/BnB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E,IAAlB,EAAqC,GLwpBe,EKxpBlC,E","sourceRoot":"./release","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","const hexLookupTable: StaticArray<u8> = [\n  48, 48, 48, 49, 48, 50, 48, 51, 48, 52, 48, 53, 48, 54, 48, 55, 48, 56, 48,\n  57, 48, 97, 48, 98, 48, 99, 48, 100, 48, 101, 48, 102, 49, 48, 49, 49, 49, 50,\n  49, 51, 49, 52, 49, 53, 49, 54, 49, 55, 49, 56, 49, 57, 49, 97, 49, 98, 49,\n  99, 49, 100, 49, 101, 49, 102, 50, 48, 50, 49, 50, 50, 50, 51, 50, 52, 50, 53,\n  50, 54, 50, 55, 50, 56, 50, 57, 50, 97, 50, 98, 50, 99, 50, 100, 50, 101, 50,\n  102, 51, 48, 51, 49, 51, 50, 51, 51, 51, 52, 51, 53, 51, 54, 51, 55, 51, 56,\n  51, 57, 51, 97, 51, 98, 51, 99, 51, 100, 51, 101, 51, 102, 52, 48, 52, 49, 52,\n  50, 52, 51, 52, 52, 52, 53, 52, 54, 52, 55, 52, 56, 52, 57, 52, 97, 52, 98,\n  52, 99, 52, 100, 52, 101, 52, 102, 53, 48, 53, 49, 53, 50, 53, 51, 53, 52, 53,\n  53, 53, 54, 53, 55, 53, 56, 53, 57, 53, 97, 53, 98, 53, 99, 53, 100, 53, 101,\n  53, 102, 54, 48, 54, 49, 54, 50, 54, 51, 54, 52, 54, 53, 54, 54, 54, 55, 54,\n  56, 54, 57, 54, 97, 54, 98, 54, 99, 54, 100, 54, 101, 54, 102, 55, 48, 55, 49,\n  55, 50, 55, 51, 55, 52, 55, 53, 55, 54, 55, 55, 55, 56, 55, 57, 55, 97, 55,\n  98, 55, 99, 55, 100, 55, 101, 55, 102, 56, 48, 56, 49, 56, 50, 56, 51, 56, 52,\n  56, 53, 56, 54, 56, 55, 56, 56, 56, 57, 56, 97, 56, 98, 56, 99, 56, 100, 56,\n  101, 56, 102, 57, 48, 57, 49, 57, 50, 57, 51, 57, 52, 57, 53, 57, 54, 57, 55,\n  57, 56, 57, 57, 57, 97, 57, 98, 57, 99, 57, 100, 57, 101, 57, 102, 97, 48, 97,\n  49, 97, 50, 97, 51, 97, 52, 97, 53, 97, 54, 97, 55, 97, 56, 97, 57, 97, 97,\n  97, 98, 97, 99, 97, 100, 97, 101, 97, 102, 98, 48, 98, 49, 98, 50, 98, 51, 98,\n  52, 98, 53, 98, 54, 98, 55, 98, 56, 98, 57, 98, 97, 98, 98, 98, 99, 98, 100,\n  98, 101, 98, 102, 99, 48, 99, 49, 99, 50, 99, 51, 99, 52, 99, 53, 99, 54, 99,\n  55, 99, 56, 99, 57, 99, 97, 99, 98, 99, 99, 99, 100, 99, 101, 99, 102, 100,\n  48, 100, 49, 100, 50, 100, 51, 100, 52, 100, 53, 100, 54, 100, 55, 100, 56,\n  100, 57, 100, 97, 100, 98, 100, 99, 100, 100, 100, 101, 100, 102, 101, 48,\n  101, 49, 101, 50, 101, 51, 101, 52, 101, 53, 101, 54, 101, 55, 101, 56, 101,\n  57, 101, 97, 101, 98, 101, 99, 101, 100, 101, 101, 101, 102, 102, 48, 102, 49,\n  102, 50, 102, 51, 102, 52, 102, 53, 102, 54, 102, 55, 102, 56, 102, 57, 102,\n  97, 102, 98, 102, 99, 102, 100, 102, 101, 102, 102,\n];\n\nexport function encodeHexUTF8(start: usize, len: usize): ArrayBuffer {\n  let result = new ArrayBuffer(2 + <i32>len * 2);\n  store<u16>(changetype<usize>(result), <u16>0x7830);\n  for (let i: usize = 0; i < len; i++) {\n    store<u16>(\n      2 + changetype<usize>(result) + i * 2,\n      load<u16>(changetype<usize>(hexLookupTable) + 2 * load<u8>(start + i)),\n    );\n  }\n  return result;\n}\nexport function encodeHex(start: usize, len: usize): string {\n  return String.UTF8.decode(encodeHexUTF8(start, len));\n}\n\nexport function encodeHexFromBuffer(data: ArrayBuffer): string {\n  return encodeHex(changetype<usize>(data), data.byteLength);\n}\n\nexport function decodeHex(hex: string): ArrayBuffer {\n  const result = new ArrayBuffer(hex.length / 2);\n  for (let i = 0; i < hex.length; i += 2) {\n    store<u8>(\n      changetype<usize>(result) + i / 2,\n      <u8>parseInt(hex.substring(i, i + 2), 16),\n    );\n  }\n  return result;\n}\n","\n@inline const XXH32_P1: u32 = 2654435761;\n\n\n@inline const XXH32_P2: u32 = 2246822519;\n\n\n@inline const XXH32_P3: u32 = 3266489917;\n\n\n@inline const XXH32_P4: u32 = 668265263;\n\n\n@inline const XXH32_P5: u32 = 374761393;\n\n\n@inline const XXH32_SEED: u32 = 0;\n\n\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\nexport function xxh32(key: ArrayBuffer): u32 {\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\n\n  let h: u32 = key.byteLength << 1;\n  let len: usize = h;\n  let pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos));\n      s2 = mix(s2, load<u32>(pos, 4));\n      s3 = mix(s3, load<u32>(pos, 8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  let end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","import { AL_MASK, OBJECT, OBJECT_OVERHEAD, BLOCK_MAXSIZE, BLOCK_OVERHEAD, BLOCK, OBJECT_MAXSIZE } from \"./common\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === A minimal runtime stub ===\n\n// @ts-ignore: decorator\n@lazy let startOffset: usize = ((__heap_base + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n// @ts-ignore: decorator\n@lazy let offset: usize = startOffset;\n\nfunction maybeGrowMemory(newOffset: usize): void {\n  // assumes newOffset is aligned\n  let pagesBefore = memory.size();\n  let maxOffset = ((<usize>pagesBefore << 16) + AL_MASK) & ~AL_MASK;\n  if (newOffset > maxOffset) {\n    let pagesNeeded = <i32>(((newOffset - maxOffset + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newOffset;\n}\n\n// @ts-ignore: decorator\n@inline function computeSize(size: usize): usize {\n  return ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  let block = changetype<BLOCK>(offset);\n  let ptr = offset + BLOCK_OVERHEAD;\n  let payloadSize = computeSize(size);\n  maybeGrowMemory(ptr + payloadSize);\n  block.mmInfo = payloadSize;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ptr: usize, size: usize): usize {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  let actualSize = block.mmInfo;\n  let isLast = ptr + actualSize == offset;\n  let payloadSize = computeSize(size);\n  if (size > actualSize) {\n    if (isLast) { // last block: grow\n      if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n      maybeGrowMemory(ptr + payloadSize);\n      block.mmInfo = payloadSize;\n    } else { // copy to new block at least double the size\n      let newPtr = __alloc(max<usize>(payloadSize, actualSize << 1));\n      memory.copy(newPtr, ptr, actualSize);\n      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);\n    }\n  } else if (isLast) { // last block: shrink\n    offset = ptr + payloadSize;\n    block.mmInfo = payloadSize;\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ptr: usize): void {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  let block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  if (ptr + block.mmInfo == offset) { // last block: discard\n    offset = changetype<usize>(block);\n  }\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __new(size: usize, id: u32): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  let ptr = __alloc(OBJECT_OVERHEAD + size);\n  let object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);\n  object.gcInfo = 0;\n  object.gcInfo2 = 0;\n  object.rtId = id;\n  object.rtSize = <u32>size;\n  return ptr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __renew(oldPtr: usize, size: usize): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  let newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);\n  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;\n  return newPtr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __visit(ptr: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  // nop\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","\n@external(\"env\", \"__log\") declare function __log(s: ArrayBuffer): void;\nfunction _log(s: string): void {\n  console.log(s);\n}\nclass Console {\n  log(v: string): void {\n    __log(String.UTF8.encode(v, true));\n  }\n  logUTF8(data: ArrayBuffer): void {\n    __log(data);\n  }\n}\n\nexport const console: Console = new Console();\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  let b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  let base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = (value >>> 31) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = u32(value >>> 63) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy let _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// let _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  let u0 = u & 0xFFFFFFFF;\n  let v0 = v & 0xFFFFFFFF;\n\n  let u1 = u >> 32;\n  let v1 = v >> 32;\n\n  let l = u0 * v0;\n  let t = u1 * v0 + (l >> 32);\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  let frc = (f << 1) + 1;\n  let exp = e - 1;\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  let lastp = buffer + ((len - 1) << 1);\n  let digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  let dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  let k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  let index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  let uv  = reinterpret<u64>(value);\n  let exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  let sid = uv & 0x000FFFFFFFFFFFFF;\n  let frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let frc_pow = _frc_pow;\n  let exp_pow = _exp_pow;\n\n  let w_frc = umul64f(frc, frc_pow);\n  let w_exp = umul64e(exp, exp_pow);\n\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  let wp_exp = umul64e(_exp, exp_pow);\n\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  let delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  let one_exp = -mp_exp;\n  let one_frc = (<u64>1) << one_exp;\n  let mask    = one_frc - 1;\n\n  let wp_w_frc = mp_frc - w_frc;\n\n  let p1 = u32(mp_frc >> one_exp);\n  let p2 = mp_frc & mask;\n\n  let kappa = <i32>decimalCount32(p1);\n  let len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  let sign = k < 0;\n  if (sign) k = -k;\n  let decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  let kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  let sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  let len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  let size = dtoa_core(dtoa_buf, value) << 1;\n  let result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  let sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      if (sizeof<T>() == 1) {\n        if (value == -0x80) {\n          // -0x80  ->  -128\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 1) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 8) << 48\n          );\n          return 4;\n        }\n      }\n      if (sizeof<T>() == 2) {\n        if (value == -0x8000) {\n          // -0x8000  ->  -32768\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 3) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 7) << 48\n          ); // -327\n          store<u32>(buffer + 8,\n            (CharCode._0 + 6) << 0 |\n            (CharCode._0 + 8) << 16\n          ); // 68\n          return 6;\n        }\n      }\n      store<u16>(buffer, CharCode.MINUS);\n      // @ts-ignore\n      value = -value;\n    }\n  }\n  let dest = buffer + (sign << 1);\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  let decimals: u32 = 0;\n  if (sizeof<T>() <= 4) {\n    let val32 = <u32>value;\n    decimals = decimalCount32(val32);\n    utoa32_dec_core(dest, val32, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals = decimalCount32(val32);\n      utoa32_dec_core(dest, val32, decimals);\n    } else {\n      let val64 = <u64>value;\n      decimals = decimalCount64High(val64);\n      utoa64_dec_core(dest, val64, decimals);\n    }\n  }\n  return sign + decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  let kd = xd + shift;\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  let z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  let kd = <f64>(z + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = z - (kd - shift);\n  let s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFDEFEC65B963019, // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  0x3FF571ED4AAF883D, 0xBFDB0B6832D4FCA4, // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  0x3FF49539F0F010B0, 0xBFD7418B0A1FB77B, // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  0x3FF3C995B0B80385, 0xBFD39DE91A6DCF7B, // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  0x3FF30D190C8864A5, 0xBFD01D9BF3F2B631, // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  0x3FF25E227B0B8EA0, 0xBFC97C1D1B3B7AF0, // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  0x3FF1BB4A4A1A343F, 0xBFC2F9E393AF3C9F, // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  0x3FF12358F08AE5BA, 0xBFB960CBBF788D5C, // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  0x3FF0953F419900A7, 0xBFAA6F9DB6475FCE, // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0x0,\n  0x3FEE608CFD9A47AC, 0x3FB338CA9F24F53D, // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  0x3FECA4B31F026AA0, 0x3FC476A9543891BA, // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  0x3FEB2036576AFCE6, 0x3FCE840B4AC4E4D2, // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  0x3FE9C2D163A1AA2D, 0x3FD40645F0C6651C, // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  0x3FE886E6037841ED, 0x3FD88E9C2C1B9FF8, // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  0x3FE767DCF5534862, 0x3FDCE0A44EB17BCC  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  let top  = tmp & 0xFF800000;\n  let iz   = ux - top;\n  let k    = <i32>tmp >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y  = A1 * r + A2;\n  let p  = A3 * r + y0;\n  let r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFD57BF7808CAADE, // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  0x3FF571ED4AAF883D, 0xBFD2BEF0A7C06DDB, // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  0x3FF49539F0F010B0, 0xBFD01EAE7F513A67, // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  0x3FF3C995B0B80385, 0xBFCB31D8A68224E9, // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  0x3FF30D190C8864A5, 0xBFC6574F0AC07758, // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  0x3FF25E227B0B8EA0, 0xBFC1AA2BC79C8100, // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  0x3FF1BB4A4A1A343F, 0xBFBA4E76CE8C0E5E, // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  0x3FF12358F08AE5BA, 0xBFB1973C5A611CCC, // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  0x3FF0953F419900A7, 0xBFA252F438E10C1E, // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0,\n  0x3FEE608CFD9A47AC, 0x3FAAA5AA5DF25984, // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  0x3FECA4B31F026AA0, 0x3FBC5E53AA362EB4, // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  0x3FEB2036576AFCE6, 0x3FC526E57720DB08, // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  0x3FE9C2D163A1AA2D, 0x3FCBC2860D224770, // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  0x3FE886E6037841ED, 0x3FD1058BC8A07EE1, // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  0x3FE767DCF5534862, 0x3FD4043057B6EE09  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ux - 0x3F330000;\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  let k   = <i32>tmp >> 23;\n  let iz  = ux - (tmp & 0x1FF << 23);\n\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  let z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  let r = z * invc - 1;\n  let y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  let r2 = r * r;\n  let y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  let e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  let top  = tmp & 0xFF800000;\n  let uz   = ux - top;\n  let k    = <i32>top >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y = A0 * r + A1;\n  let p = A2 * r + A3;\n  let q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  let kd = <f64>(xd + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  let signBias: u32 = 0;\n  let ix = reinterpret<u32>(x);\n  let iy = reinterpret<u32>(y);\n  let ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return <i32>iy < 0 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (<i32>ix < 0) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  let logx = log2f_inline(ix);\n  let ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  let scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  let y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) {\n        return 1.0 + x;\n      } else {\n        return select<f64>(0, Infinity, <i64>ux < 0);\n      }\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  let z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // let kd = z + shift;\n  // let ki = reinterpret<u64>(kd) >> 16;\n  // let kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  let kd = z + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  let scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  let y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7ff;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (<i64>ux >= 0) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  let kd = x + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  let r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<u64>([\n  //     invc       ,        logc\n  0x3FF724286BB1ACF8, 0xBFE1095FEECDB000,\n  0x3FF6E1F766D2CCA1, 0xBFE08494BD76D000,\n  0x3FF6A13D0E30D48A, 0xBFE00143AEE8F800,\n  0x3FF661EC32D06C85, 0xBFDEFEC5360B4000,\n  0x3FF623FA951198F8, 0xBFDDFDD91AB7E000,\n  0x3FF5E75BA4CF026C, 0xBFDCFFAE0CC79000,\n  0x3FF5AC055A214FB8, 0xBFDC043811FDA000,\n  0x3FF571ED0F166E1E, 0xBFDB0B67323AE000,\n  0x3FF53909590BF835, 0xBFDA152F5A2DB000,\n  0x3FF5014FED61ADDD, 0xBFD9217F5AF86000,\n  0x3FF4CAB88E487BD0, 0xBFD8304DB0719000,\n  0x3FF49539B4334FEE, 0xBFD74189F9A9E000,\n  0x3FF460CBDFAFD569, 0xBFD6552BB5199000,\n  0x3FF42D664EE4B953, 0xBFD56B23A29B1000,\n  0x3FF3FB01111DD8A6, 0xBFD483650F5FA000,\n  0x3FF3C995B70C5836, 0xBFD39DE937F6A000,\n  0x3FF3991C4AB6FD4A, 0xBFD2BAA1538D6000,\n  0x3FF3698E0CE099B5, 0xBFD1D98340CA4000,\n  0x3FF33AE48213E7B2, 0xBFD0FA853A40E000,\n  0x3FF30D191985BDB1, 0xBFD01D9C32E73000,\n  0x3FF2E025CAB271D7, 0xBFCE857DA2FA6000,\n  0x3FF2B404CF13CD82, 0xBFCCD3C8633D8000,\n  0x3FF288B02C7CCB50, 0xBFCB26034C14A000,\n  0x3FF25E2263944DE5, 0xBFC97C1C2F4FE000,\n  0x3FF234563D8615B1, 0xBFC7D6023F800000,\n  0x3FF20B46E33EAF38, 0xBFC633A71A05E000,\n  0x3FF1E2EEFDCDA3DD, 0xBFC494F5E9570000,\n  0x3FF1BB4A580B3930, 0xBFC2F9E424E0A000,\n  0x3FF19453847F2200, 0xBFC162595AFDC000,\n  0x3FF16E06C0D5D73C, 0xBFBF9C9A75BD8000,\n  0x3FF1485F47B7E4C2, 0xBFBC7B575BF9C000,\n  0x3FF12358AD0085D1, 0xBFB960C60FF48000,\n  0x3FF0FEF00F532227, 0xBFB64CE247B60000,\n  0x3FF0DB2077D03A8F, 0xBFB33F78B2014000,\n  0x3FF0B7E6D65980D9, 0xBFB0387D1A42C000,\n  0x3FF0953EFE7B408D, 0xBFAA6F9208B50000,\n  0x3FF07325CAC53B83, 0xBFA47A954F770000,\n  0x3FF05197E40D1B5C, 0xBF9D23A8C50C0000,\n  0x3FF03091C1208EA2, 0xBF916A2629780000,\n  0x3FF0101025B37E21, 0xBF7720F8D8E80000,\n  0x3FEFC07EF9CAA76B, 0x3F86FE53B1500000,\n  0x3FEF4465D3F6F184, 0x3FA11CCCE10F8000,\n  0x3FEECC079F84107F, 0x3FAC4DFC8C8B8000,\n  0x3FEE573A99975AE8, 0x3FB3AA321E574000,\n  0x3FEDE5D6F0BD3DE6, 0x3FB918A0D08B8000,\n  0x3FED77B681FF38B3, 0x3FBE72E9DA044000,\n  0x3FED0CB5724DE943, 0x3FC1DCD2507F6000,\n  0x3FECA4B2DC0E7563, 0x3FC476AB03DEA000,\n  0x3FEC3F8EE8D6CB51, 0x3FC7074377E22000,\n  0x3FEBDD2B4F020C4C, 0x3FC98EDE8BA94000,\n  0x3FEB7D6C006015CA, 0x3FCC0DB86AD2E000,\n  0x3FEB20366E2E338F, 0x3FCE840AAFCEE000,\n  0x3FEAC57026295039, 0x3FD0790AB4678000,\n  0x3FEA6D01BC2731DD, 0x3FD1AC056801C000,\n  0x3FEA16D3BC3FF18B, 0x3FD2DB11D4FEE000,\n  0x3FE9C2D14967FEAD, 0x3FD406464EC58000,\n  0x3FE970E4F47C9902, 0x3FD52DBE093AF000,\n  0x3FE920FB3982BCF2, 0x3FD651902050D000,\n  0x3FE8D30187F759F1, 0x3FD771D2CDEAF000,\n  0x3FE886E5EBB9F66D, 0x3FD88E9C857D9000,\n  0x3FE83C97B658B994, 0x3FD9A80155E16000,\n  0x3FE7F405FFC61022, 0x3FDABE186ED3D000,\n  0x3FE7AD22181415CA, 0x3FDBD0F2AEA0E000,\n  0x3FE767DCF99EFF8C, 0x3FDCE0A43DBF4000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE6200012B90A8E, 0x3C8904AB0644B605,\n  0x3FE66000045734A6, 0x3C61FF9BEA62F7A9,\n  0x3FE69FFFC325F2C5, 0x3C827ECFCB3C90BA,\n  0x3FE6E00038B95A04, 0x3C88FF8856739326,\n  0x3FE71FFFE09994E3, 0x3C8AFD40275F82B1,\n  0x3FE7600015590E10, 0xBC72FD75B4238341,\n  0x3FE7A00012655BD5, 0x3C7808E67C242B76,\n  0x3FE7E0003259E9A6, 0xBC6208E426F622B7,\n  0x3FE81FFFEDB4B2D2, 0xBC8402461EA5C92F,\n  0x3FE860002DFAFCC3, 0x3C6DF7F4A2F29A1F,\n  0x3FE89FFFF78C6B50, 0xBC8E0453094995FD,\n  0x3FE8E00039671566, 0xBC8A04F3BEC77B45,\n  0x3FE91FFFE2BF1745, 0xBC77FA34400E203C,\n  0x3FE95FFFCC5C9FD1, 0xBC76FF8005A0695D,\n  0x3FE9A0003BBA4767, 0x3C70F8C4C4EC7E03,\n  0x3FE9DFFFE7B92DA5, 0x3C8E7FD9478C4602,\n  0x3FEA1FFFD72EFDAF, 0xBC6A0C554DCDAE7E,\n  0x3FEA5FFFDE04FF95, 0x3C867DA98CE9B26B,\n  0x3FEA9FFFCA5E8D2B, 0xBC8284C9B54C13DE,\n  0x3FEADFFFDDAD03EA, 0x3C5812C8EA602E3C,\n  0x3FEB1FFFF10D3D4D, 0xBC8EFADDAD27789C,\n  0x3FEB5FFFCE21165A, 0x3C53CB1719C61237,\n  0x3FEB9FFFD950E674, 0x3C73F7D94194CE00,\n  0x3FEBE000139CA8AF, 0x3C750AC4215D9BC0,\n  0x3FEC20005B46DF99, 0x3C6BEEA653E9C1C9,\n  0x3FEC600040B9F7AE, 0xBC7C079F274A70D6,\n  0x3FECA0006255FD8A, 0xBC7A0B4076E84C1F,\n  0x3FECDFFFD94C095D, 0x3C88F933F99AB5D7,\n  0x3FED1FFFF975D6CF, 0xBC582C08665FE1BE,\n  0x3FED5FFFA2561C93, 0xBC7B04289BD295F3,\n  0x3FED9FFF9D228B0C, 0x3C870251340FA236,\n  0x3FEDE00065BC7E16, 0xBC75011E16A4D80C,\n  0x3FEE200002F64791, 0x3C89802F09EF62E0,\n  0x3FEE600057D7A6D8, 0xBC7E0B75580CF7FA,\n  0x3FEEA00027EDC00C, 0xBC8C848309459811,\n  0x3FEEE0006CF5CB7C, 0xBC8F8027951576F4,\n  0x3FEF2000782B7DCC, 0xBC8F81D97274538F,\n  0x3FEF6000260C450A, 0xBC4071002727FFDC,\n  0x3FEF9FFFE88CD533, 0xBC581BDCE1FDA8B0,\n  0x3FEFDFFFD50F8689, 0x3C87F91ACB918E6E,\n  0x3FF0200004292367, 0x3C9B7FF365324681,\n  0x3FF05FFFE3E3D668, 0x3C86FA08DDAE957B,\n  0x3FF0A0000A85A757, 0xBC57E2DE80D3FB91,\n  0x3FF0E0001A5F3FCC, 0xBC91823305C5F014,\n  0x3FF11FFFF8AFBAF5, 0xBC8BFABB6680BAC2,\n  0x3FF15FFFE54D91AD, 0xBC9D7F121737E7EF,\n  0x3FF1A00011AC36E1, 0x3C9C000A0516F5FF,\n  0x3FF1E00019C84248, 0xBC9082FBE4DA5DA0,\n  0x3FF220000FFE5E6E, 0xBC88FDD04C9CFB43,\n  0x3FF26000269FD891, 0x3C8CFE2A7994D182,\n  0x3FF2A00029A6E6DA, 0xBC700273715E8BC5,\n  0x3FF2DFFFE0293E39, 0x3C9B7C39DAB2A6F9,\n  0x3FF31FFFF7DCF082, 0x3C7DF1336EDC5254,\n  0x3FF35FFFF05A8B60, 0xBC9E03564CCD31EB,\n  0x3FF3A0002E0EAECC, 0x3C75F0E74BD3A477,\n  0x3FF3E000043BB236, 0x3C9C7DCB149D8833,\n  0x3FF4200002D187FF, 0x3C7E08AFCF2D3D28,\n  0x3FF460000D387CB1, 0x3C820837856599A6,\n  0x3FF4A00004569F89, 0xBC89FA5C904FBCD2,\n  0x3FF4E000043543F3, 0xBC781125ED175329,\n  0x3FF51FFFCC027F0F, 0x3C9883D8847754DC,\n  0x3FF55FFFFD87B36F, 0xBC8709E731D02807,\n  0x3FF59FFFF21DF7BA, 0x3C87F79F68727B02,\n  0x3FF5DFFFEBFC3481, 0xBC9180902E30E93E\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & 0xFFF0000000000000);\n\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n  let kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  let r   = (z - chi - clo) * invc;\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  let rlo = r - rhi;\n  let t1  = rhi * InvLn2hi;\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  let t3 = kd + logc;\n  let hi = t3 + t1;\n  let lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<u64>([\n  //      invc      ,        logc\n  0x3FF734F0C3E0DE9F, 0xBFD7CC7F79E69000,\n  0x3FF713786A2CE91F, 0xBFD76FEEC20D0000,\n  0x3FF6F26008FAB5A0, 0xBFD713E31351E000,\n  0x3FF6D1A61F138C7D, 0xBFD6B85B38287800,\n  0x3FF6B1490BC5B4D1, 0xBFD65D5590807800,\n  0x3FF69147332F0CBA, 0xBFD602D076180000,\n  0x3FF6719F18224223, 0xBFD5A8CA86909000,\n  0x3FF6524F99A51ED9, 0xBFD54F4356035000,\n  0x3FF63356AA8F24C4, 0xBFD4F637C36B4000,\n  0x3FF614B36B9DDC14, 0xBFD49DA7FDA85000,\n  0x3FF5F66452C65C4C, 0xBFD445923989A800,\n  0x3FF5D867B5912C4F, 0xBFD3EDF439B0B800,\n  0x3FF5BABCCB5B90DE, 0xBFD396CE448F7000,\n  0x3FF59D61F2D91A78, 0xBFD3401E17BDA000,\n  0x3FF5805612465687, 0xBFD2E9E2EF468000,\n  0x3FF56397CEE76BD3, 0xBFD2941B3830E000,\n  0x3FF54725E2A77F93, 0xBFD23EC58CDA8800,\n  0x3FF52AFF42064583, 0xBFD1E9E129279000,\n  0x3FF50F22DBB2BDDF, 0xBFD1956D2B48F800,\n  0x3FF4F38F4734DED7, 0xBFD141679AB9F800,\n  0x3FF4D843CFDE2840, 0xBFD0EDD094EF9800,\n  0x3FF4BD3EC078A3C8, 0xBFD09AA518DB1000,\n  0x3FF4A27FC3E0258A, 0xBFD047E65263B800,\n  0x3FF4880524D48434, 0xBFCFEB224586F000,\n  0x3FF46DCE1B192D0B, 0xBFCF474A7517B000,\n  0x3FF453D9D3391854, 0xBFCEA4443D103000,\n  0x3FF43A2744B4845A, 0xBFCE020D44E9B000,\n  0x3FF420B54115F8FB, 0xBFCD60A22977F000,\n  0x3FF40782DA3EF4B1, 0xBFCCC00104959000,\n  0x3FF3EE8F5D57FE8F, 0xBFCC202956891000,\n  0x3FF3D5D9A00B4CE9, 0xBFCB81178D811000,\n  0x3FF3BD60C010C12B, 0xBFCAE2C9CCD3D000,\n  0x3FF3A5242B75DAB8, 0xBFCA45402E129000,\n  0x3FF38D22CD9FD002, 0xBFC9A877681DF000,\n  0x3FF3755BC5847A1C, 0xBFC90C6D69483000,\n  0x3FF35DCE49AD36E2, 0xBFC87120A645C000,\n  0x3FF34679984DD440, 0xBFC7D68FB4143000,\n  0x3FF32F5CCEFFCB24, 0xBFC73CB83C627000,\n  0x3FF3187775A10D49, 0xBFC6A39A9B376000,\n  0x3FF301C8373E3990, 0xBFC60B3154B7A000,\n  0x3FF2EB4EBB95F841, 0xBFC5737D76243000,\n  0x3FF2D50A0219A9D1, 0xBFC4DC7B8FC23000,\n  0x3FF2BEF9A8B7FD2A, 0xBFC4462C51D20000,\n  0x3FF2A91C7A0C1BAB, 0xBFC3B08ABC830000,\n  0x3FF293726014B530, 0xBFC31B996B490000,\n  0x3FF27DFA5757A1F5, 0xBFC2875490A44000,\n  0x3FF268B39B1D3BBF, 0xBFC1F3B9F879A000,\n  0x3FF2539D838FF5BD, 0xBFC160C8252CA000,\n  0x3FF23EB7AAC9083B, 0xBFC0CE7F57F72000,\n  0x3FF22A012BA940B6, 0xBFC03CDC49FEA000,\n  0x3FF2157996CC4132, 0xBFBF57BDBC4B8000,\n  0x3FF201201DD2FC9B, 0xBFBE370896404000,\n  0x3FF1ECF4494D480B, 0xBFBD17983EF94000,\n  0x3FF1D8F5528F6569, 0xBFBBF9674ED8A000,\n  0x3FF1C52311577E7C, 0xBFBADC79202F6000,\n  0x3FF1B17C74CB26E9, 0xBFB9C0C3E7288000,\n  0x3FF19E010C2C1AB6, 0xBFB8A646B372C000,\n  0x3FF18AB07BB670BD, 0xBFB78D01B3AC0000,\n  0x3FF1778A25EFBCB6, 0xBFB674F145380000,\n  0x3FF1648D354C31DA, 0xBFB55E0E6D878000,\n  0x3FF151B990275FDD, 0xBFB4485CDEA1E000,\n  0x3FF13F0EA432D24C, 0xBFB333D94D6AA000,\n  0x3FF12C8B7210F9DA, 0xBFB22079F8C56000,\n  0x3FF11A3028ECB531, 0xBFB10E4698622000,\n  0x3FF107FBDA8434AF, 0xBFAFFA6C6AD20000,\n  0x3FF0F5EE0F4E6BB3, 0xBFADDA8D4A774000,\n  0x3FF0E4065D2A9FCE, 0xBFABBCECE4850000,\n  0x3FF0D244632CA521, 0xBFA9A1894012C000,\n  0x3FF0C0A77CE2981A, 0xBFA788583302C000,\n  0x3FF0AF2F83C636D1, 0xBFA5715E67D68000,\n  0x3FF09DDB98A01339, 0xBFA35C8A49658000,\n  0x3FF08CABAF52E7DF, 0xBFA149E364154000,\n  0x3FF07B9F2F4E28FB, 0xBF9E72C082EB8000,\n  0x3FF06AB58C358F19, 0xBF9A55F152528000,\n  0x3FF059EEA5ECF92C, 0xBF963D62CF818000,\n  0x3FF04949CDD12C90, 0xBF9228FB8CAA0000,\n  0x3FF038C6C6F0ADA9, 0xBF8C317B20F90000,\n  0x3FF02865137932A9, 0xBF8419355DAA0000,\n  0x3FF0182427EA7348, 0xBF781203C2EC0000,\n  0x3FF008040614B195, 0xBF60040979240000,\n  0x3FEFE01FF726FA1A, 0x3F6FEFF384900000,\n  0x3FEFA11CC261EA74, 0x3F87DC41353D0000,\n  0x3FEF6310B081992E, 0x3F93CEA3C4C28000,\n  0x3FEF25F63CEEADCD, 0x3F9B9FC114890000,\n  0x3FEEE9C8039113E7, 0x3FA1B0D8CE110000,\n  0x3FEEAE8078CBB1AB, 0x3FA58A5BD001C000,\n  0x3FEE741AA29D0C9B, 0x3FA95C8340D88000,\n  0x3FEE3A91830A99B5, 0x3FAD276AEF578000,\n  0x3FEE01E009609A56, 0x3FB07598E598C000,\n  0x3FEDCA01E577BB98, 0x3FB253F5E30D2000,\n  0x3FED92F20B7C9103, 0x3FB42EDD8B380000,\n  0x3FED5CAC66FB5CCE, 0x3FB606598757C000,\n  0x3FED272CAA5EDE9D, 0x3FB7DA76356A0000,\n  0x3FECF26E3E6B2CCD, 0x3FB9AB434E1C6000,\n  0x3FECBE6DA2A77902, 0x3FBB78C7BB0D6000,\n  0x3FEC8B266D37086D, 0x3FBD431332E72000,\n  0x3FEC5894BD5D5804, 0x3FBF0A3171DE6000,\n  0x3FEC26B533BB9F8C, 0x3FC067152B914000,\n  0x3FEBF583EEECE73F, 0x3FC147858292B000,\n  0x3FEBC4FD75DB96C1, 0x3FC2266ECDCA3000,\n  0x3FEB951E0C864A28, 0x3FC303D7A6C55000,\n  0x3FEB65E2C5EF3E2C, 0x3FC3DFC33C331000,\n  0x3FEB374867C9888B, 0x3FC4BA366B7A8000,\n  0x3FEB094B211D304A, 0x3FC5933928D1F000,\n  0x3FEADBE885F2EF7E, 0x3FC66ACD2418F000,\n  0x3FEAAF1D31603DA2, 0x3FC740F8EC669000,\n  0x3FEA82E63FD358A7, 0x3FC815C0F51AF000,\n  0x3FEA5740EF09738B, 0x3FC8E92954F68000,\n  0x3FEA2C2A90AB4B27, 0x3FC9BB3602F84000,\n  0x3FEA01A01393F2D1, 0x3FCA8BED1C2C0000,\n  0x3FE9D79F24DB3C1B, 0x3FCB5B515C01D000,\n  0x3FE9AE2505C7B190, 0x3FCC2967CCBCC000,\n  0x3FE9852EF297CE2F, 0x3FCCF635D5486000,\n  0x3FE95CBAEEA44B75, 0x3FCDC1BD3446C000,\n  0x3FE934C69DE74838, 0x3FCE8C01B8CFE000,\n  0x3FE90D4F2F6752E6, 0x3FCF5509C0179000,\n  0x3FE8E6528EFFD79D, 0x3FD00E6C121FB800,\n  0x3FE8BFCE9FCC007C, 0x3FD071B80E93D000,\n  0x3FE899C0DABEC30E, 0x3FD0D46B9E867000,\n  0x3FE87427AA2317FB, 0x3FD13687334BD000,\n  0x3FE84F00ACB39A08, 0x3FD1980D67234800,\n  0x3FE82A49E8653E55, 0x3FD1F8FFE0CC8000,\n  0x3FE8060195F40260, 0x3FD2595FD7636800,\n  0x3FE7E22563E0A329, 0x3FD2B9300914A800,\n  0x3FE7BEB377DCB5AD, 0x3FD3187210436000,\n  0x3FE79BAA679725C2, 0x3FD377266DEC1800,\n  0x3FE77907F2170657, 0x3FD3D54FFBAF3000,\n  0x3FE756CADBD6130C, 0x3FD432EEE32FE000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE61000014FB66B, 0x3C7E026C91425B3C,\n  0x3FE63000034DB495, 0x3C8DBFEA48005D41,\n  0x3FE650000D94D478, 0x3C8E7FA786D6A5B7,\n  0x3FE67000074E6FAD, 0x3C61FCEA6B54254C,\n  0x3FE68FFFFEDF0FAE, 0xBC7C7E274C590EFD,\n  0x3FE6B0000763C5BC, 0xBC8AC16848DCDA01,\n  0x3FE6D0001E5CC1F6, 0x3C833F1C9D499311,\n  0x3FE6EFFFEB05F63E, 0xBC7E80041AE22D53,\n  0x3FE710000E869780, 0x3C7BFF6671097952,\n  0x3FE72FFFFC67E912, 0x3C8C00E226BD8724,\n  0x3FE74FFFDF81116A, 0xBC6E02916EF101D2,\n  0x3FE770000F679C90, 0xBC67FC71CD549C74,\n  0x3FE78FFFFA7EC835, 0x3C81BEC19EF50483,\n  0x3FE7AFFFFE20C2E6, 0xBC707E1729CC6465,\n  0x3FE7CFFFED3FC900, 0xBC808072087B8B1C,\n  0x3FE7EFFFE9261A76, 0x3C8DC0286D9DF9AE,\n  0x3FE81000049CA3E8, 0x3C897FD251E54C33,\n  0x3FE8300017932C8F, 0xBC8AFEE9B630F381,\n  0x3FE850000633739C, 0x3C89BFBF6B6535BC,\n  0x3FE87000204289C6, 0xBC8BBF65F3117B75,\n  0x3FE88FFFEBF57904, 0xBC89006EA23DCB57,\n  0x3FE8B00022BC04DF, 0xBC7D00DF38E04B0A,\n  0x3FE8CFFFE50C1B8A, 0xBC88007146FF9F05,\n  0x3FE8EFFFFC918E43, 0x3C83817BD07A7038,\n  0x3FE910001EFA5FC7, 0x3C893E9176DFB403,\n  0x3FE9300013467BB9, 0x3C7F804E4B980276,\n  0x3FE94FFFE6EE076F, 0xBC8F7EF0D9FF622E,\n  0x3FE96FFFDE3C12D1, 0xBC7082AA962638BA,\n  0x3FE98FFFF4458A0D, 0xBC87801B9164A8EF,\n  0x3FE9AFFFDD982E3E, 0xBC8740E08A5A9337,\n  0x3FE9CFFFED49FB66, 0x3C3FCE08C19BE000,\n  0x3FE9F00020F19C51, 0xBC8A3FAA27885B0A,\n  0x3FEA10001145B006, 0x3C74FF489958DA56,\n  0x3FEA300007BBF6FA, 0x3C8CBEAB8A2B6D18,\n  0x3FEA500010971D79, 0x3C88FECADD787930,\n  0x3FEA70001DF52E48, 0xBC8F41763DD8ABDB,\n  0x3FEA90001C593352, 0xBC8EBF0284C27612,\n  0x3FEAB0002A4F3E4B, 0xBC69FD043CFF3F5F,\n  0x3FEACFFFD7AE1ED1, 0xBC823EE7129070B4,\n  0x3FEAEFFFEE510478, 0x3C6A063EE00EDEA3,\n  0x3FEB0FFFDB650D5B, 0x3C5A06C8381F0AB9,\n  0x3FEB2FFFFEAACA57, 0xBC79011E74233C1D,\n  0x3FEB4FFFD995BADC, 0xBC79FF1068862A9F,\n  0x3FEB7000249E659C, 0x3C8AFF45D0864F3E,\n  0x3FEB8FFFF9871640, 0x3C7CFE7796C2C3F9,\n  0x3FEBAFFFD204CB4F, 0xBC63FF27EEF22BC4,\n  0x3FEBCFFFD2415C45, 0xBC6CFFB7EE3BEA21,\n  0x3FEBEFFFF86309DF, 0xBC814103972E0B5C,\n  0x3FEC0FFFE1B57653, 0x3C8BC16494B76A19,\n  0x3FEC2FFFF1FA57E3, 0xBC64FEEF8D30C6ED,\n  0x3FEC4FFFDCBFE424, 0xBC843F68BCEC4775,\n  0x3FEC6FFFED54B9F7, 0x3C847EA3F053E0EC,\n  0x3FEC8FFFEB998FD5, 0x3C7383068DF992F1,\n  0x3FECB0002125219A, 0xBC68FD8E64180E04,\n  0x3FECCFFFDD94469C, 0x3C8E7EBE1CC7EA72,\n  0x3FECEFFFEAFDC476, 0x3C8EBE39AD9F88FE,\n  0x3FED1000169AF82B, 0x3C757D91A8B95A71,\n  0x3FED30000D0FF71D, 0x3C89C1906970C7DA,\n  0x3FED4FFFEA790FC4, 0xBC580E37C558FE0C,\n  0x3FED70002EDC87E5, 0xBC7F80D64DC10F44,\n  0x3FED900021DC82AA, 0xBC747C8F94FD5C5C,\n  0x3FEDAFFFD86B0283, 0x3C8C7F1DC521617E,\n  0x3FEDD000296C4739, 0x3C88019EB2FFB153,\n  0x3FEDEFFFE54490F5, 0x3C6E00D2C652CC89,\n  0x3FEE0FFFCDABF694, 0xBC7F8340202D69D2,\n  0x3FEE2FFFDB52C8DD, 0x3C7B00C1CA1B0864,\n  0x3FEE4FFFF24216EF, 0x3C72FFA8B094AB51,\n  0x3FEE6FFFE88A5E11, 0xBC57F673B1EFBE59,\n  0x3FEE9000119EFF0D, 0xBC84808D5E0BC801,\n  0x3FEEAFFFDFA51744, 0x3C780006D54320B5,\n  0x3FEED0001A127FA1, 0xBC5002F860565C92,\n  0x3FEEF00007BABCC4, 0xBC8540445D35E611,\n  0x3FEF0FFFF57A8D02, 0xBC4FFB3139EF9105,\n  0x3FEF30001EE58AC7, 0x3C8A81ACF2731155,\n  0x3FEF4FFFF5823494, 0x3C8A3F41D4D7C743,\n  0x3FEF6FFFFCA94C6B, 0xBC6202F41C987875,\n  0x3FEF8FFFE1F9C441, 0x3C777DD1F477E74B,\n  0x3FEFAFFFD2E0E37E, 0xBC6F01199A7CA331,\n  0x3FEFD0001C77E49E, 0x3C7181EE4BCEACB1,\n  0x3FEFEFFFF7E0C331, 0xBC6E05370170875A,\n  0x3FF00FFFF465606E, 0xBC8A7EAD491C0ADA,\n  0x3FF02FFFF3867A58, 0xBC977F69C3FCB2E0,\n  0x3FF04FFFFDFC0D17, 0x3C97BFFE34CB945B,\n  0x3FF0700003CD4D82, 0x3C820083C0E456CB,\n  0x3FF08FFFF9F2CBE8, 0xBC6DFFDFBE37751A,\n  0x3FF0B000010CDA65, 0xBC913F7FAEE626EB,\n  0x3FF0D00001A4D338, 0x3C807DFA79489FF7,\n  0x3FF0EFFFFADAFDFD, 0xBC77040570D66BC0,\n  0x3FF110000BBAFD96, 0x3C8E80D4846D0B62,\n  0x3FF12FFFFAE5F45D, 0x3C9DBFFA64FD36EF,\n  0x3FF150000DD59AD9, 0x3C9A0077701250AE,\n  0x3FF170000F21559A, 0x3C8DFDF9E2E3DEEE,\n  0x3FF18FFFFC275426, 0x3C910030DC3B7273,\n  0x3FF1B000123D3C59, 0x3C997F7980030188,\n  0x3FF1CFFFF8299EB7, 0xBC65F932AB9F8C67,\n  0x3FF1EFFFF48AD400, 0x3C937FBF9DA75BEB,\n  0x3FF210000C8B86A4, 0x3C9F806B91FD5B22,\n  0x3FF2300003854303, 0x3C93FFC2EB9FBF33,\n  0x3FF24FFFFFBCF684, 0x3C7601E77E2E2E72,\n  0x3FF26FFFF52921D9, 0x3C7FFCBB767F0C61,\n  0x3FF2900014933A3C, 0xBC7202CA3C02412B,\n  0x3FF2B00014556313, 0xBC92808233F21F02,\n  0x3FF2CFFFEBFE523B, 0xBC88FF7E384FDCF2,\n  0x3FF2F0000BB8AD96, 0xBC85FF51503041C5,\n  0x3FF30FFFFB7AE2AF, 0xBC810071885E289D,\n  0x3FF32FFFFEAC5F7F, 0xBC91FF5D3FB7B715,\n  0x3FF350000CA66756, 0x3C957F82228B82BD,\n  0x3FF3700011FBF721, 0x3C8000BAC40DD5CC,\n  0x3FF38FFFF9592FB9, 0xBC943F9D2DB2A751,\n  0x3FF3B00004DDD242, 0x3C857F6B707638E1,\n  0x3FF3CFFFF5B2C957, 0x3C7A023A10BF1231,\n  0x3FF3EFFFEAB0B418, 0x3C987F6D66B152B0,\n  0x3FF410001532AFF4, 0x3C67F8375F198524,\n  0x3FF4300017478B29, 0x3C8301E672DC5143,\n  0x3FF44FFFE795B463, 0x3C89FF69B8B2895A,\n  0x3FF46FFFE80475E0, 0xBC95C0B19BC2F254,\n  0x3FF48FFFEF6FC1E7, 0x3C9B4009F23A2A72,\n  0x3FF4AFFFE5BEA704, 0xBC94FFB7BF0D7D45,\n  0x3FF4D000171027DE, 0xBC99C06471DC6A3D,\n  0x3FF4F0000FF03EE2, 0x3C977F890B85531C,\n  0x3FF5100012DC4BD1, 0x3C6004657166A436,\n  0x3FF530001605277A, 0xBC96BFCECE233209,\n  0x3FF54FFFECDB704C, 0xBC8902720505A1D7,\n  0x3FF56FFFEF5F54A9, 0x3C9BBFE60EC96412,\n  0x3FF5900017E61012, 0x3C887EC581AFEF90,\n  0x3FF5B00003C93E92, 0xBC9F41080ABF0CC0,\n  0x3FF5D0001D4919BC, 0xBC98812AFB254729,\n  0x3FF5EFFFE7B87A89, 0xBC947EB780ED6904\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  let r = (z - chi - clo) * invc;\n  // #endif\n  let kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  let w  = kd * Ln2hi + logc;\n  let hi = w + r;\n  let lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<u64>([\n  //      invc      ,pad,       logc       ,       logctail\n  0x3FF6A00000000000, 0, 0xBFD62C82F2B9C800, 0x3CFAB42428375680,\n  0x3FF6800000000000, 0, 0xBFD5D1BDBF580800, 0xBD1CA508D8E0F720,\n  0x3FF6600000000000, 0, 0xBFD5767717455800, 0xBD2362A4D5B6506D,\n  0x3FF6400000000000, 0, 0xBFD51AAD872DF800, 0xBCE684E49EB067D5,\n  0x3FF6200000000000, 0, 0xBFD4BE5F95777800, 0xBD041B6993293EE0,\n  0x3FF6000000000000, 0, 0xBFD4618BC21C6000, 0x3D13D82F484C84CC,\n  0x3FF5E00000000000, 0, 0xBFD404308686A800, 0x3CDC42F3ED820B3A,\n  0x3FF5C00000000000, 0, 0xBFD3A64C55694800, 0x3D20B1C686519460,\n  0x3FF5A00000000000, 0, 0xBFD347DD9A988000, 0x3D25594DD4C58092,\n  0x3FF5800000000000, 0, 0xBFD2E8E2BAE12000, 0x3D267B1E99B72BD8,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5400000000000, 0, 0xBFD22941FBCF7800, 0xBD165A242853DA76,\n  0x3FF5200000000000, 0, 0xBFD1C898C1699800, 0xBD1FAFBC68E75404,\n  0x3FF5000000000000, 0, 0xBFD1675CABABA800, 0x3D1F1FC63382A8F0,\n  0x3FF4E00000000000, 0, 0xBFD1058BF9AE4800, 0xBD26A8C4FD055A66,\n  0x3FF4C00000000000, 0, 0xBFD0A324E2739000, 0xBD0C6BEE7EF4030E,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4800000000000, 0, 0xBFCFB9186D5E4000, 0x3D0D572AAB993C87,\n  0x3FF4600000000000, 0, 0xBFCEF0ADCBDC6000, 0x3D2B26B79C86AF24,\n  0x3FF4400000000000, 0, 0xBFCE27076E2AF000, 0xBD172F4F543FFF10,\n  0x3FF4200000000000, 0, 0xBFCD5C216B4FC000, 0x3D21BA91BBCA681B,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF3E00000000000, 0, 0xBFCBC286742D9000, 0x3D194EB0318BB78F,\n  0x3FF3C00000000000, 0, 0xBFCAF3C94E80C000, 0x3CBA4E633FCD9066,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3800000000000, 0, 0xBFC9525A9CF45000, 0xBD2AD1D904C1D4E3,\n  0x3FF3600000000000, 0, 0xBFC87FA06520D000, 0x3D2BBDBF7FDBFA09,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3200000000000, 0, 0xBFC6D60FE719D000, 0xBD10E46AA3B2E266,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF2E00000000000, 0, 0xBFC526E5E3A1B000, 0xBD20DE8B90075B8F,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2A00000000000, 0, 0xBFC371FC201E9000, 0x3CF178864D27543A,\n  0x3FF2800000000000, 0, 0xBFC29552F81FF000, 0xBD248D301771C408,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2200000000000, 0, 0xBFBFEC9131DBE000, 0xBD2575545CA333F2,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF1E00000000000, 0, 0xBFBC5E548F5BC000, 0xBD1D0C57585FBE06,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1800000000000, 0, 0xBFB6F0D28AE56000, 0xBD269737C93373DA,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1200000000000, 0, 0xBFB16536EEA38000, 0x3D147C5E768FA309,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0600000000000, 0, 0xBF97B91B07D58000, 0xBD288D5493FAA639,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FEFC00000000000, 0, 0x3F80101575890000, 0xBD10C76B999D2BE8,\n  0x3FEF800000000000, 0, 0x3F90205658938000, 0xBD23DC5B06E2F7D2,\n  0x3FEF400000000000, 0, 0x3F98492528C90000, 0xBD2AA0BA325A0C34,\n  0x3FEF000000000000, 0, 0x3FA0415D89E74000, 0x3D0111C05CF1D753,\n  0x3FEEC00000000000, 0, 0x3FA466AED42E0000, 0xBD2C167375BDFD28,\n  0x3FEE800000000000, 0, 0x3FA894AA149FC000, 0xBD197995D05A267D,\n  0x3FEE400000000000, 0, 0x3FACCB73CDDDC000, 0xBD1A68F247D82807,\n  0x3FEE200000000000, 0, 0x3FAEEA31C006C000, 0xBD0E113E4FC93B7B,\n  0x3FEDE00000000000, 0, 0x3FB1973BD1466000, 0xBD25325D560D9E9B,\n  0x3FEDA00000000000, 0, 0x3FB3BDF5A7D1E000, 0x3D2CC85EA5DB4ED7,\n  0x3FED600000000000, 0, 0x3FB5E95A4D97A000, 0xBD2C69063C5D1D1E,\n  0x3FED400000000000, 0, 0x3FB700D30AEAC000, 0x3CEC1E8DA99DED32,\n  0x3FED000000000000, 0, 0x3FB9335E5D594000, 0x3D23115C3ABD47DA,\n  0x3FECC00000000000, 0, 0x3FBB6AC88DAD6000, 0xBD1390802BF768E5,\n  0x3FECA00000000000, 0, 0x3FBC885801BC4000, 0x3D2646D1C65AACD3,\n  0x3FEC600000000000, 0, 0x3FBEC739830A2000, 0xBD2DC068AFE645E0,\n  0x3FEC400000000000, 0, 0x3FBFE89139DBE000, 0xBD2534D64FA10AFD,\n  0x3FEC000000000000, 0, 0x3FC1178E8227E000, 0x3D21EF78CE2D07F2,\n  0x3FEBE00000000000, 0, 0x3FC1AA2B7E23F000, 0x3D2CA78E44389934,\n  0x3FEBA00000000000, 0, 0x3FC2D1610C868000, 0x3D039D6CCB81B4A1,\n  0x3FEB800000000000, 0, 0x3FC365FCB0159000, 0x3CC62FA8234B7289,\n  0x3FEB400000000000, 0, 0x3FC4913D8333B000, 0x3D25837954FDB678,\n  0x3FEB200000000000, 0, 0x3FC527E5E4A1B000, 0x3D2633E8E5697DC7,\n  0x3FEAE00000000000, 0, 0x3FC6574EBE8C1000, 0x3D19CF8B2C3C2E78,\n  0x3FEAC00000000000, 0, 0x3FC6F0128B757000, 0xBD25118DE59C21E1,\n  0x3FEAA00000000000, 0, 0x3FC7898D85445000, 0xBD1C661070914305,\n  0x3FEA600000000000, 0, 0x3FC8BEAFEB390000, 0xBD073D54AAE92CD1,\n  0x3FEA400000000000, 0, 0x3FC95A5ADCF70000, 0x3D07F22858A0FF6F,\n  0x3FEA000000000000, 0, 0x3FCA93ED3C8AE000, 0xBD28724350562169,\n  0x3FE9E00000000000, 0, 0x3FCB31D8575BD000, 0xBD0C358D4EACE1AA,\n  0x3FE9C00000000000, 0, 0x3FCBD087383BE000, 0xBD2D4BC4595412B6,\n  0x3FE9A00000000000, 0, 0x3FCC6FFBC6F01000, 0xBCF1EC72C5962BD2,\n  0x3FE9600000000000, 0, 0x3FCDB13DB0D49000, 0xBD2AFF2AF715B035,\n  0x3FE9400000000000, 0, 0x3FCE530EFFE71000, 0x3CC212276041F430,\n  0x3FE9200000000000, 0, 0x3FCEF5ADE4DD0000, 0xBCCA211565BB8E11,\n  0x3FE9000000000000, 0, 0x3FCF991C6CB3B000, 0x3D1BCBECCA0CDF30,\n  0x3FE8C00000000000, 0, 0x3FD07138604D5800, 0x3CF89CDB16ED4E91,\n  0x3FE8A00000000000, 0, 0x3FD0C42D67616000, 0x3D27188B163CEAE9,\n  0x3FE8800000000000, 0, 0x3FD1178E8227E800, 0xBD2C210E63A5F01C,\n  0x3FE8600000000000, 0, 0x3FD16B5CCBACF800, 0x3D2B9ACDF7A51681,\n  0x3FE8400000000000, 0, 0x3FD1BF99635A6800, 0x3D2CA6ED5147BDB7,\n  0x3FE8200000000000, 0, 0x3FD214456D0EB800, 0x3D0A87DEBA46BAEA,\n  0x3FE7E00000000000, 0, 0x3FD2BEF07CDC9000, 0x3D2A9CFA4A5004F4,\n  0x3FE7C00000000000, 0, 0x3FD314F1E1D36000, 0xBD28E27AD3213CB8,\n  0x3FE7A00000000000, 0, 0x3FD36B6776BE1000, 0x3D116ECDB0F177C8,\n  0x3FE7800000000000, 0, 0x3FD3C25277333000, 0x3D183B54B606BD5C,\n  0x3FE7600000000000, 0, 0x3FD419B423D5E800, 0x3D08E436EC90E09D,\n  0x3FE7400000000000, 0, 0x3FD4718DC271C800, 0xBD2F27CE0967D675,\n  0x3FE7200000000000, 0, 0x3FD4C9E09E173000, 0xBD2E20891B0AD8A4,\n  0x3FE7000000000000, 0, 0x3FD522AE0738A000, 0x3D2EBE708164C759,\n  0x3FE6E00000000000, 0, 0x3FD57BF753C8D000, 0x3D1FADEDEE5D40EF,\n  0x3FE6C00000000000, 0, 0x3FD5D5BDDF596000, 0xBD0A0B2A08A465DC\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  let e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy let log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ix - 0x3fE6955500000000;\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  let k   = <i64>tmp >> 52;\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\n  let z   = reinterpret<f64>(iz);\n  let kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  let zlo = z - zhi;\n  let rhi = zhi * invc - 1.0;\n  let rlo = zlo * invc;\n  let r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  let t1  = kd * Ln2hi + logc;\n  let t2  = t1 + r;\n  let lo1 = kd * Ln2lo + logctail;\n  let lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let ar  = A0 * r; // A[0] = -0.5\n  let ar2 = r * ar;\n  let ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  let arhi  = A0  * rhi;\n  let arhi2 = rhi * arhi;\n  let hi    = t2  + arhi2;\n  let lo3   = rlo * (ar + arhi);\n  let lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\n  let y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let abstop: u32;\n  let ki: u64, top: u64, sbits: u64;\n  let idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  let ux = reinterpret<u64>(x);\n  abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return <i64>ux < 0\n        ? uflow(sign_bias)\n        : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = usize((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let sign_bias: u32 = 0;\n  let ix = reinterpret<u64>(x);\n  let iy = reinterpret<u64>(y);\n  let topx = ix >> 52;\n  let topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return <i64>iy < 0 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (<i64>ix < 0) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  let hi = log_inline(ix);\n  let lo = log_tail;\n  let ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  let ylo = y - yhi;\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  let llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import {\n  itoa32,\n  utoa32,\n  itoa64,\n  utoa64,\n  dtoa,\n  itoa_buffered,\n  dtoa_buffered,\n  MAX_DOUBLE_LENGTH\n} from \"./number\";\n\nimport {\n  ipow32\n} from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  let found = false;\n  let pos = index;\n  let minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  let maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  let len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  let code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  let sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  let num: T = 0;\n  let initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  let len = str.length;\n  if (!len) return NaN;\n\n  let ptr  = changetype<usize>(str);\n  let code = <u32>load<u16>(ptr);\n\n  let sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  let savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0.0 * sign;\n  const capacity = 19; // int(64 * 0.3010)\n  let pointed = false;\n  let consumed = 0;\n  let position = 0;\n  let x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0.0 * sign;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function strtob(str: string): bool {\n  let size: usize = str.length << 1;\n  let offset: usize = 0;\n  if (size > 8) {\n    // try trim end whitespaces first\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\n    if (size > 8) {\n      // trim start whitespaces\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\n      size -= offset;\n    }\n  }\n  if (size != 8) return false;\n  // \"true\" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  let sepLen = separator.length;\n  let valueLen = 5; // max possible length of element len(\"false\")\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  let sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  let sepLen = separator.length;\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  let estLen = 0;\n  let value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  let offset = 0;\n  let sepLen = separator.length;\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  let value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  let result = \"\";\n  let sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  let significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  let shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  let b = <u64>ipow32(5, -exp);\n  let q = significand / b;\n  let r = significand % b;\n  let s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  let shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  let sign = 1, magnitude = 0;\n  let code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy let __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  let low  = (a & 0xFFFFFFFF) * b;\n  let high = (a >> 32) * b + (low >> 32);\n  let overflow = <u32>(high >> 32);\n  let space = clz(overflow);\n  let revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","const hexLookupTable: StaticArray<u8> = [\n  48, 48, 48, 49, 48, 50, 48, 51, 48, 52, 48, 53, 48, 54, 48, 55, 48, 56, 48,\n  57, 48, 97, 48, 98, 48, 99, 48, 100, 48, 101, 48, 102, 49, 48, 49, 49, 49, 50,\n  49, 51, 49, 52, 49, 53, 49, 54, 49, 55, 49, 56, 49, 57, 49, 97, 49, 98, 49,\n  99, 49, 100, 49, 101, 49, 102, 50, 48, 50, 49, 50, 50, 50, 51, 50, 52, 50, 53,\n  50, 54, 50, 55, 50, 56, 50, 57, 50, 97, 50, 98, 50, 99, 50, 100, 50, 101, 50,\n  102, 51, 48, 51, 49, 51, 50, 51, 51, 51, 52, 51, 53, 51, 54, 51, 55, 51, 56,\n  51, 57, 51, 97, 51, 98, 51, 99, 51, 100, 51, 101, 51, 102, 52, 48, 52, 49, 52,\n  50, 52, 51, 52, 52, 52, 53, 52, 54, 52, 55, 52, 56, 52, 57, 52, 97, 52, 98,\n  52, 99, 52, 100, 52, 101, 52, 102, 53, 48, 53, 49, 53, 50, 53, 51, 53, 52, 53,\n  53, 53, 54, 53, 55, 53, 56, 53, 57, 53, 97, 53, 98, 53, 99, 53, 100, 53, 101,\n  53, 102, 54, 48, 54, 49, 54, 50, 54, 51, 54, 52, 54, 53, 54, 54, 54, 55, 54,\n  56, 54, 57, 54, 97, 54, 98, 54, 99, 54, 100, 54, 101, 54, 102, 55, 48, 55, 49,\n  55, 50, 55, 51, 55, 52, 55, 53, 55, 54, 55, 55, 55, 56, 55, 57, 55, 97, 55,\n  98, 55, 99, 55, 100, 55, 101, 55, 102, 56, 48, 56, 49, 56, 50, 56, 51, 56, 52,\n  56, 53, 56, 54, 56, 55, 56, 56, 56, 57, 56, 97, 56, 98, 56, 99, 56, 100, 56,\n  101, 56, 102, 57, 48, 57, 49, 57, 50, 57, 51, 57, 52, 57, 53, 57, 54, 57, 55,\n  57, 56, 57, 57, 57, 97, 57, 98, 57, 99, 57, 100, 57, 101, 57, 102, 97, 48, 97,\n  49, 97, 50, 97, 51, 97, 52, 97, 53, 97, 54, 97, 55, 97, 56, 97, 57, 97, 97,\n  97, 98, 97, 99, 97, 100, 97, 101, 97, 102, 98, 48, 98, 49, 98, 50, 98, 51, 98,\n  52, 98, 53, 98, 54, 98, 55, 98, 56, 98, 57, 98, 97, 98, 98, 98, 99, 98, 100,\n  98, 101, 98, 102, 99, 48, 99, 49, 99, 50, 99, 51, 99, 52, 99, 53, 99, 54, 99,\n  55, 99, 56, 99, 57, 99, 97, 99, 98, 99, 99, 99, 100, 99, 101, 99, 102, 100,\n  48, 100, 49, 100, 50, 100, 51, 100, 52, 100, 53, 100, 54, 100, 55, 100, 56,\n  100, 57, 100, 97, 100, 98, 100, 99, 100, 100, 100, 101, 100, 102, 101, 48,\n  101, 49, 101, 50, 101, 51, 101, 52, 101, 53, 101, 54, 101, 55, 101, 56, 101,\n  57, 101, 97, 101, 98, 101, 99, 101, 100, 101, 101, 101, 102, 102, 48, 102, 49,\n  102, 50, 102, 51, 102, 52, 102, 53, 102, 54, 102, 55, 102, 56, 102, 57, 102,\n  97, 102, 98, 102, 99, 102, 100, 102, 101, 102, 102,\n];\n\nexport function encodeHexUTF8(start: usize, len: usize): ArrayBuffer {\n  let result = new ArrayBuffer(2 + <i32>len * 2);\n  store<u16>(changetype<usize>(result), <u16>0x7830);\n  for (let i: usize = 0; i < len; i++) {\n    store<u16>(\n      2 + changetype<usize>(result) + i * 2,\n      load<u16>(changetype<usize>(hexLookupTable) + 2 * load<u8>(start + i)),\n    );\n  }\n  return result;\n}\nexport function encodeHex(start: usize, len: usize): string {\n  return String.UTF8.decode(encodeHexUTF8(start, len));\n}\n\nexport function encodeHexFromBuffer(data: ArrayBuffer): string {\n  return encodeHex(changetype<usize>(data), data.byteLength);\n}\n","// SHA-256 (+ HMAC and PBKDF2) for JavaScript.\n//\n// Written in 2014-2016 by Dmitry Chestnykh.\n// Public domain, no warranty.\n//\n// Functions (accept and return Uint8Arrays):\n//\n//   sha256(message) -> hash\n//   sha256.hmac(key, message) -> mac\n//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk\n//\n//  Classes:\n//\n//   new sha256.Hash()\n//   new sha256.HMAC(key)\n//\n\n// SHA-256 constants\n\nimport { Box } from \"./box\";\n\nconst K: u32[] = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n  0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n  0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n  0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n  0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n  0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n];\n\nfunction hashBlocks(\n  w: Int32Array,\n  v: Int32Array,\n  p: Uint8Array,\n  pos: i32,\n  len: i32,\n): i32 {\n  let a: i32,\n    b: i32,\n    c: i32,\n    d: i32,\n    e: i32,\n    f: i32,\n    g: i32,\n    h: i32,\n    u: i32,\n    i: i32,\n    j: i32,\n    t1: i32,\n    t2: i32;\n\n  while (len >= 64) {\n    a = v[0];\n    b = v[1];\n    c = v[2];\n    d = v[3];\n    e = v[4];\n    f = v[5];\n    g = v[6];\n    h = v[7];\n\n    for (i = 0; i < 16; i++) {\n      j = pos + i * 4;\n      w[i] =\n        (((<i32>p[j]) & 0xff) << 24) |\n        (((<i32>p[j + 1]) & 0xff) << 16) |\n        (((<i32>p[j + 2]) & 0xff) << 8) |\n        ((<i32>p[j + 3]) & 0xff);\n    }\n\n    for (i = 16; i < 64; i++) {\n      u = w[i - 2];\n      t1 =\n        ((u >>> 17) | (u << (32 - 17))) ^\n        ((u >>> 19) | (u << (32 - 19))) ^\n        (u >>> 10);\n\n      u = w[i - 15];\n      t2 =\n        ((u >>> 7) | (u << (32 - 7))) ^\n        ((u >>> 18) | (u << (32 - 18))) ^\n        (u >>> 3);\n\n      w[i] = ((t1 + w[i - 7]) | 0) + ((t2 + w[i - 16]) | 0);\n    }\n\n    for (i = 0; i < 64; i++) {\n      t1 =\n        ((((((e >>> 6) | (e << (32 - 6))) ^\n          ((e >>> 11) | (e << (32 - 11))) ^\n          ((e >>> 25) | (e << (32 - 25)))) +\n          ((e & f) ^ (~e & g))) |\n          0) +\n          ((h + ((K[i] + w[i]) | 0)) | 0)) |\n        0;\n\n      t2 =\n        ((((a >>> 2) | (a << (32 - 2))) ^\n          ((a >>> 13) | (a << (32 - 13))) ^\n          ((a >>> 22) | (a << (32 - 22)))) +\n          ((a & b) ^ (a & c) ^ (b & c))) |\n        0;\n\n      h = g;\n      g = f;\n      f = e;\n      e = (d + t1) | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = (t1 + t2) | 0;\n    }\n\n    v[0] += a;\n    v[1] += b;\n    v[2] += c;\n    v[3] += d;\n    v[4] += e;\n    v[5] += f;\n    v[6] += g;\n    v[7] += h;\n\n    pos += 64;\n    len -= 64;\n  }\n  return pos;\n}\n\n// Hash implements SHA256 hash algorithm.\nexport class Hash {\n  public digestLength: i32;\n  public blockSize: i32;\n\n  // Note: Int32Array is used instead of Uint32Array for performance reasons.\n  private state: Int32Array; // hash state\n  private temp: Int32Array; // temporary state\n  private buffer: Uint8Array; // buffer for data to hash\n  private bufferLength: i32; // number of bytes in buffer\n  private bytesHashed: i32; // number of total bytes hashed\n\n  finished: boolean = false; // indicates whether the hash was finalized\n\n  constructor() {\n    this.digestLength = 32;\n    this.blockSize = 64;\n    this.state = new Int32Array(8);\n    this.temp = new Int32Array(64);\n    this.buffer = new Uint8Array(128);\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    this.reset();\n  }\n\n  // Resets hash state making it possible\n  // to re-use this instance to hash other data.\n  reset(): this {\n    this.state[0] = 0x6a09e667;\n    this.state[1] = 0xbb67ae85;\n    this.state[2] = 0x3c6ef372;\n    this.state[3] = 0xa54ff53a;\n    this.state[4] = 0x510e527f;\n    this.state[5] = 0x9b05688c;\n    this.state[6] = 0x1f83d9ab;\n    this.state[7] = 0x5be0cd19;\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    this.finished = false;\n    return this;\n  }\n\n  // Cleans internal buffers and re-initializes hash state.\n  clean(): void {\n    for (let i = 0; i < this.buffer.length; i++) {\n      this.buffer[i] = 0;\n    }\n    for (let i = 0; i < this.temp.length; i++) {\n      this.temp[i] = 0;\n    }\n    this.reset();\n  }\n\n  // Updates hash state with the given data.\n  //\n  // Optionally, length of the data can be specified to hash\n  // fewer bytes than data.length.\n  //\n  // Throws error when trying to update already finalized hash:\n  // instance must be reset to use it again.\n  update(data: Uint8Array, dataLength: i32 = data.length): this {\n    if (this.finished) {\n      throw new Error(\"SHA256: can't update because hash was finished.\");\n    }\n    let dataPos = 0;\n    let setMem = true;\n    this.bytesHashed += dataLength;\n    if (this.bufferLength > 0) {\n      while (this.bufferLength < 64 && dataLength > 0) {\n        this.buffer[this.bufferLength++] = data[dataPos++];\n        dataLength--;\n      }\n      if (this.bufferLength === 64) {\n        hashBlocks(this.temp, this.state, this.buffer, 0, 64);\n        this.bufferLength = 0;\n      }\n    }\n    if (dataLength >= 64) {\n      dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);\n      dataLength %= 64;\n    }\n    while (dataLength > 0) {\n      this.buffer[this.bufferLength++] = data[dataPos++];\n      dataLength--;\n    }\n    return this;\n  }\n\n  // Finalizes hash state and puts hash into out.\n  //\n  // If hash was already finalized, puts the same value.\n  finish(out: Uint8Array): this {\n    if (!this.finished) {\n      const bytesHashed = this.bytesHashed;\n      const left = this.bufferLength;\n      const bitLenHi = (bytesHashed / 0x20000000) | 0;\n      const bitLenLo = bytesHashed << 3;\n      const padLength = bytesHashed % 64 < 56 ? 64 : 128;\n\n      this.buffer[left] = 0x80;\n      for (let i = left + 1; i < padLength - 8; i++) {\n        this.buffer[i] = 0;\n      }\n      this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;\n      this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;\n      this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;\n      this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;\n      this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;\n      this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;\n      this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;\n      this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;\n\n      hashBlocks(this.temp, this.state, this.buffer, 0, padLength);\n\n      this.finished = true;\n    }\n\n    for (let i = 0; i < 8; i++) {\n      out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;\n      out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n      out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n      out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n    }\n\n    return this;\n  }\n\n  // Returns the final hash digest.\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.digestLength);\n    this.finish(out);\n    return out;\n  }\n\n  // Internal function for use in HMAC for optimization.\n  _saveState(out: Uint32Array): void {\n    for (let i = 0; i < this.state.length; i++) {\n      out[i] = this.state[i];\n    }\n  }\n\n  // Internal function for use in HMAC for optimization.\n  _restoreState(from: Uint32Array, bytesHashed: number): void {\n    for (let i = 0; i < this.state.length; i++) {\n      this.state[i] = from[i];\n    }\n    this.bytesHashed = bytesHashed;\n    this.finished = false;\n    this.bufferLength = 0;\n  }\n}\n\n// Returns SHA256 hash of data.\nexport function sha256(data: ArrayBuffer): ArrayBuffer {\n  const h = new Hash().update(Uint8Array.wrap(data));\n  const digest = h.digest();\n  h.clean();\n  return digest.buffer;\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    let length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    let outSize = <usize>max(end - begin, 0);\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\n\n  let h: u32 = key.length << 1;\n  let len: usize = h;\n  let pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  let end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    let entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) != null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    let hashCode = HASH<K>(key);\n    let entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    let halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    let oldPtr = changetype<usize>(this.entries);\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    let newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let keys = new Array<K>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(keys[length++] = entry.key);\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let values = new Array<V>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(values[length++] = entry.value);\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    let entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","\n@external(\"env\", \"__set\") declare function __set(\n  k: ArrayBuffer,\n  v: ArrayBuffer,\n): void;\n\n\n@external(\"env\", \"__get\") declare function __get(\n  k: ArrayBuffer,\n  v: ArrayBuffer,\n): void;\n\n\n@external(\"env\", \"__get_len\") declare function __get_len(k: ArrayBuffer): i32;\n\n\n@external(\"env\", \"__flush\") declare function __flush(values: ArrayBuffer): void;\n\n\n@external(\"env\", \"__load_input\") declare function __load_input(\n  block: ArrayBuffer,\n): void;\n\n\n@external(\"env\", \"__host_len\") declare function __host_len(): i32;\n\nimport { xxh32 } from \"../utils/xxh32\";\nimport { sha256 } from \"../utils/sha256\";\nimport { memcpy } from \"../utils/memcpy\";\nimport { Box } from \"../utils/box\";\nimport { console } from \"../utils/logging\";\nimport { IndexPointer } from \"./tables\";\nimport { metashrew } from \"../proto/metashrew\";\nconst _updates = new Map<string, ArrayBuffer>();\n\nconst _updateKeys = new Map<string, ArrayBuffer>();\n\nconst BUFFER_SIZE = <u32>0x100000;\nlet _filled: u32 = 0;\n\nexport function input(): ArrayBuffer {\n  const data = new ArrayBuffer(__host_len());\n  __load_input(data);\n  return data;\n}\nexport function hash(k: ArrayBuffer): string {\n  return Box.from(k).toHexString();\n}\nexport function set(k: ArrayBuffer, v: ArrayBuffer): void {\n  const h = hash(k);\n  _updates.set(h, v);\n  _updateKeys.set(h, k);\n}\nexport function get(k: ArrayBuffer): ArrayBuffer {\n  const h = hash(k);\n  let result = changetype<ArrayBuffer>(0);\n  if (!_updates.has(h)) {\n    result = new ArrayBuffer(__get_len(k));\n    __get(k, result);\n    _updates.set(h, result);\n  } else result = _updates.get(h);\n  return result;\n}\n\nexport function getImmutable(k: ArrayBuffer): ArrayBuffer {\n  const result = new ArrayBuffer(__get_len(k));\n  __get(k, result);\n  return result;\n}\n\nfunction arrayBufferToArray(data: ArrayBuffer): Array<u8> {\n  const result = new Array<u8>(data.byteLength);\n  store<usize>(changetype<usize>(result), changetype<usize>(data));\n  store<usize>(\n    changetype<usize>(result) + sizeof<usize>(),\n    changetype<usize>(data),\n  );\n  return result;\n}\n\nexport function _flush(): void {\n  const hashKeys = _updateKeys.keys();\n  const protobufInput = new Array<Array<u8>>();\n  hashKeys.reduce(\n    (r: Array<Array<u8>>, v: string, i: i32, ary: Array<string>) => {\n      r.push(arrayBufferToArray(_updateKeys.get(v)));\n      r.push(arrayBufferToArray(_updates.get(v)));\n      return r;\n    },\n    protobufInput,\n  );\n  const message = new metashrew.KeyValueFlush();\n  message.list = protobufInput;\n  _updateKeys.clear();\n  __flush(message.encode());\n}\n\n/**\n * Class - Index\n *\n * Description:\n * This class is used to encode data and call the __set host function to store an index,\n * this class abstracts database updates as well as rlp encoding & hashing of data and key respectively\n *\n */\nexport class Index {\n  static keyFor(table: ArrayBuffer, key: ArrayBuffer): ArrayBuffer {\n    return Box.concat([Box.from(table), Box.from(key)]);\n  }\n\n  static indexTransactionById(txid: ArrayBuffer, data: ArrayBuffer): void {\n    set(Index.keyFor(TRANSACTION_ID_TO_TRANSACTION, txid), data);\n  }\n\n  // Index: \"/insc/byid\"\n  static indexInscriptionById(inscID: ArrayBuffer, data: ArrayBuffer): void {\n    set(Index.keyFor(INSCRIPTION_ID_TO_INSCRIPTION, inscID), data);\n  }\n\n  // static indexInscriptionsByHeight(height: ArrayBuffer, data: ArrayBuffer): void {\n  //   set(Index.keyFor(HEIGHT_TO_INSCRIPTIONS, height), data);\n  // }\n}\n","// Yet Another Bitcoin Script Parser\n@external(\"env\", \"__log\") declare function __log(s: ArrayBuffer): void;\nexport function _log(s: string): void {\n  console.log(s);\n}\nclass Console {\n  log(v: string): void {\n    __log(String.UTF8.encode(v, true));\n  }\n  logUTF8(data: ArrayBuffer): void {\n    __log(data);\n  }\n}\n\nconst console: Console = new Console();\n\nimport { isPushOp, parsePushOp, parsePrimitive, parseBytes } from \"./utils\";\nimport { Box } from \"./box\";\nimport { nullptr } from \"./pointer\";\n\n// main class for yet-another-bitcoin-script-parser\nexport class Script {\n  public data: Box;\n  public witness_version: usize;\n  constructor(data: Box) {\n    this.data = data;\n    this.witness_version = usize.MAX_VALUE;\n\n    if (this.is_witness_program()) {\n      this.witness_version = this.data.start;\n    }\n  }\n\n  static from(data: Box): Script {\n    return new Script(data);\n  }\n\n  is_p2sh(): boolean {\n    if (this.data.len != 23) {\n      return false;\n    }\n    if (\n      load<u8>(this.data.start) == 0xa9 &&\n      load<u8>(this.data.start + 1) == 0x14 &&\n      load<u8>(this.data.start + 22) == 0x87\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  is_p2pkh(): boolean {\n    if (this.data.len != 25) {\n      return false;\n    }\n    if (\n      load<u8>(this.data.start) == 0x76 &&\n      load<u8>(this.data.start + 1) == 0xa9 &&\n      load<u8>(this.data.start + 2) == 0x14 &&\n      load<u8>(this.data.start + 23) == 0x88 &&\n      load<u8>(this.data.start + 24) == 0xac\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  is_p2pk(): boolean {\n    if (this.data.len != <usize>35 || this.data.len != <usize>67) {\n      return false;\n    }\n\n    if (\n      load<u8>(this.data.start) != 0x21 ||\n      load<u8>(this.data.start) != 0x41\n    ) {\n      return false;\n    }\n\n    if (\n      load<u8>(this.data.start + 34) != 0xac ||\n      load<u8>(this.data.start + 66) != 0xac\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  is_p2tr(): boolean {\n    if (this.data.len != 34) {\n      return false;\n    }\n\n    if (\n      load<u8>(this.data.start) == 0x51 &&\n      load<u8>(this.data.start + 1) == 0x20\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  is_p2wpkh(): boolean {\n    if (this.data.len != 22) {\n      return false;\n    }\n\n    if (\n      load<u8>(this.data.start) == 0x00 &&\n      load<u8>(this.data.start + 1) == 0x14\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  is_p2wsh(): boolean {\n    if (this.data.len != 34) {\n      return false;\n    }\n\n    if (\n      load<u8>(this.witness_version) == 0x00 &&\n      load<u8>(this.data.start + 1) == 0x20\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  is_op_return(): boolean {\n    if (load<u8>(this.data.start) == 0x6a) {\n      return true;\n    }\n    return false;\n  }\n\n  // Checks if a scriptPubKey is a SegWit program.\n  is_witness_program(): boolean {\n    // A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a 1-byte\n    // push opcode (for 0 to 16) followed by a data push between 2 and 40 bytes gets a new\n    // special meaning. The value of the first push is called the \"version byte\". The following\n    // byte vector pushed is called the \"witness program\".\n    let scriptLen = this.data.len;\n    if (scriptLen < 4 || scriptLen > 42) {\n      return false;\n    }\n\n    let ver_opcode = load<u8>(this.data.start);\n    let push_opcode = load<u8>(this.data.start + 1);\n\n    if (!valid_witness_version_from_opcode(ver_opcode)) {\n      return false;\n    }\n    if (push_opcode < 0x02 || push_opcode > 0x28) {\n      return false;\n    }\n\n    return true;\n  }\n}\n\nfunction valid_witness_version_from_opcode(opcode: u8): boolean {\n  if (opcode >= 0x52 || opcode <= 0x60) {\n    return true;\n  } else if (opcode == 0x00 || opcode == 0x51) {\n    return true;\n  }\n  return false;\n}\n\nexport function scriptParse(data: Box): Array<Box> {\n  let stack = new Array<Box>();\n  let view = data.sliceFrom(0);\n\n  while (view.len > 0) {\n    let value = parsePrimitive<u8>(view);\n\n    let opcode = new Box(usize.MAX_VALUE, <usize>value);\n    if (value >= 0x01 && value <= 0x4e) {\n      switch (value) {\n        case 0x4c:\n          stack.push(parseBytes(view, <usize>parsePrimitive<u8>(view)));\n          break;\n        case 0x4d:\n          stack.push(parseBytes(view, <usize>parsePrimitive<u16>(view)));\n          break;\n        case 0x4e:\n          stack.push(parseBytes(view, <usize>parsePrimitive<u32>(view)));\n          break;\n        default:\n          stack.push(parseBytes(view, <usize>value));\n      }\n    } else {\n      stack.push(opcode);\n    }\n  }\n  return stack;\n}\n\nexport function intoAsm(stack: Array<Box>): string {\n  let result = \"\";\n  for (let i = 0; i < stack.length; i++) {\n    let box = stack[i];\n    result += intoString(box) + \" \";\n  }\n\n  return result;\n}\n\nexport function intoString(item: Box): string {\n  if (item.start == usize.MAX_VALUE) {\n    // interpret as opcode\n    let opcode = <u32>item.len;\n    if (opcode >= 82 && opcode <= 96) {\n      return \"OP_\" + (opcode - 80).toString();\n    }\n\n    if (opcode == 76) {\n      return \"OP_PUSHDATA1\";\n    }\n\n    if (opcode == 77) {\n      return \"OP_PUSHDATA2\";\n    }\n\n    if (opcode == 78) {\n      return \"OP_PUSHDATA4\";\n    }\n\n    if (opcode == 0) {\n      return \"OP_FALSE\";\n    }\n\n    if (opcode == 81) {\n      return \"OP_TRUE\";\n    }\n\n    if (opcode == 99) {\n      return \"OP_IF\";\n    }\n\n    if (opcode == 106) {\n      return \"OP_RETURN\";\n    }\n\n    if (opcode == 169) {\n      return \"OP_HASH160\";\n    }\n\n    if (opcode == 172) {\n      return \"OP_CHECKSIG\";\n    }\n\n    return \"\";\n  } else {\n    // interpreate as data\n    return item.toHexString().slice(2);\n  }\n}\n","\"use strict\";\nimport { memcpy } from \"./memcpy\";\n\nconst ENCODING_CONST_BECH32: u32 = 1;\nconst ENCODING_CONST_BECH32M: u32 = 0x2bc830a3;\n\n// const LIMIT: i32 = 90;\nconst ONE = String.UTF8.encode(\"1\");\nconst ALPHABET_MAP: StaticArray<u8> = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 10,\n  17, 21, 20, 26, 30, 7, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 24,\n  13, 25, 9, 8, 23, 0, 18, 22, 31, 27, 19, 0, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4,\n  2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0,\n];\nconst ALPHABET: StaticArray<u8> = [\n  113, 112, 122, 114, 121, 57, 120, 56, 103, 102, 50, 116, 118, 100, 119, 48,\n  115, 51, 106, 110, 53, 52, 107, 104, 99, 101, 54, 109, 117, 97, 55, 108,\n];\n\n\n@inline\nfunction polymodStep(pre: u32): u32 {\n  const b = pre >> 25;\n  return (\n    ((pre & 0x1ffffff) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n  );\n}\n\n\n@inline\nfunction lookupByte(n: u8): u8 {\n  return load<u8>(changetype<usize>(ALPHABET_MAP) + <usize>n);\n}\n\n\n@inline\nfunction encodeByte(n: u8): u8 {\n  return load<u8>(changetype<usize>(ALPHABET) + <usize>n);\n}\n\nfunction prefixChk(prefix: ArrayBuffer): u32 {\n  let chk: u32 = 1;\n  for (let i: i32 = 0; i < prefix.byteLength; ++i) {\n    const c = load<u8>(changetype<usize>(prefix) + <usize>i);\n    if (c < <u8>33 || c > <u8>126)\n      throw Error(\"Invalid prefix (\" + prefix + \")\");\n\n    chk = polymodStep(chk) ^ (c >> 5);\n  }\n  chk = polymodStep(chk);\n\n  for (let i: i32 = 0; i < prefix.byteLength; ++i) {\n    const v = load<u8>(changetype<usize>(prefix) + <usize>i);\n    chk = polymodStep(chk) ^ (<u32>(v & (<u8>0x1f)));\n  }\n  return chk;\n}\n\n// convert function uses Uint8Array instead of Array<u8>\nfunction convert(\n  data: Uint8Array,\n  inBits: u32,\n  outBits: u32,\n  pad: boolean,\n): Array<u8> {\n  let value = 0;\n  let bits: u32 = 0;\n  const maxV = (1 << outBits) - 1;\n\n  const result: Array<u8> = new Array(0);\n\n  for (let i = 0; i < data.length; i++) {\n    value = (value << inBits) | data[i];\n    bits += inBits;\n\n    while (bits >= outBits) {\n      bits -= outBits;\n      result.push(<u8>((value >> bits) & maxV));\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push(<u8>((value << (outBits - bits)) & maxV));\n    }\n  } else {\n    if (bits >= inBits) throw Error(\"Excess padding\");\n    if ((value << (outBits - bits)) & maxV) throw Error(\"Non-zero padding\");\n  }\n\n  return result;\n}\n\nexport function toWords(bytes: ArrayBuffer): Array<u8> {\n  let data = Uint8Array.wrap(bytes);\n  return convert(data, 8, 5, true);\n}\n\nexport function encode(\n  prefix: ArrayBuffer,\n  words: Array<u8>,\n  encoding: u32,\n  LIMIT: i32 = 90,\n): ArrayBuffer {\n  if (prefix.byteLength + 7 + words.length > LIMIT)\n    throw new Error(\"Exceeds length limit\");\n\n  let chk = prefixChk(prefix);\n\n  const result = new ArrayBuffer(prefix.byteLength + 7 + words.length);\n  memcpy(\n    changetype<usize>(result),\n    changetype<usize>(prefix),\n    prefix.byteLength,\n  );\n  let ptr: usize = changetype<usize>(result) + prefix.byteLength;\n  store<u8>(ptr, load<u8>(changetype<usize>(ONE)));\n  ptr++;\n  for (let i = 0; i < words.length; ++i) {\n    const x = words[i];\n    if (x >> 5 !== 0) throw new Error(\"Non 5-bit word\");\n    chk = polymodStep(chk) ^ x;\n    store<u8>(ptr + i, encodeByte(x));\n  }\n  ptr += <usize>words.length;\n\n  for (let i: u32 = 0; i < 6; ++i) {\n    chk = polymodStep(chk);\n  }\n  chk ^= encoding;\n\n  for (let i = 0; i < 6; ++i) {\n    const v = (chk >> ((5 - i) * 5)) & 0x1f;\n    store<u8>(ptr + i, encodeByte(<u8>v));\n  }\n\n  return result;\n}\n\nexport function bech32m(prefix: ArrayBuffer, words: Array<u8>): ArrayBuffer {\n  return encode(prefix, words, ENCODING_CONST_BECH32M);\n}\n\nexport function bech32(prefix: ArrayBuffer, words: Array<u8>): ArrayBuffer {\n  return encode(prefix, words, ENCODING_CONST_BECH32);\n}\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        let ia = reinterpret<i32>(f32(a));\n        let ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        let ia = reinterpret<i64>(f64(a));\n        let ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (\n        changetype<usize>(a) == changetype<usize>(b) ||\n        changetype<usize>(a) == 0 ||\n        changetype<usize>(b) == 0\n      ) return 0;\n      let alen = changetype<string>(a).length;\n      let blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  let lgPlus2         = log2u(len) + 2;\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  let buffer = __alloc(len << alignof<T>());\n\n  let hi   = len - 1;\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  let lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  let top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  let n: u64 = right - left + 1;\n  let s = startB - (left << 1);\n  let l = startA + s;\n  let r = endB   + s + 1;\n  let a = (<u64>l << 30) / n;\n  let b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  let j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  let i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    let hasSur = surr > 0;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    let length = units.length;\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    let ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    let hasSur = <u32>code > 0xFFFF;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    let len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    let out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    let len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    let thisSize: isize = this.length << 1;\n    let otherSize: isize = other.length << 1;\n    let outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    let searchLength = <isize>search.length;\n    let searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    let leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return false;\n    let rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let rightLength = right.length;\n    if (!rightLength) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    let len = <isize>this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    let len = this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    let alen = this.length;\n    let blen = other.length;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\n    res = res ? res : alen - blen;\n    // normalize to [-1, 1] range\n    return i32(res > 0) - i32(res < 0);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    let len = <isize>this.length;\n    let searchStart = min(max(<isize>start, 0), len);\n    let searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    let intStart: isize = start;\n    let end: isize = length;\n    let len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    let size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len: isize = this.length;\n    let finalStart = min<isize>(max(start, 0), len);\n    let finalEnd = min<isize>(max(end, 0), len);\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\n    let size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    let len = this.length;\n    let size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    let size = <usize>this.length << 1;\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    let originalSize = <usize>this.length << 1;\n    let size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let prependSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let appendSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    let length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    let len: usize = this.length;\n    let slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    let index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    let thisLen: usize = this.length;\n    let searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    let replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    let prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    let length: isize = this.length;\n    let sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    let end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    let len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    let specialsLen = SPECIALS_UPPER.length;\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      let strOff = changetype<usize>(str);\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      let bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      let strEnd = str + (<usize>len << 1);\n      let bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      let bufOff = buf;\n      let bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      let strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      let size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","\"use strict\";\nimport { concat } from \"./utils\";\n\nconst ALPHABET: StaticArray<u8> = [\n  49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 74, 75,\n  76, 77, 78, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101,\n  102, 103, 104, 105, 106, 107, 109, 110, 111, 112, 113, 114, 115, 116, 117,\n  118, 119, 120, 121, 122,\n];\n\n\n@inline const BASE = 58;\nconst LEADER = ALPHABET[0];\n\n// log(256) / log(58) = 1.365658237309761 ~= 554 / 405\n@inline const FACTOR_NUM = 406;\n\n\n@inline const FACTOR_DEN = 554;\n\n\n@inline const INV_FACTOR_NUM = FACTOR_DEN;\n\n\n@inline const INV_FACTOR_DEN = FACTOR_NUM - 1;\n\n\n@inline\nfunction INV_FACTOR(length: i32): i32 {\n  return (length * INV_FACTOR_NUM) / INV_FACTOR_DEN + 1; // log(256) / log(58), rounded up\n}\n\n/**\n * Encode Uint8Array as a base58 string.\n * @param bytes Byte array of type Uint8Array.\n */\nexport function base58(source: Uint8Array): ArrayBuffer {\n  // Skip & count leading zeroes.\n  let pend = source.length;\n  let pbegin = 0;\n  while (pbegin != pend && source[pbegin] == 0) ++pbegin;\n  let zeroes = pbegin;\n\n  // Allocate enough space in big-endian base58 representation.\n  let size = INV_FACTOR(pend - pbegin);\n  let b58 = new Uint8Array(size);\n  let length = 0;\n\n  // Process the bytes.\n  while (pbegin != pend) {\n    let carry = u32(source[pbegin]);\n    // Apply \"b58 = b58 * 256 + ch\".\n    let i = 0;\n    for (let it = size - 1; it != -1 && (carry != 0 || i < length); --it, ++i) {\n      carry += u32(b58[it]) << 8;\n      b58[it] = carry % BASE;\n      carry = carry / BASE;\n    }\n    if (ASC_OPTIMIZE_LEVEL == 0) {\n      assert(!carry, \"Non-zero carry\");\n    }\n    length = i;\n    pbegin++;\n  }\n\n  // Skip leading zeroes in base58 result.\n  let it = size - length;\n  while (it != size && b58[it] == 0) ++it;\n\n  let result = new Uint8Array(zeroes + b58.length);\n  result.fill(LEADER, 0, zeroes);\n  for (; it < size; ++it) {\n    result[zeroes++] = ALPHABET[b58[it]];\n  }\n  return result.buffer;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    let length = source.length;\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    return source.concat<StaticArray<T>>(other);\n  }\n\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    return source.slice<StaticArray<T>>(start, end);\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    let len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    let ptr = changetype<usize>(this);\n    let len = this.length;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    let length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\n    let sourceLen = this.length;\n    let otherLen = other.length;\n    let outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\n      throw new Error(E_INVALIDLENGTH);\n    }\n    let sourceSize = <usize>sourceLen << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      let otherStart = changetype<Array<T>>(other).dataStart;\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else if (out instanceof StaticArray<T>) {\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      let otherStart = changetype<usize>(other);\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\n    let length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\n    length = max(end - start, 0);\n\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\n    let size = <usize>length << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      // return Array\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(changetype<usize>(out), ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else if (out instanceof StaticArray<T>) {\n      // return StaticArray\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(outStart, ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    let len = this.length;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): StaticArray<T> {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","@final\n@unmanaged\nexport class Field {\n  static BODY: u64 = 0;\n  static FLAGS: u64 = 2;\n  static RUNE: u64 = 4;\n  static PREMINE: u64 = 6;\n  static CAP: u64 = 8;\n  static AMOUNT: u64 = 10;\n  static HEIGHTSTART: u64 = 12;\n  static HEIGHTEND: u64 = 14;\n  static OFFSETSTART: u64 = 16;\n  static OFFSETEND: u64 = 18;\n  static MINT: u64 = 20;\n  static POINTER: u64 = 22;\n  static CENOTAPH: u64 = 126;\n  static DIVISIBILITY: u64 = 1;\n  static SPACERS: u64 = 3;\n  static SYMBOL: u64 = 5;\n  static NOP: u64 = 127;\n  constructor() {}\n}\n","import { u128 } from \"as-bignum/assembly\";\nimport { IndexPointer } from \"metashrew-as/assembly/indexer/tables\";\n\nexport const RUNESTONE_TAG: u16 = 0x5d6a;\n\nexport const OP_RETURN: u8 = 0x6a;\n\nexport const GENESIS: u32 = 840000;\n\nexport const HEIGHT_TO_BLOCKHASH = IndexPointer.for(\"/blockhash/byheight/\");\nexport const BLOCKHASH_TO_HEIGHT = IndexPointer.for(\"/height/byblockhash/\");\nexport const OUTPOINT_TO_RUNES = IndexPointer.for(\"/runes/byoutpoint/\");\nexport const OUTPOINT_TO_HEIGHT = IndexPointer.for(\"/height/byoutpoint/\");\nexport const HEIGHT_TO_TRANSACTION_IDS = IndexPointer.for(\"/txids/byheight\");\nexport const SYMBOL = IndexPointer.for(\"/runes/symbol/\");\nexport const CAP = IndexPointer.for(\"/runes/cap/\");\nexport const SPACERS = IndexPointer.for(\"/runes/spaces/\");\nexport const OFFSETEND = IndexPointer.for(\"/runes/offset/end/\");\nexport const OFFSETSTART = IndexPointer.for(\"/runes/offset/start/\");\nexport const HEIGHTSTART = IndexPointer.for(\"/runes/height/start/\");\nexport const HEIGHTEND = IndexPointer.for(\"/runes/height/end/\");\nexport const AMOUNT = IndexPointer.for(\"/runes/amount/\");\nexport const MINTS_REMAINING = IndexPointer.for(\"/runes/mints-remaining/\");\nexport const PREMINE = IndexPointer.for(\"/runes/premine/\");\nexport const DIVISIBILITY = IndexPointer.for(\"/runes/divisibility/\");\nexport const RUNE_ID_TO_HEIGHT = IndexPointer.for(\"/height/byruneid/\");\nexport const ETCHINGS = IndexPointer.for(\"/runes/names\");\nexport const RUNE_ID_TO_ETCHING = IndexPointer.for(\"/etching/byruneid/\");\nexport const ETCHING_TO_RUNE_ID = IndexPointer.for(\"/runeid/byetching/\");\n\nexport const MINIMUM_NAME = u128.from(\"99246114928149462\");\nexport const TWENTY_SIX = u128.from(26);\nexport const RESERVED_NAME = u128.from(\"6402364363415443603228541259936211926\");\nexport const SUBSIDY_HALVING_INTERVAL: u64 = 210_000;\nexport const HEIGHT_INTERVAL: u64 = 17_500;\nexport const MAX_BYTES_LEB128_INT: usize = 18;","import { _flush, input, getImmutable, get, set } from \"./index\";\nimport { memcpy } from \"../utils/memcpy\";\nimport { Box } from \"../utils/box\";\nimport { console } from \"../utils/logging\";\n\nexport class Node {\n  public key: ArrayBuffer;\n  public value: ArrayBuffer;\n  constructor(key: ArrayBuffer, value: ArrayBuffer) {\n    this.key = key;\n    this.value = value;\n  }\n\n\n  @inline\n  static from(key: ArrayBuffer, value: ArrayBuffer): Node {\n    return new Node(key, value);\n  }\n}\n\n\n@final\n@unmanaged\nexport class IndexPointer {\n  [key: number]: number;\n  constructor(keyPrefix: ArrayBuffer) {\n    return IndexPointer.wrap(keyPrefix);\n  }\n  static wrap(pointer: ArrayBuffer): IndexPointer {\n    return changetype<IndexPointer>(pointer);\n  }\n  static for(keyword: string): IndexPointer {\n    return IndexPointer.wrap(String.UTF8.encode(keyword));\n  }\n  unwrap(): ArrayBuffer {\n    return changetype<ArrayBuffer>(this);\n  }\n  select(key: ArrayBuffer): IndexPointer {\n    const res = Box.concat([Box.from(this.unwrap()), Box.from(key)]);\n    return IndexPointer.wrap(res);\n  }\n  selectValue<T>(key: T): IndexPointer {\n    const keyBytes = new ArrayBuffer(sizeof<T>());\n    store<T>(changetype<usize>(keyBytes), bswap<T>(key));\n    return this.select(keyBytes);\n  }\n  keyword(key: string): IndexPointer {\n    return this.select(String.UTF8.encode(key));\n  }\n  getValue<T>(): T {\n    const value = this.get();\n    if (value.byteLength === 0) return <T>0;\n    const container = new ArrayBuffer(sizeof<T>());\n    memcpy(\n      changetype<usize>(container),\n      changetype<usize>(value),\n      value.byteLength,\n    );\n    return load<T>(changetype<usize>(container));\n  }\n  getImmutableValue<T>(): T {\n    const value = this.getImmutable();\n    if (value.byteLength === 0) return <T>0;\n    const container = new ArrayBuffer(sizeof<T>());\n    memcpy(\n      changetype<usize>(container),\n      changetype<usize>(value),\n      value.byteLength,\n    );\n    return load<T>(changetype<usize>(container));\n  }\n  setValue<T>(v: T): void {\n    const value = new ArrayBuffer(sizeof<T>());\n    store<T>(changetype<usize>(value), v);\n    this.set(value);\n  }\n  set(v: ArrayBuffer): void {\n    set(this.unwrap(), v);\n  }\n  get(): ArrayBuffer {\n    return Box.from(get(this.unwrap())).toArrayBuffer();\n  }\n  getImmutable(): ArrayBuffer {\n    return getImmutable(this.unwrap());\n  }\n  lengthKey(): IndexPointer {\n    return this.keyword(\"/length\");\n  }\n  length(): u32 {\n    return this.lengthKey().getValue<u32>();\n  }\n  getList(): Array<ArrayBuffer> {\n    const result = new Array<ArrayBuffer>(<i32>this.length());\n    for (let i: i32 = 0; i < result.length; i++) {\n      result[i] = this.selectIndex(i).get();\n    }\n    return result;\n  }\n  getListValues<T>(): Array<T> {\n    const result = new Array<T>(<i32>this.length());\n    for (let i: i32 = 0; i < result.length; i++) {\n      result[i] = this.selectIndex(i).getValue<T>();\n    }\n    return result;\n  }\n  extend(): IndexPointer {\n    const lengthKey = this.lengthKey();\n    const length = lengthKey.getValue<u32>();\n    lengthKey.setValue<u32>(length + 1);\n    return this.selectIndex(length);\n  }\n  selectIndex(index: u32): IndexPointer {\n    return this.keyword(\"/\" + index.toString(10));\n  }\n  nullify(): void {\n    this.set(new ArrayBuffer(0));\n  }\n  pop(): ArrayBuffer {\n    const lengthKey = this.lengthKey();\n    const length = lengthKey.getValue<u32>();\n    if (length === 0) return new ArrayBuffer(0);\n    const newLength = length - 1;\n    lengthKey.setValue<u32>(newLength);\n    return this.selectIndex(newLength).get();\n  }\n  popValue<T>(): ArrayBuffer {\n    const lengthKey = this.lengthKey();\n    const length = lengthKey.getValue<u32>();\n    if (length === 0) return new ArrayBuffer(0);\n    const newLength = length - 1;\n    lengthKey.setValue<u32>(newLength);\n    return this.selectIndex(newLength).getValue<T>();\n  }\n  append(v: ArrayBuffer): void {\n    this.extend().set(v);\n  }\n  appendValue<T>(v: T): void {\n    this.extend().setValue<T>(v);\n  }\n}\n/*\n\nexport class ListPointer {\n  public keyPrefix: ArrayBuffer;\n  constructor(key: ArrayBuffer) {\n    this.keyPrefix = prefix;\n\n  }\n  static lengthKey(key: ArrayBuffer): ArrayBuffer {\n    return Box.concat([\n      Box.from(key),\n      Box.from(String.UTF8.encode(\"/length\"))\n    ]);\n  }\n  static tipKey(key: ArrayBuffer): ArrayBuffer {\n    return Box.concat([\n      Box.from(key),\n      Box.from(String.UTF8.encode(\"/tip\"))\n    ]);\n  }\n  static nextKey(key: ArrayBuffer): ArrayBuffer {\n    return Box.concat([\n      Box.from(key),\n      Box.from(String.UTF8.encode(\"/next\"))\n    ]);\n  }\n  static subKey(key: ArrayBuffer, subKey: ArrayBuffer): ArrayBuffer {\n    return Box.concat([\n      Box.from(key),\n      Box.from(String.UTF8.encode(\"/\")),\n      Box.from(subKey)\n    ]);\n  }\n  static previousKey(key: ArrayBuffer): ArrayBuffer {\n    return Box.concat([\n      Box.from(key),\n      Box.from(String.UTF8.encode(\"/previous\"))\n    ]);\n  }\n  static appendNode(key: ArrayBuffer, subKey: ArrayBuffer, value: ArrayBuffer): void {\n    const tableKey = Table.keyFor(key);\n    let nextKey = Table.tipKey(tableKey);\n    let tip = get(tipKey);\n    let previous = new ArrayBuffer(0);\n    let i = 0;\n    while (tip.byteLength !== 0) {\n      previous = tip;\n      nextKey = Table.nextKey(Table.subKey(tableKey, tip));\n      tip = get(nextKey);\n      i++;\n    }\n    if (i > 0) {\n      set(Table.previousKey(Table.subKey(tableKey, subKey)), previous);\n      set(Table.nextKey(Table.subKey(tableKey, previous)), subKey);\n    }\n    set(Table.subKey(tableKey, subKey), value);\n  }\n  static listKey(key: ArrayBuffer, i: u32): ArrayBuffer {\n    return Box.concat([\n      Box.from(key),\n      Box.from(String.UTF8.encode(\"/\")),\n      Box.from(String.UTF8.encode(i.toString(10)))\n    ]);\n  }\n  static keyFor(table: ArrayBuffer, key: ArrayBuffer): ArrayBuffer {\n    return Box.concat([Box.from(table), Box.from(key)]);\n  }\n  public tableKey(key: ArrayBuffer): ArrayBuffer {\n    return Table.keyFor(this.keyPrefix, key);\n  }\n  static open(prefix: ArrayBuffer): Table {\n    return new Table(prefix);\n  }\n  fromLinkedList(key: ArrayBuffer): Array<Node> {\n    let tip = this.get(Table.tipKey(key));\n    const result: Array<Node> = [];\n    if (tip.byteLength === 0) return [];\n    while (tip.byteLength !== 0) {\n      result.push(Node.from(tip, this.get(Table.subKey(key, tip))));\n      tip = this.get(Table.nextKey(Table.subKey(key, tip)));\n    }\n    return result;\n  }\n}\nexport const HEIGHT_TO_BLOCKHASH = Table.open(String.UTF8.encode(\"/block/byheight\"));\nexport const BLOCKHASH_TO_HEIGHT = Table.open(String.UTF8.encode(\"/height/byhash\"));\nexport const SAT_TO_SATPOINT = Table.open(String.UTF8.encode(\"/satpoint/byordinal\"));\nexport const SAT_TO_INSCRIPTION_ID = Table.open(String.UTF8.encode(\"/inscription/byordinal\"));\nexport const INSCRIPTION_TO_SATPOINT = Table.open(String.UTF8.encode(\"/satpoint/byinscription\"));\nexport const SATPOINT_TO_INSCRIPTION = Table.open(String.UTF8.encode(\"/inscription/bysatpoint\"));\nexport const OUTPOINT_TO_SATRANGES = Table.open(String.UTF8.encode(\"/satranges/byoutpoint\"));\nexport const OUTPOINT_TO_VALUE = Table.open(String.UTF8.encode(\"/outpoint/tovalue\"));\nexport const SEQUENCE_TO_INSCRIPTION_ID = Table.open(String.UTF8.encode(\"/inscription/bysequence\"));\nexport const SEQUENCE_NUMBER_TO_SATPOINT = Table.open(String.UTF8.encode(\"/satpoint/bysequencenumber\"));\nexport const SEQUENCE_NUMBER_TO_ENTRY = Table.open(String.UTF8.encode(\"/entry/bysequencenumber\"));\nexport const SEQUENCE_NUMBER_TO_CHILDREN = Table.open(String.UTF8.encode(\"/children/bysequencenumber\"));\nexport const SAT_TO_SEQUENCE_NUMBER = Table.open(String.UTF8.encode(\"/sequencenumber/bysat\"));\nexport const INSCRIPTION_NUMBER_TO_SEQUENCE_NUMBER = Table.open(String.UTF8.encode(\"/sequencenumber/byinscriptionnumber\"));\nexport const ID_TO_SEQUENCE_NUMBER = Table.open(String.UTF8.encode(\"/sequencenumber/byid\"));\nexport const HOME_INSCRIPTIONS = Table.open(String.UTF8.encode(\"/homeinscriptions\"));\nexport const SATPOINT_TO_SEQUENCE_NUMBER = Table.open(String.UTF8.encode(\"/sequencenumber/bysatpoint\"));\nexport const CONTENT_TYPE_TO_COUNT = Table.open(String.UTF8.encode(\"/count/bycontenttype\"));\nexport const VALUE_CACHE = Table.open(String.UTF8.encode(\"/valuecache\"));\nexport const TRANSACTION_ID_TO_TRANSACTION = Table.open(String.UTF8.encode(\"/transaction/byid\"));\n*/\n","import { i128 } from './i128';\nimport { i256 } from './i256';\nimport { u256 } from './u256';\n\n// TODO import this on top level 'index.ts'\nimport {\n  __clz128,\n  __ctz128,\n  __floatuntidf,\n\n  __multi3,\n  __res128_hi,\n\n  __udivmod128,\n  __udivmod128_10,\n\n  __divmod_quot_hi,\n  __divmod_rem_lo,\n  __divmod_rem_hi,\n} from '../globals';\n\nimport { atou128, u128toDecimalString } from '../utils';\n\n@lazy const HEX_CHARS = '0123456789abcdef';\n\nexport class u128 {\n\n  @inline static get Zero(): u128 { return new u128(); }\n  @inline static get One():  u128 { return new u128(1); }\n  @inline static get Min():  u128 { return new u128(); }\n  @inline static get Max():  u128 { return new u128(-1, -1); }\n\n  @inline\n  static fromString(value: string, radix: i32 = 10): u128 {\n    return atou128(value, radix);\n  }\n\n  @inline\n  static fromI256(value: i256): u128 {\n    return new u128(value.lo1, value.lo2);\n  }\n\n  @inline\n  static fromU256(value: u256): u128 {\n    return new u128(value.lo1, value.lo2);\n  }\n\n  @inline\n  static fromI128(value: i128): u128 {\n    return new u128(value.lo, value.hi);\n  }\n\n  @inline\n  static fromU128(value: u128): u128 {\n    return new u128(value.lo, value.hi);\n  }\n\n  @inline\n  static fromI64(value: i64): u128 {\n    return new u128(value, value >> 63);\n  }\n\n  @inline\n  static fromU64(value: u64): u128 {\n    return new u128(value);\n  }\n\n  // TODO need improvement\n  // max safe uint for f64 actually 53-bits\n  @inline\n  static fromF64(value: f64): u128 {\n    return new u128(<u64>value, reinterpret<i64>(value) >> 63);\n  }\n\n  // TODO need improvement\n  // max safe int for f32 actually 23-bits\n  @inline\n  static fromF32(value: f32): u128 {\n    return new u128(<u64>value, <u64>(reinterpret<i32>(value) >> 31));\n  }\n\n  @inline\n  static fromI32(value: i32): u128 {\n    return new u128(value, value >> 31);\n  }\n\n  @inline\n  static fromU32(value: u32): u128 {\n    return new u128(value);\n  }\n\n  @inline\n  static fromBool(value: bool): u128 {\n    return new u128(<u64>value);\n  }\n\n  @inline\n  static fromBits(lo1: u32, lo2: u32, hi1: u32, hi2: u32): u128 {\n    return new u128(\n      <u64>lo1 | ((<u64>lo2) << 32),\n      <u64>hi1 | ((<u64>hi2) << 32),\n    );\n  }\n\n  @inline\n  static fromBytes<T>(array: T, bigEndian: bool = false): u128 {\n    if (array instanceof u8[]) {\n      return bigEndian\n        ? u128.fromBytesBE(<u8[]>array)\n        : u128.fromBytesLE(<u8[]>array);\n    } else if (array instanceof Uint8Array) {\n      return bigEndian\n        ? u128.fromUint8ArrayBE(<Uint8Array>array)\n        : u128.fromUint8ArrayLE(<Uint8Array>array);\n    } else {\n      throw new TypeError(\"Unsupported generic type\");\n    }\n  }\n\n  @inline\n  static fromBytesLE(array: u8[]): u128 {\n    return u128.fromUint8ArrayLE(changetype<Uint8Array>(array));\n  }\n\n  @inline\n  static fromBytesBE(array: u8[]): u128 {\n    return u128.fromUint8ArrayBE(changetype<Uint8Array>(array));\n  }\n\n  @inline\n  static fromUint8ArrayLE(array: Uint8Array): u128 {\n    assert(array.length && (array.length & 15) == 0);\n    // @ts-ignore\n    var buffer = array.dataStart;\n    return new u128(\n      load<u64>(buffer, 0 * sizeof<u64>()),\n      load<u64>(buffer, 1 * sizeof<u64>())\n    );\n  }\n\n  @inline\n  static fromUint8ArrayBE(array: Uint8Array): u128 {\n    assert(array.length && (array.length & 15) == 0);\n    // @ts-ignore\n    var buffer = array.dataStart;\n    return new u128(\n      bswap<u64>(load<u64>(buffer, 1 * sizeof<u64>())),\n      bswap<u64>(load<u64>(buffer, 0 * sizeof<u64>()))\n    );\n  }\n\n  /**\n   * Create 128-bit unsigned integer from generic type T\n   * @param  value\n   * @returns 128-bit unsigned integer\n   */\n  @inline\n  static from<T>(value: T): u128 {\n         if (value instanceof bool)   return u128.fromU64(<u64>value);\n    else if (value instanceof i8)     return u128.fromI64(<i64>value);\n    else if (value instanceof u8)     return u128.fromU64(<u64>value);\n    else if (value instanceof i16)    return u128.fromI64(<i64>value);\n    else if (value instanceof u16)    return u128.fromU64(<u64>value);\n    else if (value instanceof i32)    return u128.fromI64(<i64>value);\n    else if (value instanceof u32)    return u128.fromU64(<u64>value);\n    else if (value instanceof i64)    return u128.fromI64(<i64>value);\n    else if (value instanceof u64)    return u128.fromU64(<u64>value);\n    else if (value instanceof f32)    return u128.fromF64(<f64>value);\n    else if (value instanceof f64)    return u128.fromF64(<f64>value);\n    else if (value instanceof i128)   return u128.fromI128(<i128>value);\n    else if (value instanceof u128)   return u128.fromU128(<u128>value);\n    else if (value instanceof i256)   return u128.fromI256(<i256>value);\n    else if (value instanceof u256)   return u128.fromU256(<u256>value);\n    else if (value instanceof u8[])   return u128.fromBytes(<u8[]>value);\n    else if (value instanceof Uint8Array) return u128.fromBytes(<Uint8Array>value);\n    else if (value instanceof String) return u128.fromString(<string>value);\n    else throw new TypeError(\"Unsupported generic type\");\n  }\n\n  /**\n   * Create 128-bit unsigned integer from 64-bit parts\n   * @param lo low  64-bit part of 128-bit unsigned integer\n   * @param hi high 64-bit part of 128-bit unsigned integer\n   */\n  constructor(\n    public lo: u64 = 0,\n    public hi: u64 = 0,\n  ) {}\n\n  @inline\n  set(value: u128): this {\n    this.lo = value.lo;\n    this.hi = value.hi;\n    return this;\n  }\n\n  @inline\n  setI64(value: i64): this {\n    this.lo = value;\n    this.hi = value >> 63;\n    return this;\n  }\n\n  @inline\n  setU64(value: u64): this {\n    this.lo = value;\n    this.hi = 0;\n    return this;\n  }\n\n  @inline\n  setI32(value: i32): this {\n    this.lo = value;\n    this.hi = value >> 63;\n    return this;\n  }\n\n  @inline\n  setU32(value: u32): this {\n    this.lo = value;\n    this.hi = 0;\n    return this;\n  }\n\n  @inline\n  isZero(): bool {\n    return !(this.lo | this.hi);\n  }\n\n  @inline @operator.prefix('~')\n  not(): u128 {\n    return new u128(~this.lo, ~this.hi);\n  }\n\n  @inline @operator.prefix('+')\n  pos(): u128 {\n    return this;\n  }\n\n  @inline @operator.prefix('-')\n  neg(): u128 {\n    var lo = ~this.lo;\n    var hi = ~this.hi;\n    var lo1 = lo + 1;\n    return new u128(lo1, hi + u64(lo1 < lo));\n  }\n\n  @operator.prefix('++')\n  preInc(): this {\n    var lo = this.lo;\n    var lo1 = lo + 1;\n    this.hi += u64(lo1 < lo);\n    this.lo = lo1;\n    return this;\n  }\n\n  @operator.prefix('--')\n  preDec(): this {\n    var lo = this.lo;\n    var lo1 = lo - 1;\n    this.hi -= u64(lo1 > lo);\n    this.lo = lo1;\n    return this;\n  }\n\n  @operator.postfix('++')\n  postInc(): u128 {\n    return this.clone().preInc();\n  }\n\n  @operator.postfix('--')\n  postDec(): u128 {\n    return this.clone().preDec();\n  }\n\n  @inline @operator.prefix('!')\n  static isEmpty(value: u128): bool {\n    return !(value.lo | value.hi);\n  }\n\n  @inline @operator('|')\n  static or(a: u128, b: u128): u128 {\n    return new u128(a.lo | b.lo, a.hi | b.hi);\n  }\n\n  @inline @operator('^')\n  static xor(a: u128, b: u128): u128 {\n    return new u128(a.lo ^ b.lo, a.hi ^ b.hi);\n  }\n\n  @inline @operator('&')\n  static and(a: u128, b: u128): u128 {\n    return new u128(a.lo & b.lo, a.hi & b.hi);\n  }\n\n  @inline @operator('<<')\n  static shl(value: u128, shift: i32): u128 {\n    shift &= 127;\n\n    // need for preventing redundant i32 -> u64 extends\n    var shift64 = shift as u64;\n\n    var mod1 = ((((shift64 + 127) | shift64) & 64) >> 6) - 1;\n    var mod2 = (shift64 >> 6) - 1;\n\n    shift64 &= 63;\n\n    var vl = value.lo;\n    var lo = vl << shift64;\n    var hi = lo & ~mod2;\n\n    hi |= ((value.hi << shift64) | ((vl >> (64 - shift64)) & mod1)) & mod2;\n\n    return new u128(lo & mod2, hi);\n  }\n\n  @inline @operator('>>')\n  static shr(value: u128, shift: i32): u128 {\n    shift &= 127;\n\n    // need for preventing redundant i32 -> u64 extends\n    var shift64 = shift as u64;\n\n    var mod1 = ((((shift64 + 127) | shift64) & 64) >> 6) - 1;\n    var mod2 = (shift64 >> 6) - 1;\n\n    shift64 &= 63;\n\n    var vh = value.hi;\n    var hi = vh >> shift64;\n    var lo = hi & ~mod2;\n\n    lo |= ((value.lo >> shift64) | ((vh << (64 - shift64)) & mod1)) & mod2;\n\n    return new u128(lo, hi & mod2);\n  }\n\n  @inline @operator('>>>')\n  static shr_u(value: u128, shift: i32): u128 {\n    return u128.shr(value, shift);\n  }\n\n  @inline\n  static rotl(value: u128, shift: i32): u128 {\n    let n = shift & 127;\n    if (n == 0) return value.clone();\n\n    let lo = value.lo;\n    let hi = value.hi;\n    if (n == 64) {\n      return new u128(hi, lo);\n    }\n    if (n & 64) {\n      let t = lo; lo = hi; hi = t;\n    }\n    let slo = lo << n;\n    let shi = hi << n;\n    let rlo = lo >> (64 - n);\n    let rhi = hi >> (64 - n);\n    return new u128(slo | rhi, shi | rlo);\n  }\n\n  @inline\n  static rotr(value: u128, shift: i32): u128 {\n    let n = shift & 127;\n    if (n == 0) return value.clone();\n\n    let lo = value.lo;\n    let hi = value.hi;\n    if (n == 64) {\n      return new u128(hi, lo);\n    }\n    if (n & 64) {\n      let t = lo; lo = hi; hi = t;\n    }\n    let slo = lo >> n;\n    let shi = hi >> n;\n    let rlo = lo << (64 - n);\n    let rhi = hi << (64 - n);\n    return new u128(slo | rhi, shi | rlo);\n  }\n\n  @inline @operator('+')\n  static add(a: u128, b: u128): u128 {\n    var alo = a.lo;\n    var lo = alo + b.lo;\n    var hi = a.hi + b.hi + u64(lo < alo);\n    return new u128(lo, hi);\n  }\n\n  @inline @operator('-')\n  static sub(a: u128, b: u128): u128 {\n    var alo = a.lo;\n    var lo = alo - b.lo;\n    var hi = a.hi - b.hi - u64(lo > alo);\n    return new u128(lo, hi);\n  }\n\n  // mul: u128 x u128 = u128\n  @inline @operator('*')\n  static mul(a: u128, b: u128): u128 {\n    return new u128(\n      __multi3(a.lo, a.hi, b.lo, b.hi),\n      __res128_hi\n    );\n  }\n\n  @inline @operator('/')\n  static div(a: u128, b: u128): u128 {\n    return new u128(\n      __udivmod128(a.lo, a.hi, b.lo, b.hi),\n      __divmod_quot_hi\n    );\n  }\n\n  @inline @operator('%')\n  static rem(a: u128, b: u128): u128 {\n    __udivmod128(a.lo, a.hi, b.lo, b.hi);\n    return new u128(__divmod_rem_lo, __divmod_rem_hi);\n  }\n\n  @inline\n  static div10(value: u128): u128 {\n    return new u128(\n      __udivmod128_10(value.lo, value.hi),\n      __divmod_quot_hi\n    );\n  }\n\n  @inline\n  static rem10(value: u128): u128 {\n    __udivmod128_10(value.lo, value.hi);\n    return new u128(__divmod_rem_lo, __divmod_rem_hi);\n  }\n\n  /**\n   * Calculate power of base with exponent\n   * @param  base     128-bit unsigned integer\n   * @param  exponent 32-bit signed integer\n   * @returns         128-bit unsigned integer\n   */\n  @operator('**')\n  static pow(base: u128, exponent: i32): u128 {\n    // any negative exponent produce zero\n\n    var result = u128.One;\n\n    if (base == result) return result;\n    var tmp = base.clone();\n    if (exponent <= 1) {\n      if (exponent < 0) return u128.Zero;\n      return exponent == 0 ? result : tmp;\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      var lo = base.lo;\n      var hi = base.hi;\n      // if base > u64::max and exp > 1 always return \"0\"\n      if (!lo) return u128.Zero;\n      if (!hi) {\n        let lo1 = lo - 1;\n        // \"1 ^ exponent\" always return \"1\"\n        if (!lo1) return result;\n\n        // if base is power of two do \"1 << log2(base) * exp\"\n        if (!(lo & lo1)) {\n          let shift = <i32>(64 - clz(lo1)) * exponent;\n          // @ts-ignore\n          return shift < 128 ? result << shift : u128.Zero;\n        }\n      }\n\n      if (exponent <= 4) {\n        let baseSq = tmp.sqr();\n        switch (exponent) {\n          case 2: return baseSq;        // base ^ 2\n          // @ts-ignore\n          case 3: return baseSq * base; // base ^ 2 * base\n          case 4: return baseSq.sqr();  // base ^ 2 * base ^ 2\n          default: break;\n        }\n      }\n\n      let log = 32 - clz(exponent);\n      if (log <= 7) {\n        // 128 = 2 ^ 7, so need usually only seven cases\n        switch (log) {\n          case 7:\n            // @ts-ignore\n            if (exponent & 1) result *= tmp;\n            exponent >>= 1;\n            tmp.sqr();\n          case 6:\n            // @ts-ignore\n            if (exponent & 1) result *= tmp;\n            exponent >>= 1;\n            tmp.sqr();\n          case 5:\n            // @ts-ignore\n            if (exponent & 1) result *= tmp;\n            exponent >>= 1;\n            tmp.sqr();\n          case 4:\n            // @ts-ignore\n            if (exponent & 1) result *= tmp;\n            exponent >>= 1;\n            tmp.sqr();\n          case 3:\n            // @ts-ignore\n            if (exponent & 1) result *= tmp;\n            exponent >>= 1;\n            tmp.sqr();\n          case 2:\n            // @ts-ignore\n            if (exponent & 1) result *= tmp;\n            exponent >>= 1;\n            tmp.sqr();\n          case 1:\n            // @ts-ignore\n            if (exponent & 1) result *= tmp;\n        }\n        return result;\n      }\n    }\n\n    while (exponent > 0) {\n      // @ts-ignore\n      if (exponent & 1) result *= tmp;\n      exponent >>= 1;\n      tmp.sqr();\n    }\n    return result;\n  }\n\n  // compute floor(sqrt(x))\n  static sqrt(value: u128): u128 {\n    var rem = value.clone();\n    if (value < new u128(2)) {\n      return rem;\n    }\n    var res = u128.Zero;\n    // @ts-ignore\n    var pos = u128.One << (127 - (u128.clz(value) | 1));\n    // @ts-ignore\n    while (!pos.isZero()) {\n      // @ts-ignore\n      value = res + pos;\n      if (rem >= value) {\n        // @ts-ignore\n        rem = rem - value;\n        // @ts-ignore\n        res = pos + value;\n      }\n      // @ts-ignore\n      res >>= 1;\n      pos >>= 2;\n    }\n    return res;\n  }\n\n  @inline @operator('==')\n  static eq(a: u128, b: u128): bool {\n    return a.hi == b.hi && a.lo == b.lo;\n  }\n\n  @inline @operator('!=')\n  static ne(a: u128, b: u128): bool {\n    return !u128.eq(a, b);\n  }\n\n  @inline @operator('<')\n  static lt(a: u128, b: u128): bool {\n    var ah = a.hi, bh = b.hi;\n    return ah == bh ? a.lo < b.lo : ah < bh;\n  }\n\n  @inline @operator('>')\n  static gt(a: u128, b: u128): bool {\n    var ah = a.hi, bh = b.hi;\n    return ah == bh ? a.lo > b.lo : ah > bh;\n  }\n\n  @inline @operator('<=')\n  static le(a: u128, b: u128): bool {\n    return !u128.gt(a, b);\n  }\n\n  @inline @operator('>=')\n  static ge(a: u128, b: u128): bool {\n    return !u128.lt(a, b);\n  }\n\n   /**\n   * Get ordering\n   * if a > b then result is  1\n   * if a < b then result is -1\n   * if a = b then result is  0\n   * @param  a 128-bit unsigned integer\n   * @param  b 128-bit unsigned integer\n   * @returns  32-bit signed integer\n   */\n  @inline\n  static ord(a: u128, b: u128): i32 {\n    var dlo = a.lo - b.lo;\n    var dhi = a.hi - b.hi;\n    var cmp = <i32>select<i64>(dhi, dlo, dhi != 0);\n    // normalize to [-1, 0, 1]\n    return i32(cmp > 0) - i32(cmp < 0);\n  }\n\n  /**\n   * Compute count of set (populated) bits\n   * @param  value 128-bit unsigned integer\n   * @returns      32-bit signed integer\n   */\n  @inline\n  static popcnt(value: u128): i32 {\n    return <i32>(popcnt(value.lo) + popcnt(value.hi));\n  }\n\n  /**\n   * Compute bit count of leading zeros\n   * @param  value 128-bit unsigned integer\n   * @returns      32-bit signed integer\n   */\n  @inline\n  static clz(value: u128): i32 {\n    return __clz128(value.lo, value.hi);\n  }\n\n  /**\n   * Compute bit count of trailing zeros\n   * @param  value 128-bit unsigned integer\n   * @returns      32-bit signed integer\n   */\n  @inline\n  static ctz(value: u128): i32 {\n    return __ctz128(value.lo, value.hi);\n  }\n\n  /**\n   * Calculate squared value (value ** 2)\n   * @param  value 128-bit unsigned integer\n   * @returns      128-bit unsigned integer\n   */\n  @inline\n  static sqr(value: u128): u128 {\n    return value.clone().sqr();\n  }\n\n  /**\n   * Calculate inplace squared 128-bit unsigned integer (this ** 2)\n   * @returns 128-bit unsigned integer\n   */\n  sqr(): this {\n    var u = this.lo,\n        v = this.hi;\n\n    var u1 = u & 0xFFFFFFFF;\n    var t  = u1 * u1;\n    var w  = t & 0xFFFFFFFF;\n    var k  = t >> 32;\n\n    u >>= 32;\n    var m = u * u1;\n    t = m + k;\n    var w1 = t >> 32;\n\n    t = m + (t & 0xFFFFFFFF);\n\n    var lo = (t << 32) + w;\n    var hi  = u * u;\n        hi += w1 + (t >> 32);\n        hi += u * v << 1;\n\n    this.lo = lo;\n    this.hi = hi;\n\n    return this;\n  }\n\n  /**\n   * Calculate multiply and division as `number * numerator / denominator`\n   * without overflow in multiplication part.\n   *\n   * @returns 128-bit unsigned integer\n   */\n  static muldiv(number: u128, numerator: u128, denominator: u128): u128 {\n    let a = number;\n    let b = numerator;\n    let c = denominator;\n\n    let ql = __udivmod128(b.lo, b.hi, c.lo, c.hi);\n\n    let qn = new u128(ql, __divmod_quot_hi);             // b / c\n    let rn = new u128(__divmod_rem_lo, __divmod_rem_hi); // b % c\n\n    let q = u128.Zero;\n    let r = u128.Zero;\n    let n = a.clone();\n\n    while (!n.isZero()) {\n      if (n.lo & 1) {\n        // @ts-ignore\n        q += qn;\n        // @ts-ignore\n        r += rn;\n        if (r >= c) {\n          // @ts-ignore\n          ++q;\n          // @ts-ignore\n          r -= c;\n        }\n      }\n      // @ts-ignore\n      n >>= 1;\n      // @ts-ignore\n      qn <<= 1;\n      // @ts-ignore\n      rn <<= 1;\n\n      if (rn >= c) {\n        // @ts-ignore\n        ++qn;\n        // @ts-ignore\n        rn -= c;\n      }\n    }\n    return q;\n  }\n\n  /**\n  * Convert to 256-bit signed integer\n  * @returns 256-bit signed integer\n  */\n  @inline\n  toI256(): i256 {\n    return new i256(this.lo, this.hi);\n  }\n\n  /**\n  * Convert to 256-bit unsigned integer\n  * @returns 256-bit unsigned integer\n  */\n  @inline\n  toU256(): u256 {\n    return new u256(this.lo, this.hi);\n  }\n\n  /**\n  * Convert to 128-bit signed integer\n  * @returns 128-bit signed integer\n  */\n  @inline\n  toI128(): i128 {\n    return new i128(this.lo, this.hi);\n  }\n\n  /**\n  * Convert to 128-bit unsigned integer\n  * @returns 128-bit unsigned integer\n  */\n  @inline\n  toU128(): this {\n    return this;\n  }\n\n  /**\n  * Convert to 64-bit signed integer\n  * @returns 64-bit signed integer\n  */\n  @inline\n  toI64(): i64 {\n    return <i64>(\n      (this.lo & 0x7FFFFFFFFFFFFFFF) |\n      (this.hi & 0x8000000000000000)\n    );\n  }\n\n  /**\n  * Convert to 64-bit unsigned integer\n  * @returns 64-bit unsigned integer\n  */\n  @inline\n  toU64(): u64 {\n    return this.lo;\n  }\n\n  /**\n  * Convert to 32-bit signed integer\n  * @returns 32-bit signed integer\n  */\n  @inline\n  toI32(): i32 {\n    return <i32>this.toI64();\n  }\n\n  /**\n  * Convert to 32-bit unsigned integer\n  * @returns 32-bit unsigned integer\n  */\n  @inline\n  toU32(): u32 {\n    return <u32>this.lo;\n  }\n\n  /**\n  * Convert to 1-bit boolean\n  * @returns 1-bit boolean\n  */\n  @inline\n  toBool(): bool {\n    return (this.lo | this.hi) != 0;\n  }\n\n  /**\n  * Convert to 64-bit float number in deteministic way\n  * @returns 64-bit float\n  */\n  @inline\n  toF64(): f64 {\n    return __floatuntidf(this.lo, this.hi);\n  }\n\n  /**\n  * Convert to 32-bit float number\n  * @returns 32-bit float\n  */\n  @inline\n  toF32(): f32 {\n    return <f32>this.toF64();\n  }\n\n  /**\n   * Convert to generic type `T`. Useful inside other generics methods\n   * @param  T  is <bool | i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | f32 | f64 | i128 | u128 | u256 | u8[] | Uint8Array | `StaticArray<u8>` | string>\n   * @returns   type of `T`\n   */\n  @inline\n  as<T>(): T {\n    if (isBoolean<T>()) {\n      return <T>this.toBool();\n    }\n    else if (isInteger<T>()) {\n      if (isSigned<T>()) {\n        // i8, i16, i32, i64\n        return <T>this.toI64();\n      } else {\n        // u8, u16, u32, u64\n        return <T>this.toU64();\n      }\n    }\n    else if (isFloat<T>()) {\n      // f32, f64\n      return <T>this.toF64();\n    }\n    else if (isString<T>()) {\n      return <T>this.toString();\n    }\n    else if (isReference<T>()) {\n      let dummy = changetype<T>(0);\n           if (dummy instanceof u8[]) return <T>this.toBytes();\n      else if (dummy instanceof StaticArray<u8>) return <T>this.toStaticBytes();\n      else if (dummy instanceof Uint8Array) return <T>this.toUint8Array();\n      else if (dummy instanceof i128) return <T>this.toI128();\n      else if (dummy instanceof u128) return <T>this;\n      else if (dummy instanceof u256) return <T>this.toU256();\n      else throw new TypeError('Unsupported generic type');\n    }\n    else throw new TypeError('Unsupported generic type');\n  }\n\n  @inline\n  private toArrayBufferLE(buffer: usize): void {\n    store<u64>(buffer, this.lo, 0 * sizeof<u64>());\n    store<u64>(buffer, this.hi, 1 * sizeof<u64>());\n  }\n\n  @inline\n  private toArrayBufferBE(buffer: usize): void {\n    store<u64>(buffer, bswap(this.hi), 0 * sizeof<u64>());\n    store<u64>(buffer, bswap(this.lo), 1 * sizeof<u64>());\n  }\n\n  @inline\n  private toArrayBuffer(buffer: usize, bigEndian: bool = false): void {\n    if (bigEndian) {\n      this.toArrayBufferBE(buffer);\n    } else {\n      this.toArrayBufferLE(buffer);\n    }\n  }\n\n  /**\n   * Convert to byte array\n   * @param bigEndian Little or Big Endian? Default: false\n   * @returns  Array of bytes\n   */\n  @inline\n  toBytes(bigEndian: bool = false): u8[] {\n    var result = new Array<u8>(16);\n    this.toArrayBuffer(result.dataStart, bigEndian);\n    return result;\n  }\n\n    /**\n   * Convert to byte static array\n   * @param bigEndian Little or Big Endian? Default: false\n   * @returns  StaticArray of bytes\n   */\n    @inline\n    toStaticBytes(bigEndian: bool = false): StaticArray<u8> {\n      var result = new StaticArray<u8>(16);\n      this.toArrayBuffer(changetype<usize>(result), bigEndian);\n      return result;\n    }\n\n  /**\n   * Convert to Uint8Array\n   * @param bigEndian Little or Big Endian? Default: false\n   * @returns  Uint8Array\n   */\n  @inline\n  toUint8Array(bigEndian: bool = false): Uint8Array {\n    var result = new Uint8Array(16);\n    this.toArrayBuffer(result.dataStart, bigEndian);\n    return result;\n  }\n\n  /**\n  * Return copy of current 128-bit value\n  * @returns 128-bit unsigned integer\n  */\n  clone(): u128 {\n    return new u128(this.lo, this.hi);\n  }\n\n  toString(radix: i32 = 10): string {\n    assert(radix == 10 || radix == 16, 'radix argument must be between 10 or 16');\n    if (this.isZero()) return '0';\n\n    var result = '';\n    if (radix == 16) {\n      let shift: i32 = 124 - (u128.clz(this) & ~3);\n      while (shift >= 0) {\n        // @ts-ignore\n        result += HEX_CHARS.charAt(<i32>((this >> shift).lo & 15));\n        shift  -= 4;\n      }\n      return result;\n    }\n    return u128toDecimalString(this);\n  }\n}\n","import { CharCode } from \"util/string\";\nimport { u128 } from \"./integer/u128\";\nimport { u256 } from \"./integer/u256\";\n\n// @ts-ignore: decorator\n@lazy const MaxBaseForExponent128 = memory.data<u64>([\n  u64.MAX_VALUE,       // 0\n  u64.MAX_VALUE,       // 1\n  u64.MAX_VALUE,       // 2\n  0x000006597FA94F5B,  // 3\n  0x00000000FFFFFFFF,  // 4\n  0x0000000003080C00,  // 5\n  0x0000000000285145,  // 6\n  0x000000000004E045,  // 7\n  0x000000000000FFFF,  // 8\n  0x0000000000004AA8,  // 9\n  0x0000000000001BDB,  // 10\n  0x0000000000000C6F,  // 11\n  0x0000000000000659,  // 12\n  0x0000000000000398,  // 13\n  0x0000000000000235,  // 14\n  0x0000000000000172,  // 15\n  0x00000000000000FF,  // 16\n  0x00000000000000B8,  // 17\n  0x000000000000008A,  // 18\n  0x000000000000006A,  // 19\n  0x0000000000000054,  // 20\n  0x0000000000000044,  // 21\n  0x0000000000000038,  // 22\n  0x000000000000002F,  // 23\n  0x0000000000000028,  // 24\n  0x0000000000000022,  // 25\n  0x000000000000001E,  // 26\n  0x000000000000001A,  // 27\n  0x0000000000000017,  // 28\n  0x0000000000000015,  // 29\n  0x0000000000000013,  // 30\n  0x0000000000000011,  // 31\n  0x000000000000000F,  // 32\n  0x000000000000000E,  // 33\n  0x000000000000000D,  // 34\n  0x000000000000000C,  // 35\n  0x000000000000000B,  // 36\n  0x000000000000000B,  // 37\n  0x000000000000000A,  // 38\n]);\n\n// Use LUT wrapped by function for lazy compilation\n// @ts-ignore: decorator\n@lazy const RadixCharsTable = memory.data<u8>([\n   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 36, 36, 36, 36, 36, 36,\n  36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n  25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36, 36, 36,\n  36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n  25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35\n]);\n\n// @ts-ignore: decorator\n@inline export function isPowerOverflow128(base: u128, exponent: i32): bool {\n  // never overflow\n  if (exponent <= 1 || base <= u128.One) {\n    return false;\n  }\n  // always overflow\n  if (base.hi != 0 || exponent >= 128) {\n    return true;\n  }\n  var low = base.lo;\n  if (low <= 10) {\n    switch (<i32>low) {\n      case 2:  return exponent > 127;\n      case 3:  return exponent > 80;\n      case 4:  return exponent > 63;\n      case 5:  return exponent > 55;\n      case 6:  return exponent > 49;\n      case 7:  return exponent > 45;\n      case 8:  return exponent > 42;\n      case 9:  return exponent > 40;\n      case 10: return exponent > 38;\n    }\n  }\n  if (exponent >= 38) return true;\n  return low > load<u64>(MaxBaseForExponent128 + (exponent << 3));\n}\n\n// helper function for utoa\nfunction processU64(digits: Uint8Array, value: u64): void {\n  var length = digits.length - 1;\n  for (let i = 63; i != -1; --i) {\n    for (let j = 0; j <= length; ++j) {\n      unchecked(digits[j] += (u8(digits[j] >= 5) * 3));\n    }\n    for (let j = length; j != -1; --j) {\n      let d = unchecked(digits[j]) << 1;\n      if (j < length) unchecked(digits[j + 1] |= u8(d > 15));\n      unchecked(digits[j] = d & 15);\n    }\n    unchecked(digits[0] += u8((value & (1 << i)) != 0));\n  }\n}\n\nexport function u128toDecimalString(value: u128): string {\n  var length = 40;\n  var digits = new Uint8Array(length);\n  var result = \"\", start = false;\n\n  processU64(digits, value.hi);\n  processU64(digits, value.lo);\n\n  for (let i = length - 1; i != -1; --i) {\n    let d = unchecked(digits[i]);\n    if (!start && d != 0) start = true;\n    if (start) {\n      assert(<u32>d <= 9);\n      result += String.fromCharCode(0x30 + d);\n    }\n  }\n  return result;\n}\n\nexport function u256toDecimalString(value: u256): string {\n  var length = 78;\n  var digits = new Uint8Array(length);\n  var result = \"\", start = false;\n\n  processU64(digits, value.hi2);\n  processU64(digits, value.hi1);\n  processU64(digits, value.lo2);\n  processU64(digits, value.lo1);\n\n  for (let i = length - 1; i != -1; --i) {\n    let d = unchecked(digits[i]);\n    if (!start && d != 0) start = true;\n    if (start) {\n      assert(<u32>d <= 9);\n      result += String.fromCharCode(0x30 + d);\n    }\n  }\n  return result;\n}\n\nexport function atou128(str: string, radix: i32 = 10): u128 {\n  if (radix < 2 || radix > 36) {\n    throw new Error(\"Invalid radix\");\n  }\n  var len = str.length;\n  if (!len) return u128.Zero;\n\n  var first = str.charCodeAt(0);\n  if (len == 1 && first == CharCode._0) {\n    return u128.Zero;\n  }\n  var isNeg = first == CharCode.MINUS;\n  // @ts-ignore\n  var index = i32(isNeg | (first == CharCode.PLUS));\n\n  if (str.charCodeAt(index) == CharCode._0) {\n    let second = str.charCodeAt(++index);\n    if ((second | 32) == CharCode.x) {\n      radix = 16; ++index;\n    } else if ((second | 32) == CharCode.o) {\n      radix = 8; ++index;\n    } else if ((second | 32) == CharCode.b) {\n      radix = 2; ++index;\n    } else if (second == CharCode._0) {\n      // skip leading zeros\n      while (index < len && str.charCodeAt(index) == CharCode._0) ++index;\n    }\n  }\n  var result = u128.Zero;\n  var table  = RadixCharsTable;\n\n  if (index >= len) return result;\n\n  if (ASC_SHRINK_LEVEL >= 1) {\n    let radix128 = u128.fromU64(radix);\n    do {\n      let n: u32 = str.charCodeAt(index) - CharCode._0;\n      if (n > <u32>(CharCode.z - CharCode._0)) break;\n\n      let num = load<u8>(table + n);\n      if (num >= <u8>radix) break;\n\n      // @ts-ignore\n      result *= radix128;\n      // @ts-ignore\n      result += u128.fromU64(num);\n    } while (++index < len);\n  } else {\n    switch (radix) {\n      case 2: {\n        do {\n          let num: u32 = str.charCodeAt(index) - CharCode._0;\n          if (num >= 2) break;\n          // @ts-ignore\n          result <<= 1;\n          // @ts-ignore\n          result |= u128.fromU64(num);\n        } while (++index < len);\n        break;\n      }\n      case 10: {\n        do {\n          let num: u32 = str.charCodeAt(index) - CharCode._0;\n          if (num >= 10) break;\n          // @ts-ignore\n          result  = (result << 3) + (result << 1);\n          // @ts-ignore\n          result += u128.fromU64(num);\n        } while (++index < len);\n        break;\n      }\n      case 16: {\n        do {\n          let n: u32 = str.charCodeAt(index) - CharCode._0;\n          if (n > <u32>(CharCode.z - CharCode._0)) break;\n\n          let num = load<u8>(table + n);\n          if (num >= 16) break;\n\n          // @ts-ignore\n          result <<= 4;\n          // @ts-ignore\n          result |= u128.fromU64(num);\n        } while (++index < len);\n        break;\n      }\n      default: {\n        let radix128 = u128.fromU64(radix);\n        do {\n          let n: u32 = str.charCodeAt(index) - CharCode._0;\n          if (n > <u32>(CharCode.z - CharCode._0)) break;\n\n          let num = load<u8>(table + n);\n          if (num >= <u8>radix) break;\n\n          // @ts-ignore\n          result *= radix128;\n          // @ts-ignore\n          result += u128.fromU64(num);\n        } while (++index < len);\n        break;\n      }\n    }\n  }\n  // @ts-ignore\n  return isNeg ? -result : result;\n}\n","import { u256 } from './integer';\nimport { u128 } from './integer/u128';\n\n// used for returning quotient and reminder from __divmod128\n@lazy export var __divmod_quot_hi: u64 = 0;\n@lazy export var __divmod_rem_lo:  u64 = 0;\n@lazy export var __divmod_rem_hi:  u64 = 0;\n\n// used for returning low and high part of __mulq64, __multi3 etc\n@lazy export var __res128_hi: u64 = 0;\n// used for returning 0 or 1\n@lazy export var __carry: u64 = 0;\n\n/**\n * Convert 128-bit unsigned integer to 64-bit float\n * @param  lo lower  64-bit part of unsigned 128-bit integer\n * @param  hi higher 64-bit part of unsigned 128-bit integer\n * @return    64-bit float result\n */\n// @ts-ignore: decorator\n@global\nexport function __floatuntidf(lo: u64, hi: u64): f64 {\n  // __floatuntidf ported from LLVM sources\n  if (!(lo | hi)) return 0.0;\n\n  var v  = new u128(lo, hi);\n  var sd = 128 - __clz128(lo, hi);\n  var e  = sd - 1;\n\n  if (sd > 53) {\n    if (sd != 55) {\n      if (sd == 54) {\n        v = u128.shl(v, 1);\n      } else {\n        v = u128.or(\n          u128.shr(v, sd - 55),\n          u128.fromBool(u128.and(v, u128.shr(u128.Max, 128 + 55 - sd)).toBool())\n        );\n      }\n    }\n\n    v.lo |= (v.lo & 4) >> 2;\n    v.preInc();\n\n    v = u128.shr(v, 2);\n\n    if (v.lo & (1 << 53)) {\n      v = u128.shr(v, 1);\n      ++e;\n    }\n\n  } else {\n    v = u128.shl(v, 53 - sd);\n  }\n\n  var w: u64 = u128.shr(v, 32).lo & 0x000FFFFF;\n  var u: u64 = <u64>(((e + 1023) << 20) | w) << 32;\n  return reinterpret<f64>(u | (v.lo & 0xFFFFFFFF));\n}\n\n// @ts-ignore: decorator\n@global\nexport function __umulh64(a: u64, b: u64): u64 {\n  var u = a & 0xFFFFFFFF; a >>= 32;\n  var v = b & 0xFFFFFFFF; b >>= 32;\n\n  var uv = u * v;\n  var uv = a * v + (uv >> 32);\n  var w0 = u * b + (uv & 0xFFFFFFFF);\n  return a * b + (uv >> 32) + (w0 >> 32);\n}\n\n// @ts-ignore: decorator\n@global\nexport function __umulq64(a: u64, b: u64): u64 {\n  var u = a & 0xFFFFFFFF; a >>= 32;\n  var v = b & 0xFFFFFFFF; b >>= 32;\n\n  var uv = u * v;\n  var w0 = uv & 0xFFFFFFFF;\n  uv = a * v + (uv >> 32);\n  var w1 = uv >> 32;\n  uv = u * b + (uv & 0xFFFFFFFF);\n\n  __res128_hi = a * b + w1 + (uv >> 32);\n  return (uv << 32) | w0;\n}\n\n// __umul64Hop computes (hi * 2^64 + lo) = z + (x * y)\n// @ts-ignore: decorator\n@inline\nexport function __umul64Hop(z: u64, x: u64, y: u64): u64 {\n  var lo = __umulq64(x, y);\n  lo = __uadd64(lo, z);\n  var hi = __res128_hi +__carry;\n  __res128_hi = hi;\n  return lo\n}\n\n// __umul64Step computes (hi * 2^64 + lo) = z + (x * y) + carry.\n// @ts-ignore: decorator\n@inline\nexport function __umul64Step(z: u64, x: u64, y: u64, carry: u64): u64 {\n  var lo = __umulq64(x, y)\n  lo = __uadd64(lo, carry);\n  var hi = __uadd64(__res128_hi, 0, __carry);\n  lo = __uadd64(lo, z);\n  hi += __carry;\n  __res128_hi = hi;\n  return lo\n}\n\n// __uadd64 returns the sum with carry of x, y and carry: sum = x + y + carry.\n// The carry input must be 0 or 1; otherwise the behavior is undefined.\n// The carryOut output is guaranteed to be 0 or 1.\n// @ts-ignore: decorator\n@inline\nexport function __uadd64(x: u64, y: u64, carry: u64 = 0): u64 {\n  var sum = x + y + carry\n  // // The sum will overflow if both top bits are set (x & y) or if one of them\n  // // is (x | y), and a carry from the lower place happened. If such a carry\n  // // happens, the top bit will be 1 + 0 + 1 = 0 (& ~sum).\n  __carry = ((x & y) | ((x | y) & ~sum)) >>> 63\n  return sum;\n\n}\n\n// u256 * u256 => u256 implemented from https://github.com/holiman/uint256\n// @ts-ignore: decorator\n@global\nexport function __mul256(x0: u64, x1: u64, x2: u64, x3: u64, y0: u64, y1: u64, y2: u64, y3: u64): u256 {\n  var lo1 = __umulq64(x0, y0);\n  var res1 = __umul64Hop(__res128_hi, x1, y0);\n  var res2 = __umul64Hop(__res128_hi, x2, y0);\n  var res3 = x3 * y0 + __res128_hi;\n\n  var lo2 = __umul64Hop(res1, x0, y1);\n  res2 = __umul64Step(res2, x1, y1, __res128_hi);\n  res3 += x2 * y1 + __res128_hi;\n\n  var hi1 = __umul64Hop(res2, x0, y2);\n  res3 += x1 * y2 + __res128_hi\n\n  var hi2 = __umul64Hop(res3, x0, y3);\n\n  return new u256(lo1, lo2, hi1, hi2);\n}\n\n// @ts-ignore: decorator\n@global\nexport function __multi3(al: u64, ah: u64, bl: u64, bh: u64): u64 {\n  var u = al, v = bl;\n  var w: u64, k: u64;\n\n  var u1 = u & 0xFFFFFFFF; u >>= 32;\n  var v1 = v & 0xFFFFFFFF; v >>= 32;\n  var t  = u1 * v1;\n  var w1 = t & 0xFFFFFFFF;\n\n  t = u * v1 + (t >> 32);\n  k = t & 0xFFFFFFFF;\n  w = t >> 32;\n  t = u1 * v + k;\n\n  var lo  = (t << 32) | w1;\n  var hi  = u  * v + w;\n      hi += ah * bl;\n      hi += al * bh;\n      hi += t >> 32;\n\n  __res128_hi = hi;\n  return lo;\n}\n\n// @ts-ignore: decorator\n@global\nexport function __floatuntfdi(value: f64): u64 {\n  var u = reinterpret<u64>(value);\n\n  // if (value < -1.7014118346046e38) { // -(2^127-1)\n  if (value < reinterpret<f64>(0xC7F0000000000000)) { // -(2^128-1)\n    // __float_u128_hi = <u64>-1; // for i128\n    __res128_hi = 0;\n    // overflow negative\n    return 0;\n    // } else if (value < -9.2233720368547e18) { // -2^63-1 // for i128\n  } else if (value < reinterpret<f64>(0xC3F0000000000000)) { // // -(2^64-1)\n    let lo: u64, hi: u64, m: u64;\n\n    m = (u & 0x000FFFFFFFFFFFFF) | (1 << 52);\n    u = (u & 0x7FFFFFFFFFFFFFFF) >> 52;\n\n    u -= 1075;\n    if (u > 64) {\n      lo = 0;\n      hi = m << (u - 64);\n    } else {\n      lo = m << u;\n      hi = m >> (64 - u);\n    }\n    __res128_hi = ~hi;\n    return ~lo;\n    // } else if (value < 9.2233720368547e18) { // 2^63-1 // for i128\n  } else if (value < reinterpret<f64>(0x43F0000000000000)) { // 2^64-1\n    // __float_u128_hi = (value < 0) ? -1 : 0; // for int\n    __res128_hi = 0;\n    // fit in a u64\n    return <u64>value;\n    // } else if (value < 1.7014118346046e38) {\n  } else if (value < reinterpret<f64>(0x47F0000000000000)) { // 2^128-1\n    let lo: u64, hi: u64, m: u64;\n\n    m = (u & 0x000FFFFFFFFFFFFF) | (1 << 52);\n    u = (u & 0x7FFFFFFFFFFFFFFF) >> 52;\n    u -= 1075;\n    if (u > 64) {\n      lo = 0;\n      hi = m << (u - 64);\n    } else {\n      lo = m << u;\n      hi = m >> (64 - u);\n    }\n    __res128_hi = hi;\n    return lo;\n  } else {\n    // overflow positive\n    __res128_hi = <u64>-1; // 0x7FFFFFFFFFFFFFFF for i128\n    return <u64>-1;\n  }\n}\n\n// @ts-ignore: decorator\n@global @inline\nexport function __clz128(lo: u64, hi: u64): i32 {\n  var mask: u64 = <i64>(hi ^ (hi - 1)) >> 63;\n  return <i32>clz((hi & ~mask) | (lo & mask)) + (<i32>mask & 64);\n}\n\n// @ts-ignore: decorator\n@global @inline\nexport function __ctz128(lo: u64, hi: u64): i32 {\n  var mask: u64 = <i64>(lo ^ (lo - 1)) >> 63;\n  return <i32>ctz((hi & mask) | (lo & ~mask)) + (<i32>mask & 64);\n}\n\n// @ts-ignore: decorator\n@global\nexport function __udivmod128(alo: u64, ahi: u64, blo: u64, bhi: u64): u64 {\n  var bzn = __clz128(blo, bhi); // N\n\n  // b == 0\n  if (bzn == 128) {\n    throw new RangeError(\"Division by zero\"); // division by zero\n  }\n\n  // var azn = __clz128(alo, ahi); // M\n  var btz = __ctz128(blo, bhi); // N\n\n  // a == 0\n  if (!(alo | ahi)) {\n    __divmod_quot_hi = 0;\n    __divmod_rem_lo  = 0;\n    __divmod_rem_hi  = 0;\n    return 0;\n  }\n\n  // a / 1\n  if (bzn == 127) {\n    __divmod_quot_hi = ahi;\n    __divmod_rem_lo  = 0;\n    __divmod_rem_hi  = 0;\n    return alo;\n  }\n\n  // a == b\n  if (alo == blo && ahi == bhi) {\n    __divmod_quot_hi = 0;\n    __divmod_rem_lo  = 0;\n    __divmod_rem_hi  = 0;\n    return 1;\n  }\n\n  // if (btz + bzn == 127) {\n  //   // TODO\n  //   // __divmod_quot = a >> btz\n  //   // b++\n  //   // __divmod_rem = a & b\n  //   return;\n  // }\n\n  if (!(ahi | bhi)) {\n    __divmod_quot_hi = 0;\n    __divmod_rem_hi  = 0;\n    // if `b.lo` is power of two\n    if (!(blo & (blo - 1))) {\n      __divmod_rem_lo = alo & (blo - 1);\n      return alo >> btz;\n    } else {\n      let dlo = alo / blo;\n      __divmod_rem_lo = alo - dlo * blo;\n      return dlo;\n    }\n  }\n\n  // if b.lo == 0 and `b.hi` is power of two\n  // if (!blo && !(bhi & (bhi - 1))) {\n  //   __divmod_rem = 0;\n\n  //   // TODO\n\n  //   return 0;\n  // }\n\n  // var diff: i64 = ahi - bhi;\n  // var cmp = <i32>(diff != 0 ? diff : alo - blo); // TODO optimize this\n\n  // if (cmp <= 0) {\n  //   __divmod_quot_hi = 0;\n  //   __divmod_rem     = 0;\n  //   return u64(cmp == 0);\n  // }\n\n  // if (bzn - azn <= 5) {\n  //   // TODO\n  //   // fast path\n  //   return __udivmod128core(alo, ahi, blo, bhi);\n  // }\n  return __udivmod128core(alo, ahi, blo, bhi);\n}\n\nfunction __udivmod128core(alo: u64, ahi: u64, blo: u64, bhi: u64): u64 {\n  var a = new u128(alo, ahi);\n  var b = new u128(blo, bhi);\n  // get leading zeros for left alignment\n  var alz = __clz128(alo, ahi);\n  var blz = __clz128(blo, bhi);\n  var off = blz - alz;\n  var nb  = b << off;\n  var q = u128.Zero;\n  var n = a.clone();\n\n  // create a mask with the length of b\n  var mask = u128.One;\n  mask <<= 128 - blz;\n  --mask;\n  mask <<= off;\n\n  var i = 0;\n  while (n >= b) {\n    ++i;\n    q <<= 1;\n    if ((n & mask) >= nb) {\n      ++q;\n      n -= nb;\n    }\n\n    mask |= mask >> 1;\n    nb >>= 1;\n  }\n  q <<= (blz - alz - i + 1);\n\n  __divmod_quot_hi = q.hi;\n  __divmod_rem_lo  = n.lo;\n  __divmod_rem_hi  = n.hi;\n  return q.lo;\n}\n\n// @ts-ignore: decorator\n@global\nexport function __udivmod128_10(lo: u64, hi: u64): u64 {\n  if (!hi) {\n    __divmod_quot_hi = 0;\n    if (lo < 10) {\n      __divmod_rem_lo = 0;\n      __divmod_rem_hi = 0;\n      return 0;\n    } else {\n      let qlo = lo / 10;\n      __divmod_rem_lo = lo - qlo * 10;\n      __divmod_rem_hi = 0;\n      return qlo;\n    }\n  }\n\n  var q: u128, r: u128;\n  var n = new u128(lo, hi);\n\n  q  = n >> 1;\n  q += n >> 2;\n  q += q >> 4;\n  q += q >> 8;\n  q += q >> 16;\n  q += q >> 32;\n  q += u128.fromU64(q.hi); // q >> 64\n  q >>= 3;\n  r = n - (((q << 2) + q) << 1);\n  n = q + u128.fromBool(r.lo > 9);\n\n  __divmod_quot_hi = n.hi;\n  __divmod_rem_lo  = r.lo;\n  __divmod_rem_hi  = r.hi;\n  return n.lo;\n}\n","export const CYCLE_EPOCHS: u32 = 6;\nexport const SUBSIDY_HALVING_INTERVAL: u32 = 210000;\nexport const COIN_VALUE: u32 = 100000000;\nexport const DIFFCHANGE_INTERVAL: u32 = 2016;\nexport const COINBASE_MATURITY: u32 = 100;\n","const OP_FALSE = 0x00;\nconst OP_PUSHDATA1 = 0x4c;\nconst OP_PUSHDATA2 = 0x4d;\nconst OP_PUSHDATA4 = 0x4e;\nconst OP_IF = 0x63;\nconst OP_NOTIF = 0x64;\nconst OP_ELSE = 0x67;\nconst OP_ENDIF = 0x68;\nconst OP_VERIFY = 0x69;\nconst OP_RETURN = 0x6a;\nconst OP_1 = 0x51;\n","@final\n@unmanaged\nexport class Flag {\n  static ETCHING: u64 = 0;\n  static TERMS: u64 = 1;\n  static CENOTAPH: u64 = 127;\n  constructor() {}\n}\n","@final\n@unmanaged\nexport class ProtoruneField {\n  static BODY: u64 = 0;\n  static FLAGS: u64 = 2;\n  static MESSAGE: u64 = 81;\n  static BURN: u64 = 83;\n  static SPLIT: u64 = 85;\n  static POINTER: u64 = 91;\n  static REFUND: u64 = 93;\n  static FROM: u64 = 95;\n  static CENOTAPH: u64 = 126;\n  static NOP: u64 = 127;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\n\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a set entry. */\n@unmanaged class SetEntry<K> {\n  key: K;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<T>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\n  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<T>(): usize {\n  const align = ENTRY_ALIGN<T>();\n  const size = (offsetof<SetEntry<T>>() + align) & ~align;\n  return size;\n}\n\nexport class Set<T> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, SetEntry<K>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: T, hashCode: u32): SetEntry<T> | null {\n    let entry = load<SetEntry<T>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  @operator(\"[]\")\n  has(key: T): bool {\n    return this.find(key, HASH<T>(key)) != null;\n  }\n\n  add(key: T): this {\n    let hashCode = HASH<T>(key);\n    let entry = this.find(key, hashCode); // unmanaged!\n    if (!entry) {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());\n      entry.key = key;\n      if (isManaged<T>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  @operator(\"[]=\")\n  private __set(key: T, value: bool): void {\n    if (value) this.add(key);\n    else this.delete(key);\n  }\n\n  delete(key: T): bool {\n    let entry = this.find(key, HASH<T>(key)); // unmanaged!\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    let halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());\n\n    // copy old entries to new entries\n    let oldPtr = changetype<usize>(this.entries);\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n    let newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<T>();\n      }\n      oldPtr += ENTRY_SIZE<T>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  values(): T[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let values = new Array<T>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(values[length++] = entry.key);\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Set]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    let entries = changetype<usize>(this.entries);\n    if (isManaged<T>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n      while (cur < end) {\n        let entry = changetype<SetEntry<T>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          let val = changetype<usize>(entry.key);\n          if (isNullable<T>()) {\n            if (val) __visit(val, cookie);\n          } else __visit(val, cookie);\n        }\n        cur += ENTRY_SIZE<T>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","import { IndexPointer } from \"metashrew-as/assembly/indexer/tables\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { console } from \"metashrew-as/assembly/utils\";\n\nclass ProtocolIndexer {\n  set: Set<string> = new Set<string>();\n  add(val: u128): void {\n    this.set.add(val.toString());\n  }\n  has(val: u128): bool {\n    return this.set.has(val.toString());\n  }\n  toString(): string {\n    let str = \"\";\n    const set = this.set.values();\n    for (let i = 0; i < set.length; i++) {\n      str += set[i] + \", \";\n    }\n    return str;\n  }\n}\n\nexport const PROTOCOLS_TO_INDEX = new ProtocolIndexer();\n\nexport class ProtoruneTable {\n  ptr: IndexPointer;\n  OUTPOINT_TO_RUNES: IndexPointer;\n  HEIGHT_TO_TRANSACTION_IDS: IndexPointer;\n  SYMBOL: IndexPointer;\n  SPACERS: IndexPointer;\n  DIVISIBILITY: IndexPointer;\n  ETCHINGS: IndexPointer;\n  RUNE_ID_TO_ETCHING: IndexPointer;\n  ETCHING_TO_RUNE_ID: IndexPointer;\n  RUNTIME_BALANCE: IndexPointer;\n  INTERNAL_MINT: IndexPointer;\n  constructor(ptr: IndexPointer) {\n    this.ptr = ptr;\n    this.OUTPOINT_TO_RUNES = ptr.keyword(\"/byoutpoint/\");\n    this.HEIGHT_TO_TRANSACTION_IDS = ptr.keyword(\"/txids/byheight\");\n    this.SYMBOL = ptr.keyword(\"/symbol/\");\n    this.SPACERS = ptr.keyword(\"/spaces/\");\n    this.DIVISIBILITY = ptr.keyword(\"/divisibility/\");\n    this.ETCHINGS = ptr.keyword(\"/names\");\n    this.RUNE_ID_TO_ETCHING = ptr.keyword(\"/etching/byruneid/\");\n    this.ETCHING_TO_RUNE_ID = ptr.keyword(\"/runeid/byetching/\");\n    this.RUNTIME_BALANCE = ptr.keyword(\"/runtime/balance\");\n    this.INTERNAL_MINT = ptr.keyword(\"/mint/isinternal\");\n  }\n  static for(protocol: u128): ProtoruneTable {\n    return new ProtoruneTable(\n      IndexPointer.for(\"/runes/proto/\").keyword(protocol.toString()),\n    );\n  }\n  static for_str(protocol: string): ProtoruneTable {\n    return new ProtoruneTable(\n      IndexPointer.for(\"/runes/proto/\").keyword(protocol),\n    );\n  }\n  unwrap(): IndexPointer {\n    return this.ptr;\n  }\n}\n","export const PROTOCOL_FIELD: u64 = 16383;\n","import { u128 } from \"as-bignum/assembly\";\nimport { RuneId } from \"metashrew-runes/assembly/indexer/RuneId\";\nimport { readULEB128ToU128 } from \"metashrew-runes/assembly/leb128.ts\";\nimport { toLEB128, concatByteArrayTruncateZeros, logArrayBuffer } from \"../utils\";\nimport { Box } from \"metashrew-as/assembly/utils/box\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\n\nexport class ProtoruneRuneId extends RuneId {\n  static readonly MAX_LEB_SIZE_BYTES: u32 = 31;\n  decode(): Array<u128> {\n    const fieldData = new Array<u128>(2);\n    fieldData[0] = u128.shr(this.block, 8);\n    fieldData[1] = this.tx;\n    const input = Box.from(concatByteArrayTruncateZeros(fieldData));\n    const result: Array<u128> = new Array<u128>();\n    while (input.len > 0) {\n      const current = u128.from(0);\n      let size = readULEB128ToU128(input, current);\n      if (size === usize.MAX_VALUE) return changetype<Array<u128>>(0); //can choose to continue or return\n      input.shrinkFront(size);\n      result.push(current);\n    }\n    return result;\n  }\n  // ary should have the string identifier for the protorune first, then the data that should be encoded\n  // Ex: [\"OYL\", RuneBlock1, RuneTx1, RuneBlock2, RuneTx2]. Guarantees that the padded bits can be ignored and the first data byte is nonzero (must be a string)\n  // Important note: collisions with existing RuneIds are not explicitly handled. Authors of subprotocols should ensure that the ProtoruneRuneId scheme does not conflict with existing rune ids.\n  // Do note that a collision would be extremely unlikely: it would require 14 bytes of pure 0s input as data, in order for txIndex to be valid, and then the data needs to be higher than 840,000 for the block.\n  static encode(ary: Array<u128>): ProtoruneRuneId {\n    const data = Box.concat(\n      ary.map<Box>((v: u128, i: i32, ary: Array<u128>) =>\n        Box.from(toLEB128(v)),\n      ),\n    );\n    const result = new ProtoruneRuneId(0, 0);\n    console.log(\"this.Max \" + this.MAX_LEB_SIZE_BYTES.toString())\n    if (<u32>data.byteLength > this.MAX_LEB_SIZE_BYTES) return result;\n\n    // adds left padding of 0 bytes until the data is 31 bytes\n    const padded = new ArrayBuffer(32);\n    if (data.byteLength <= 16) {\n      memory.copy(\n        changetype<usize>(padded) + <usize>(32 - data.byteLength),\n        changetype<usize>(data),\n        data.byteLength,\n      );\n    } else {\n      memory.copy(\n        changetype<usize>(padded) + <usize>(16),\n        changetype<usize>(data) + <usize>(data.byteLength - 16),\n        16,\n      );\n      memory.copy(\n        changetype<usize>(padded) + <usize>(31 - data.byteLength),\n        changetype<usize>(data),\n        data.byteLength - 16,\n      );\n    }\n\n    const blockArray = Uint8Array.wrap(Box.from(padded).shrinkBack(16).toArrayBuffer())\n    blockArray[15] = 0x7f\n    result.block = u128.fromBytes(\n      blockArray,\n      true // bigEndian is true, since we pushed the bytes to the highest memory addresses, we only want those to be processed, and the 0s should be higher significance so the encoded values are increasing in size and not so huge\n    ); // left shift is to ensure that the high byte is 0, which will take the value of 0x7f so the block number is nonzero\n    console.log(\"block \" + result.block.toString())\n    result.tx = u128.fromBytes(\n      Uint8Array.wrap(Box.from(padded).shrinkFront(16).toArrayBuffer()),\n      true\n    );\n    console.log(\"tx \" + result.tx.toString())\n    return result;\n  }\n  static from(v: RuneId): ProtoruneRuneId {\n    return changetype<ProtoruneRuneId>(v);\n  }\n}\n","import { IndexPointer } from \"metashrew-as/assembly/indexer/tables\";\n\nexport const OUTPOINTS_FOR_ADDRESS = IndexPointer.for(\"/outpoints/byaddress/\");\nexport const OUTPOINT_SPENDABLE_BY = IndexPointer.for(\"/outpoint/spendableby/\");\nexport const OUTPOINT_TO_OUTPUT = IndexPointer.for(\"/output/byoutpoint/\");\n","namespace __proto {\n  export const MAX_POS = 0x1000;\n\n  /**\n   * Decoder implements protobuf message decode interface.\n   *\n   * Useful references:\n   *\n   * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding\n   * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128\n   * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba\n   */\n  export class Decoder {\n    public view: DataView;\n    public pos: i32;\n\n    constructor(view: DataView) {\n      this.view = view;\n      this.pos = 0;\n    }\n\n    /**\n     * Returns true if current reader has reached the buffer end\n     * @returns True if current reader has reached the buffer end\n     */\n    @inline\n    eof(): bool {\n      return this.pos >= this.view.byteLength;\n    }\n\n    /**\n     * Returns current buffer length in bytes\n     * @returns Length in bytes\n     */\n    @inline\n    get byteLength(): i32 {\n      return this.view.byteLength;\n    }\n\n    /**\n     * An alias method to fetch tag from the reader. Supposed to return tuple of [field number, wire_type].\n     * TODO: Replace with return tuple when tuples become implemented in AS.\n     * @returns Message tag value\n     */\n    @inline\n    tag(): u32 {\n      return this.uint32();\n    }\n\n    /**\n     * Returns byte at offset, alias for getUint8\n     * @param byteOffset Offset\n     * @returns u8\n     */\n    @inline\n    private u8at(byteOffset: i32): u8 {\n      return this.view.getUint8(byteOffset);\n    }\n\n    /**\n     * Reads and returns varint number (128 + 10 bits max) from a current position.\n     * @returns Returns varint\n     */\n    varint(): u64 {\n      let value: u64;\n\n      // u32\n      value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u32 remainder or u64 byte\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value =\n        (value | ((u64(u8(this.u8at(this.pos))) & 127) << 42)) /* 42!!! */ >>>\n        0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64 remainder\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      return value;\n    }\n\n    @inline\n    int32(): i32 {\n      return i32(this.varint());\n    }\n\n    @inline\n    int64(): i64 {\n      return i32(this.varint());\n    }\n\n    @inline\n    uint32(): u32 {\n      return u32(this.varint());\n    }\n\n    @inline\n    uint64(): u64 {\n      return u64(this.varint());\n    }\n\n    @inline\n    sint32(): i32 {\n      const n: u64 = this.varint();\n      return i32((n >>> 1) ^ -(n & 1));\n    }\n\n    @inline\n    sint64(): i64 {\n      const n: u64 = this.varint();\n      return i64((n >>> 1) ^ -(n & 1));\n    }\n\n    fixed32(): u32 {\n      this.pos += 4;\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)\n      return (\n        u32(u8(this.u8at(this.pos - 4))) |\n        (u32(u8(this.u8at(this.pos - 3))) << 8) |\n        (u32(u8(this.u8at(this.pos - 2))) << 16) |\n        (u32(u8(this.u8at(this.pos - 1))) << 24)\n      );\n    }\n\n    @inline\n    sfixed32(): i32 {\n      return i32(this.fixed32());\n    }\n\n    fixed64(): u64 {\n      this.pos += 8;\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      return (\n        u64(u8(this.u8at(this.pos - 8))) |\n        (u64(u8(this.u8at(this.pos - 7))) << 8) |\n        (u64(u8(this.u8at(this.pos - 6))) << 16) |\n        (u64(u8(this.u8at(this.pos - 5))) << 24) |\n        (u64(u8(this.u8at(this.pos - 4))) << 32) |\n        (u64(u8(this.u8at(this.pos - 3))) << 40) |\n        (u64(u8(this.u8at(this.pos - 2))) << 48) |\n        (u64(u8(this.u8at(this.pos - 1))) << 56)\n      );\n    }\n\n    @inline\n    sfixed64(): i64 {\n      return i64(this.fixed64());\n    }\n\n    @inline\n    float(): f32 {\n      return f32.reinterpret_i32(this.fixed32());\n    }\n\n    @inline\n    double(): f64 {\n      return f64.reinterpret_i64(this.fixed64());\n    }\n\n    @inline\n    bool(): boolean {\n      return this.uint32() > 0;\n    }\n\n    /**\n     * Reads and returns UTF8 string.\n     * @returns String\n     */\n    string(): string {\n      const length = this.uint32();\n      if (this.pos + length > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      const p = this.pos + this.view.byteOffset;\n      const value = String.UTF8.decode(this.view.buffer.slice(p, p + length));\n      this.pos += length;\n      return value;\n    }\n\n    /**\n     * Reads and returns bytes array.\n     * @returns Array<u8> of bytes\n     */\n    bytes(): Array<u8> {\n      const len = this.uint32();\n      if (this.pos + len > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      const a = new Array<u8>(len);\n      for (let i: u32 = 0; i < len; i++) {\n        a[i] = u8(this.u8at(this.pos++));\n      }\n\n      return a;\n    }\n\n    /**\n     * Skips a message field if it can'be recognized by an object's decode() method\n     * @param wireType Current wire type\n     */\n    skipType(wireType: u32): void {\n      switch (wireType) {\n        // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length\n        case 0:\n          this.varint(); // Just read a varint\n          break;\n        // fixed64, sfixed64, double: 8 bytes always\n        case 1:\n          this.skip(8);\n          break;\n        // length-delimited; length is determined by varint32; skip length bytes;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        // tart group: skip till the end of the group, then skip group end marker\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        // fixed32, sfixed32, float: 4 bytes always\n        case 5:\n          this.skip(4);\n          break;\n\n        // Something went beyond our capability to understand\n        default:\n          throw new Error(\n            `Invalid wire type ${wireType} at offset ${this.pos}`\n          );\n      }\n    }\n\n    /**\n     * Fast-forwards cursor by length with boundary check\n     * @param length Byte length\n     */\n    skip(length: u32): void {\n      if (this.pos + length > this.byteLength) {\n        this.throwOutOfRange();\n      }\n      this.pos += length;\n    }\n\n    /**\n     * OutOfRange check. Throws an exception if current position exceeds current buffer range\n     */\n    @inline\n    private throwOutOfRange(): void {\n      throw new Error(`Decoder position ${this.pos} is out of range!`);\n    }\n  }\n\n  class SafeDecoder extends Decoder {\n    public _invalid: boolean;\n    invalid(): boolean {\n      if (this._invalid) return true;\n      if (this.pos > MAX_POS) {\n        this._invalid = true;\n        return true;\n      }\n      return false;\n    }\n    string(): string {\n      if (this.invalid()) return \"\";\n      const length = this.uint32();\n      if (this.pos + length > this.byteLength) {\n        this._invalid = true;\n        return \"\";\n      }\n      const p = this.pos + this.view.byteOffset;\n      const value = String.UTF8.decode(this.view.buffer.slice(p, p + length));\n      this.pos += length;\n      return value;\n    }\n    @inline\n    sfixed64(): i64 {\n      if (this.invalid()) return 0;\n      return i64(this.fixed64());\n    }\n\n    @inline\n    float(): f32 {\n      if (this.invalid()) return 0;\n      return f32.reinterpret_i32(this.fixed32());\n    }\n\n    @inline\n    double(): f64 {\n      if (this.invalid()) return 0;\n      return f64.reinterpret_i64(this.fixed64());\n    }\n\n    @inline\n    bool(): boolean {\n      if (this.invalid()) return false;\n      return this.uint32() > 0;\n    }\n    fixed64(): u64 {\n      if (this.invalid()) return 0;\n      this.pos += 8;\n      if (this.pos > this.byteLength || this.pos > MAX_POS) {\n        this._invalid = true;\n        return <u64>0;\n      }\n\n      return (\n        u64(u8(this.u8at(this.pos - 8))) |\n        (u64(u8(this.u8at(this.pos - 7))) << 8) |\n        (u64(u8(this.u8at(this.pos - 6))) << 16) |\n        (u64(u8(this.u8at(this.pos - 5))) << 24) |\n        (u64(u8(this.u8at(this.pos - 4))) << 32) |\n        (u64(u8(this.u8at(this.pos - 3))) << 40) |\n        (u64(u8(this.u8at(this.pos - 2))) << 48) |\n        (u64(u8(this.u8at(this.pos - 1))) << 56)\n      );\n    }\n    eof(): boolean {\n      if (this.invalid()) return true;\n      return super.eof();\n    }\n    varint(): u64 {\n      if (this.invalid()) return 0;\n      let value: u64;\n\n      // u32\n      value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u32 remainder or u64 byte\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value =\n        (value | ((u64(u8(this.u8at(this.pos))) & 127) << 42)) /* 42!!! */ >>>\n        0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64 remainder\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n\n      if (this.pos > this.byteLength || this.pos > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n\n      return value;\n    }\n    fixed32(): u32 {\n      if (this.invalid()) return 0;\n      this.pos += 4;\n      if (this.pos > this.byteLength || this.pos > MAX_POS) {\n        this._invalid = true;\n        return <u32>0;\n      }\n\n      // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)\n      return (\n        u32(u8(this.u8at(this.pos - 4))) |\n        (u32(u8(this.u8at(this.pos - 3))) << 8) |\n        (u32(u8(this.u8at(this.pos - 2))) << 16) |\n        (u32(u8(this.u8at(this.pos - 1))) << 24)\n      );\n    }\n    bytes(): Array<u8> {\n      if (this.invalid()) return new Array<u8>(0);\n      const len = this.uint32();\n      if (this.pos + len > this.byteLength || this.pos + len > MAX_POS) {\n        this._invalid = true;\n        return new Array<u8>(0);\n      }\n      const a = new Array<u8>(len);\n      for (let i: u32 = 0; i < len; i++) {\n        a[i] = u8(this.u8at(this.pos++));\n      }\n\n      return a;\n    }\n    skipType(wireType: u32): void {\n      if (this.invalid()) return;\n      switch (wireType) {\n        // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length\n        case 0:\n          this.varint(); // Just read a varint\n          break;\n        // fixed64, sfixed64, double: 8 bytes always\n        case 1:\n          this.skip(8);\n          break;\n        // length-delimited; length is determined by varint32; skip length bytes;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        // tart group: skip till the end of the group, then skip group end marker\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        // fixed32, sfixed32, float: 4 bytes always\n        case 5:\n          this.skip(4);\n          break;\n\n        // Something went beyond our capability to understand\n        default:\n          this._invalid = true;\n          break;\n      }\n    }\n    skip(length: u32): void {\n      if (this.invalid()) return;\n      if (this.pos + length > this.byteLength || this.pos + length > MAX_POS) {\n        this._invalid = true;\n      }\n      this.pos += length;\n    }\n  }\n\n  /**\n   * Encoder implements protobuf message encode interface. This is the simplest not very effective version, which uses\n   * Array<u8>.\n   *\n   * Useful references:\n   *\n   * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding\n   * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128\n   * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba\n   */\n  export class Encoder {\n    public buf: Array<u8>;\n\n    constructor(buf: Array<u8>) {\n      this.buf = buf;\n    }\n\n    /**\n     * Encodes varint at a current position\n     * @returns Returns varint\n     */\n    varint64(value: u64): void {\n      let v: u64 = value;\n\n      while (v > 127) {\n        this.buf.push(u8((v & 127) | 128));\n        v = v >> 7;\n      }\n\n      this.buf.push(u8(v));\n    }\n\n    @inline\n    int32(value: i32): void {\n      this.varint64(value);\n    }\n\n    @inline\n    int64(value: i64): void {\n      this.varint64(value);\n    }\n\n    @inline\n    uint32(value: u32): void {\n      this.varint64(value);\n    }\n\n    @inline\n    uint64(value: u64): void {\n      this.varint64(value);\n    }\n\n    @inline\n    sint32(value: i32): void {\n      this.varint64((value << 1) ^ (value >> 31));\n    }\n\n    @inline\n    sint64(value: i64): void {\n      this.varint64((value << 1) ^ (value >> 63));\n    }\n\n    @inline\n    fixed32(value: u32): void {\n      this.buf.push(u8(value & 255));\n      this.buf.push(u8((value >> 8) & 255));\n      this.buf.push(u8((value >> 16) & 255));\n      this.buf.push(u8(value >> 24));\n    }\n\n    @inline\n    sfixed32(value: i32): void {\n      this.fixed32(u32(value));\n    }\n\n    @inline\n    fixed64(value: u64): void {\n      this.buf.push(u8(value & 255));\n      this.buf.push(u8((value >> 8) & 255));\n      this.buf.push(u8((value >> 16) & 255));\n      this.buf.push(u8((value >> 24) & 255));\n      this.buf.push(u8((value >> 32) & 255));\n      this.buf.push(u8((value >> 40) & 255));\n      this.buf.push(u8((value >> 48) & 255));\n      this.buf.push(u8(value >> 56));\n    }\n\n    @inline\n    sfixed64(value: i64): void {\n      this.fixed64(u64(value));\n    }\n\n    @inline\n    float(value: f32): void {\n      this.fixed32(u32(i32.reinterpret_f32(value)));\n    }\n\n    @inline\n    double(value: f64): void {\n      this.fixed64(u64(i64.reinterpret_f64(value)));\n    }\n\n    @inline\n    bool(value: boolean): void {\n      this.buf.push(value ? 1 : 0);\n    }\n\n    string(value: string): void {\n      const utf8string = new DataView(String.UTF8.encode(value));\n\n      for (let i = 0; i < utf8string.byteLength; i++) {\n        this.buf.push(utf8string.getUint8(i));\n      }\n    }\n\n    @inline\n    bytes(value: Array<u8>): void {\n      for (let i = 0; i < value.length; i++) {\n        this.buf.push(value[i]);\n      }\n    }\n  }\n\n  /**\n   * Returns byte size required to encode a value of a certain type\n   */\n  export class Sizer {\n    static varint64(value: u64): u32 {\n      return value < 128\n        ? 1 // 2^7\n        : value < 16384\n        ? 2 // 2^14\n        : value < 2097152\n        ? 3 // 2^21\n        : value < 268435456\n        ? 4 // 2^28\n        : value < 34359738368\n        ? 5 // 2^35\n        : value < 4398046511104\n        ? 6 // 2^42\n        : value < 562949953421312\n        ? 7 // 2^49\n        : value < 72057594037927936\n        ? 8 // 2^56\n        : value < 9223372036854775808\n        ? 9 // 2^63\n        : 10;\n    }\n\n    @inline\n    static int32(value: i32): u32 {\n      return Sizer.varint64(u64(value));\n    }\n\n    @inline\n    static int64(value: i64): u32 {\n      return Sizer.varint64(u64(value));\n    }\n\n    @inline\n    static uint32(value: u32): u32 {\n      return Sizer.varint64(value);\n    }\n\n    @inline\n    static uint64(value: u64): u32 {\n      return Sizer.varint64(value);\n    }\n\n    @inline\n    static sint32(value: i32): u32 {\n      return Sizer.varint64((value << 1) ^ (value >> 31));\n    }\n\n    @inline\n    static sint64(value: i64): u32 {\n      return Sizer.varint64((value << 1) ^ (value >> 63));\n    }\n\n    @inline\n    static string(value: string): u32 {\n      return value.length;\n    }\n\n    @inline\n    static bytes(value: Array<u8>): u32 {\n      return value.length;\n    }\n  }\n}\nexport namespace spendables {\n  export class Output {\n    public value: u64;\n    public script: Array<u8> = new Array<u8>();\n\n    // Decodes Output from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Output {\n      return Output.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Output from a DataView\n    static decodeDataView(view: DataView): Output {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Output();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.value = decoder.uint64();\n            break;\n          }\n          case 2: {\n            obj.script = decoder.bytes();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Output>(0);\n      return obj;\n    } // decode Output\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size += this.value == 0 ? 0 : 1 + __proto.Sizer.uint64(this.value);\n      size +=\n        this.script.length > 0\n          ? 1 + __proto.Sizer.varint64(this.script.length) + this.script.length\n          : 0;\n\n      return size;\n    }\n\n    // Encodes Output to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Output to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.value != 0) {\n        encoder.uint32(0x8);\n        encoder.uint64(this.value);\n      }\n      if (this.script.length > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.script.length);\n        encoder.bytes(this.script);\n      }\n\n      return buf;\n    } // encode Output\n  } // Output\n\n  export class GetUnspentResponse {\n    public outputs: Array<Output> = new Array<Output>();\n\n    // Decodes GetUnspentResponse from an ArrayBuffer\n    static decode(buf: ArrayBuffer): GetUnspentResponse {\n      return GetUnspentResponse.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes GetUnspentResponse from a DataView\n    static decodeDataView(view: DataView): GetUnspentResponse {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new GetUnspentResponse();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.outputs.push(\n              Output.decodeDataView(\n                new DataView(\n                  decoder.view.buffer,\n                  decoder.pos + decoder.view.byteOffset,\n                  length\n                )\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<GetUnspentResponse>(0);\n      return obj;\n    } // decode GetUnspentResponse\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      for (let n: i32 = 0; n < this.outputs.length; n++) {\n        const messageSize = this.outputs[n].size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes GetUnspentResponse to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes GetUnspentResponse to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      for (let n: i32 = 0; n < this.outputs.length; n++) {\n        const messageSize = this.outputs[n].size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          this.outputs[n].encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode GetUnspentResponse\n  } // GetUnspentResponse\n} // spendables\n","namespace __proto {\n  export const MAX_POS = 0x1000;\n\n  /**\n   * Decoder implements protobuf message decode interface.\n   *\n   * Useful references:\n   *\n   * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding\n   * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128\n   * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba\n   */\n  export class Decoder {\n    public view: DataView;\n    public pos: i32;\n\n    constructor(view: DataView) {\n      this.view = view;\n      this.pos = 0;\n    }\n\n    /**\n     * Returns true if current reader has reached the buffer end\n     * @returns True if current reader has reached the buffer end\n     */\n    @inline\n    eof(): bool {\n      return this.pos >= this.view.byteLength;\n    }\n\n    /**\n     * Returns current buffer length in bytes\n     * @returns Length in bytes\n     */\n    @inline\n    get byteLength(): i32 {\n      return this.view.byteLength;\n    }\n\n    /**\n     * An alias method to fetch tag from the reader. Supposed to return tuple of [field number, wire_type].\n     * TODO: Replace with return tuple when tuples become implemented in AS.\n     * @returns Message tag value\n     */\n    @inline\n    tag(): u32 {\n      return this.uint32();\n    }\n\n    /**\n     * Returns byte at offset, alias for getUint8\n     * @param byteOffset Offset\n     * @returns u8\n     */\n    @inline\n    private u8at(byteOffset: i32): u8 {\n      return this.view.getUint8(byteOffset);\n    }\n\n    /**\n     * Reads and returns varint number (128 + 10 bits max) from a current position.\n     * @returns Returns varint\n     */\n    varint(): u64 {\n      let value: u64;\n\n      // u32\n      value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u32 remainder or u64 byte\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value =\n        (value | ((u64(u8(this.u8at(this.pos))) & 127) << 42)) /* 42!!! */ >>>\n        0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64 remainder\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      return value;\n    }\n\n    @inline\n    int32(): i32 {\n      return i32(this.varint());\n    }\n\n    @inline\n    int64(): i64 {\n      return i32(this.varint());\n    }\n\n    @inline\n    uint32(): u32 {\n      return u32(this.varint());\n    }\n\n    @inline\n    uint64(): u64 {\n      return u64(this.varint());\n    }\n\n    @inline\n    sint32(): i32 {\n      const n: u64 = this.varint();\n      return i32((n >>> 1) ^ -(n & 1));\n    }\n\n    @inline\n    sint64(): i64 {\n      const n: u64 = this.varint();\n      return i64((n >>> 1) ^ -(n & 1));\n    }\n\n    fixed32(): u32 {\n      this.pos += 4;\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)\n      return (\n        u32(u8(this.u8at(this.pos - 4))) |\n        (u32(u8(this.u8at(this.pos - 3))) << 8) |\n        (u32(u8(this.u8at(this.pos - 2))) << 16) |\n        (u32(u8(this.u8at(this.pos - 1))) << 24)\n      );\n    }\n\n    @inline\n    sfixed32(): i32 {\n      return i32(this.fixed32());\n    }\n\n    fixed64(): u64 {\n      this.pos += 8;\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      return (\n        u64(u8(this.u8at(this.pos - 8))) |\n        (u64(u8(this.u8at(this.pos - 7))) << 8) |\n        (u64(u8(this.u8at(this.pos - 6))) << 16) |\n        (u64(u8(this.u8at(this.pos - 5))) << 24) |\n        (u64(u8(this.u8at(this.pos - 4))) << 32) |\n        (u64(u8(this.u8at(this.pos - 3))) << 40) |\n        (u64(u8(this.u8at(this.pos - 2))) << 48) |\n        (u64(u8(this.u8at(this.pos - 1))) << 56)\n      );\n    }\n\n    @inline\n    sfixed64(): i64 {\n      return i64(this.fixed64());\n    }\n\n    @inline\n    float(): f32 {\n      return f32.reinterpret_i32(this.fixed32());\n    }\n\n    @inline\n    double(): f64 {\n      return f64.reinterpret_i64(this.fixed64());\n    }\n\n    @inline\n    bool(): boolean {\n      return this.uint32() > 0;\n    }\n\n    /**\n     * Reads and returns UTF8 string.\n     * @returns String\n     */\n    string(): string {\n      const length = this.uint32();\n      if (this.pos + length > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      const p = this.pos + this.view.byteOffset;\n      const value = String.UTF8.decode(this.view.buffer.slice(p, p + length));\n      this.pos += length;\n      return value;\n    }\n\n    /**\n     * Reads and returns bytes array.\n     * @returns Array<u8> of bytes\n     */\n    bytes(): Array<u8> {\n      const len = this.uint32();\n      if (this.pos + len > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      const a = new Array<u8>(len);\n      for (let i: u32 = 0; i < len; i++) {\n        a[i] = u8(this.u8at(this.pos++));\n      }\n\n      return a;\n    }\n\n    /**\n     * Skips a message field if it can'be recognized by an object's decode() method\n     * @param wireType Current wire type\n     */\n    skipType(wireType: u32): void {\n      switch (wireType) {\n        // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length\n        case 0:\n          this.varint(); // Just read a varint\n          break;\n        // fixed64, sfixed64, double: 8 bytes always\n        case 1:\n          this.skip(8);\n          break;\n        // length-delimited; length is determined by varint32; skip length bytes;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        // tart group: skip till the end of the group, then skip group end marker\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        // fixed32, sfixed32, float: 4 bytes always\n        case 5:\n          this.skip(4);\n          break;\n\n        // Something went beyond our capability to understand\n        default:\n          throw new Error(\n            `Invalid wire type ${wireType} at offset ${this.pos}`\n          );\n      }\n    }\n\n    /**\n     * Fast-forwards cursor by length with boundary check\n     * @param length Byte length\n     */\n    skip(length: u32): void {\n      if (this.pos + length > this.byteLength) {\n        this.throwOutOfRange();\n      }\n      this.pos += length;\n    }\n\n    /**\n     * OutOfRange check. Throws an exception if current position exceeds current buffer range\n     */\n    @inline\n    private throwOutOfRange(): void {\n      throw new Error(`Decoder position ${this.pos} is out of range!`);\n    }\n  }\n\n  class SafeDecoder extends Decoder {\n    public _invalid: boolean;\n    invalid(): boolean {\n      if (this._invalid) return true;\n      if (this.pos > MAX_POS) {\n        this._invalid = true;\n        return true;\n      }\n      return false;\n    }\n    string(): string {\n      if (this.invalid()) return \"\";\n      const length = this.uint32();\n      if (this.pos + length > this.byteLength) {\n        this._invalid = true;\n        return \"\";\n      }\n      const p = this.pos + this.view.byteOffset;\n      const value = String.UTF8.decode(this.view.buffer.slice(p, p + length));\n      this.pos += length;\n      return value;\n    }\n    @inline\n    sfixed64(): i64 {\n      if (this.invalid()) return 0;\n      return i64(this.fixed64());\n    }\n\n    @inline\n    float(): f32 {\n      if (this.invalid()) return 0;\n      return f32.reinterpret_i32(this.fixed32());\n    }\n\n    @inline\n    double(): f64 {\n      if (this.invalid()) return 0;\n      return f64.reinterpret_i64(this.fixed64());\n    }\n\n    @inline\n    bool(): boolean {\n      if (this.invalid()) return false;\n      return this.uint32() > 0;\n    }\n    fixed64(): u64 {\n      if (this.invalid()) return 0;\n      this.pos += 8;\n      if (this.pos > this.byteLength || this.pos > MAX_POS) {\n        this._invalid = true;\n        return <u64>0;\n      }\n\n      return (\n        u64(u8(this.u8at(this.pos - 8))) |\n        (u64(u8(this.u8at(this.pos - 7))) << 8) |\n        (u64(u8(this.u8at(this.pos - 6))) << 16) |\n        (u64(u8(this.u8at(this.pos - 5))) << 24) |\n        (u64(u8(this.u8at(this.pos - 4))) << 32) |\n        (u64(u8(this.u8at(this.pos - 3))) << 40) |\n        (u64(u8(this.u8at(this.pos - 2))) << 48) |\n        (u64(u8(this.u8at(this.pos - 1))) << 56)\n      );\n    }\n    eof(): boolean {\n      if (this.invalid()) return true;\n      return super.eof();\n    }\n    varint(): u64 {\n      if (this.invalid()) return 0;\n      let value: u64;\n\n      // u32\n      value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u32 remainder or u64 byte\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value =\n        (value | ((u64(u8(this.u8at(this.pos))) & 127) << 42)) /* 42!!! */ >>>\n        0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64 remainder\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n\n      if (this.pos > this.byteLength || this.pos > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n\n      return value;\n    }\n    fixed32(): u32 {\n      if (this.invalid()) return 0;\n      this.pos += 4;\n      if (this.pos > this.byteLength || this.pos > MAX_POS) {\n        this._invalid = true;\n        return <u32>0;\n      }\n\n      // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)\n      return (\n        u32(u8(this.u8at(this.pos - 4))) |\n        (u32(u8(this.u8at(this.pos - 3))) << 8) |\n        (u32(u8(this.u8at(this.pos - 2))) << 16) |\n        (u32(u8(this.u8at(this.pos - 1))) << 24)\n      );\n    }\n    bytes(): Array<u8> {\n      if (this.invalid()) return new Array<u8>(0);\n      const len = this.uint32();\n      if (this.pos + len > this.byteLength || this.pos + len > MAX_POS) {\n        this._invalid = true;\n        return new Array<u8>(0);\n      }\n      const a = new Array<u8>(len);\n      for (let i: u32 = 0; i < len; i++) {\n        a[i] = u8(this.u8at(this.pos++));\n      }\n\n      return a;\n    }\n    skipType(wireType: u32): void {\n      if (this.invalid()) return;\n      switch (wireType) {\n        // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length\n        case 0:\n          this.varint(); // Just read a varint\n          break;\n        // fixed64, sfixed64, double: 8 bytes always\n        case 1:\n          this.skip(8);\n          break;\n        // length-delimited; length is determined by varint32; skip length bytes;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        // tart group: skip till the end of the group, then skip group end marker\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        // fixed32, sfixed32, float: 4 bytes always\n        case 5:\n          this.skip(4);\n          break;\n\n        // Something went beyond our capability to understand\n        default:\n          this._invalid = true;\n          break;\n      }\n    }\n    skip(length: u32): void {\n      if (this.invalid()) return;\n      if (this.pos + length > this.byteLength || this.pos + length > MAX_POS) {\n        this._invalid = true;\n      }\n      this.pos += length;\n    }\n  }\n\n  /**\n   * Encoder implements protobuf message encode interface. This is the simplest not very effective version, which uses\n   * Array<u8>.\n   *\n   * Useful references:\n   *\n   * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding\n   * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128\n   * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba\n   */\n  export class Encoder {\n    public buf: Array<u8>;\n\n    constructor(buf: Array<u8>) {\n      this.buf = buf;\n    }\n\n    /**\n     * Encodes varint at a current position\n     * @returns Returns varint\n     */\n    varint64(value: u64): void {\n      let v: u64 = value;\n\n      while (v > 127) {\n        this.buf.push(u8((v & 127) | 128));\n        v = v >> 7;\n      }\n\n      this.buf.push(u8(v));\n    }\n\n    @inline\n    int32(value: i32): void {\n      this.varint64(value);\n    }\n\n    @inline\n    int64(value: i64): void {\n      this.varint64(value);\n    }\n\n    @inline\n    uint32(value: u32): void {\n      this.varint64(value);\n    }\n\n    @inline\n    uint64(value: u64): void {\n      this.varint64(value);\n    }\n\n    @inline\n    sint32(value: i32): void {\n      this.varint64((value << 1) ^ (value >> 31));\n    }\n\n    @inline\n    sint64(value: i64): void {\n      this.varint64((value << 1) ^ (value >> 63));\n    }\n\n    @inline\n    fixed32(value: u32): void {\n      this.buf.push(u8(value & 255));\n      this.buf.push(u8((value >> 8) & 255));\n      this.buf.push(u8((value >> 16) & 255));\n      this.buf.push(u8(value >> 24));\n    }\n\n    @inline\n    sfixed32(value: i32): void {\n      this.fixed32(u32(value));\n    }\n\n    @inline\n    fixed64(value: u64): void {\n      this.buf.push(u8(value & 255));\n      this.buf.push(u8((value >> 8) & 255));\n      this.buf.push(u8((value >> 16) & 255));\n      this.buf.push(u8((value >> 24) & 255));\n      this.buf.push(u8((value >> 32) & 255));\n      this.buf.push(u8((value >> 40) & 255));\n      this.buf.push(u8((value >> 48) & 255));\n      this.buf.push(u8(value >> 56));\n    }\n\n    @inline\n    sfixed64(value: i64): void {\n      this.fixed64(u64(value));\n    }\n\n    @inline\n    float(value: f32): void {\n      this.fixed32(u32(i32.reinterpret_f32(value)));\n    }\n\n    @inline\n    double(value: f64): void {\n      this.fixed64(u64(i64.reinterpret_f64(value)));\n    }\n\n    @inline\n    bool(value: boolean): void {\n      this.buf.push(value ? 1 : 0);\n    }\n\n    string(value: string): void {\n      const utf8string = new DataView(String.UTF8.encode(value));\n\n      for (let i = 0; i < utf8string.byteLength; i++) {\n        this.buf.push(utf8string.getUint8(i));\n      }\n    }\n\n    @inline\n    bytes(value: Array<u8>): void {\n      for (let i = 0; i < value.length; i++) {\n        this.buf.push(value[i]);\n      }\n    }\n  }\n\n  /**\n   * Returns byte size required to encode a value of a certain type\n   */\n  export class Sizer {\n    static varint64(value: u64): u32 {\n      return value < 128\n        ? 1 // 2^7\n        : value < 16384\n        ? 2 // 2^14\n        : value < 2097152\n        ? 3 // 2^21\n        : value < 268435456\n        ? 4 // 2^28\n        : value < 34359738368\n        ? 5 // 2^35\n        : value < 4398046511104\n        ? 6 // 2^42\n        : value < 562949953421312\n        ? 7 // 2^49\n        : value < 72057594037927936\n        ? 8 // 2^56\n        : value < 9223372036854775808\n        ? 9 // 2^63\n        : 10;\n    }\n\n    @inline\n    static int32(value: i32): u32 {\n      return Sizer.varint64(u64(value));\n    }\n\n    @inline\n    static int64(value: i64): u32 {\n      return Sizer.varint64(u64(value));\n    }\n\n    @inline\n    static uint32(value: u32): u32 {\n      return Sizer.varint64(value);\n    }\n\n    @inline\n    static uint64(value: u64): u32 {\n      return Sizer.varint64(value);\n    }\n\n    @inline\n    static sint32(value: i32): u32 {\n      return Sizer.varint64((value << 1) ^ (value >> 31));\n    }\n\n    @inline\n    static sint64(value: i64): u32 {\n      return Sizer.varint64((value << 1) ^ (value >> 63));\n    }\n\n    @inline\n    static string(value: string): u32 {\n      return value.length;\n    }\n\n    @inline\n    static bytes(value: Array<u8>): u32 {\n      return value.length;\n    }\n  }\n}\nexport namespace metashrew_runes {\n  export class RuneId {\n    public height: u32;\n    public txindex: u32;\n\n    // Decodes RuneId from an ArrayBuffer\n    static decode(buf: ArrayBuffer): RuneId {\n      return RuneId.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes RuneId from a DataView\n    static decodeDataView(view: DataView): RuneId {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new RuneId();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.height = decoder.uint32();\n            break;\n          }\n          case 2: {\n            obj.txindex = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<RuneId>(0);\n      return obj;\n    } // decode RuneId\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size += this.height == 0 ? 0 : 1 + __proto.Sizer.uint32(this.height);\n      size += this.txindex == 0 ? 0 : 1 + __proto.Sizer.uint32(this.txindex);\n\n      return size;\n    }\n\n    // Encodes RuneId to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes RuneId to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.height != 0) {\n        encoder.uint32(0x8);\n        encoder.uint32(this.height);\n      }\n      if (this.txindex != 0) {\n        encoder.uint32(0x10);\n        encoder.uint32(this.txindex);\n      }\n\n      return buf;\n    } // encode RuneId\n  } // RuneId\n\n  export class Rune {\n    public runeId: RuneId = new RuneId();\n    public name: Array<u8> = new Array<u8>();\n    public divisibility: u32;\n    public spacers: u32;\n    public symbol: u32;\n\n    // Decodes Rune from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Rune {\n      return Rune.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Rune from a DataView\n    static decodeDataView(view: DataView): Rune {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Rune();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.runeId = RuneId.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 2: {\n            obj.name = decoder.bytes();\n            break;\n          }\n          case 3: {\n            obj.divisibility = decoder.uint32();\n            break;\n          }\n          case 4: {\n            obj.spacers = decoder.uint32();\n            break;\n          }\n          case 5: {\n            obj.symbol = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Rune>(0);\n      return obj;\n    } // decode Rune\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      if (this.runeId != null) {\n        const f: RuneId = this.runeId as RuneId;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      size +=\n        this.name.length > 0\n          ? 1 + __proto.Sizer.varint64(this.name.length) + this.name.length\n          : 0;\n      size +=\n        this.divisibility == 0\n          ? 0\n          : 1 + __proto.Sizer.uint32(this.divisibility);\n      size += this.spacers == 0 ? 0 : 1 + __proto.Sizer.uint32(this.spacers);\n      size += this.symbol == 0 ? 0 : 1 + __proto.Sizer.uint32(this.symbol);\n\n      return size;\n    }\n\n    // Encodes Rune to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Rune to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.runeId != null) {\n        const f = this.runeId as RuneId;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.name.length > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.name.length);\n        encoder.bytes(this.name);\n      }\n      if (this.divisibility != 0) {\n        encoder.uint32(0x18);\n        encoder.uint32(this.divisibility);\n      }\n      if (this.spacers != 0) {\n        encoder.uint32(0x20);\n        encoder.uint32(this.spacers);\n      }\n      if (this.symbol != 0) {\n        encoder.uint32(0x28);\n        encoder.uint32(this.symbol);\n      }\n\n      return buf;\n    } // encode Rune\n  } // Rune\n\n  export class BalanceSheetItem {\n    public rune: Rune = new Rune();\n    public balance: Array<u8> = new Array<u8>();\n\n    // Decodes BalanceSheetItem from an ArrayBuffer\n    static decode(buf: ArrayBuffer): BalanceSheetItem {\n      return BalanceSheetItem.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes BalanceSheetItem from a DataView\n    static decodeDataView(view: DataView): BalanceSheetItem {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new BalanceSheetItem();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.rune = Rune.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 2: {\n            obj.balance = decoder.bytes();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<BalanceSheetItem>(0);\n      return obj;\n    } // decode BalanceSheetItem\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      if (this.rune != null) {\n        const f: Rune = this.rune as Rune;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      size +=\n        this.balance.length > 0\n          ? 1 +\n            __proto.Sizer.varint64(this.balance.length) +\n            this.balance.length\n          : 0;\n\n      return size;\n    }\n\n    // Encodes BalanceSheetItem to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes BalanceSheetItem to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.rune != null) {\n        const f = this.rune as Rune;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.balance.length > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.balance.length);\n        encoder.bytes(this.balance);\n      }\n\n      return buf;\n    } // encode BalanceSheetItem\n  } // BalanceSheetItem\n\n  export class BalanceSheet {\n    public entries: Array<BalanceSheetItem> = new Array<BalanceSheetItem>();\n\n    // Decodes BalanceSheet from an ArrayBuffer\n    static decode(buf: ArrayBuffer): BalanceSheet {\n      return BalanceSheet.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes BalanceSheet from a DataView\n    static decodeDataView(view: DataView): BalanceSheet {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new BalanceSheet();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.entries.push(\n              BalanceSheetItem.decodeDataView(\n                new DataView(\n                  decoder.view.buffer,\n                  decoder.pos + decoder.view.byteOffset,\n                  length\n                )\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<BalanceSheet>(0);\n      return obj;\n    } // decode BalanceSheet\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      for (let n: i32 = 0; n < this.entries.length; n++) {\n        const messageSize = this.entries[n].size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes BalanceSheet to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes BalanceSheet to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      for (let n: i32 = 0; n < this.entries.length; n++) {\n        const messageSize = this.entries[n].size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          this.entries[n].encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode BalanceSheet\n  } // BalanceSheet\n\n  export class Outpoint {\n    public txid: Array<u8> = new Array<u8>();\n    public vout: u32;\n\n    // Decodes Outpoint from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Outpoint {\n      return Outpoint.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Outpoint from a DataView\n    static decodeDataView(view: DataView): Outpoint {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Outpoint();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.txid = decoder.bytes();\n            break;\n          }\n          case 2: {\n            obj.vout = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Outpoint>(0);\n      return obj;\n    } // decode Outpoint\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.txid.length > 0\n          ? 1 + __proto.Sizer.varint64(this.txid.length) + this.txid.length\n          : 0;\n      size += this.vout == 0 ? 0 : 1 + __proto.Sizer.uint32(this.vout);\n\n      return size;\n    }\n\n    // Encodes Outpoint to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Outpoint to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.txid.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.txid.length);\n        encoder.bytes(this.txid);\n      }\n      if (this.vout != 0) {\n        encoder.uint32(0x10);\n        encoder.uint32(this.vout);\n      }\n\n      return buf;\n    } // encode Outpoint\n  } // Outpoint\n\n  export class Output {\n    public script: Array<u8> = new Array<u8>();\n    public value: u64;\n\n    // Decodes Output from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Output {\n      return Output.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Output from a DataView\n    static decodeDataView(view: DataView): Output {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Output();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.script = decoder.bytes();\n            break;\n          }\n          case 2: {\n            obj.value = decoder.uint64();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Output>(0);\n      return obj;\n    } // decode Output\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.script.length > 0\n          ? 1 + __proto.Sizer.varint64(this.script.length) + this.script.length\n          : 0;\n      size += this.value == 0 ? 0 : 1 + __proto.Sizer.uint64(this.value);\n\n      return size;\n    }\n\n    // Encodes Output to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Output to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.script.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.script.length);\n        encoder.bytes(this.script);\n      }\n      if (this.value != 0) {\n        encoder.uint32(0x10);\n        encoder.uint64(this.value);\n      }\n\n      return buf;\n    } // encode Output\n  } // Output\n\n  export class OutpointResponse {\n    public balances: BalanceSheet = new BalanceSheet();\n    public outpoint: Outpoint = new Outpoint();\n    public output: Output = new Output();\n    public height: u32;\n    public txindex: u32;\n\n    // Decodes OutpointResponse from an ArrayBuffer\n    static decode(buf: ArrayBuffer): OutpointResponse {\n      return OutpointResponse.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes OutpointResponse from a DataView\n    static decodeDataView(view: DataView): OutpointResponse {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new OutpointResponse();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.balances = BalanceSheet.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 2: {\n            const length = decoder.uint32();\n            obj.outpoint = Outpoint.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 3: {\n            const length = decoder.uint32();\n            obj.output = Output.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 4: {\n            obj.height = decoder.uint32();\n            break;\n          }\n          case 5: {\n            obj.txindex = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<OutpointResponse>(0);\n      return obj;\n    } // decode OutpointResponse\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      if (this.balances != null) {\n        const f: BalanceSheet = this.balances as BalanceSheet;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      if (this.outpoint != null) {\n        const f: Outpoint = this.outpoint as Outpoint;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      if (this.output != null) {\n        const f: Output = this.output as Output;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      size += this.height == 0 ? 0 : 1 + __proto.Sizer.uint32(this.height);\n      size += this.txindex == 0 ? 0 : 1 + __proto.Sizer.uint32(this.txindex);\n\n      return size;\n    }\n\n    // Encodes OutpointResponse to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes OutpointResponse to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.balances != null) {\n        const f = this.balances as BalanceSheet;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.outpoint != null) {\n        const f = this.outpoint as Outpoint;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0x12);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.output != null) {\n        const f = this.output as Output;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0x1a);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.height != 0) {\n        encoder.uint32(0x20);\n        encoder.uint32(this.height);\n      }\n      if (this.txindex != 0) {\n        encoder.uint32(0x28);\n        encoder.uint32(this.txindex);\n      }\n\n      return buf;\n    } // encode OutpointResponse\n  } // OutpointResponse\n\n  export class PaginationInput {\n    public start: u32;\n    public end: u32;\n\n    // Decodes PaginationInput from an ArrayBuffer\n    static decode(buf: ArrayBuffer): PaginationInput {\n      return PaginationInput.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes PaginationInput from a DataView\n    static decodeDataView(view: DataView): PaginationInput {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new PaginationInput();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.start = decoder.uint32();\n            break;\n          }\n          case 2: {\n            obj.end = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<PaginationInput>(0);\n      return obj;\n    } // decode PaginationInput\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size += this.start == 0 ? 0 : 1 + __proto.Sizer.uint32(this.start);\n      size += this.end == 0 ? 0 : 1 + __proto.Sizer.uint32(this.end);\n\n      return size;\n    }\n\n    // Encodes PaginationInput to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes PaginationInput to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.start != 0) {\n        encoder.uint32(0x8);\n        encoder.uint32(this.start);\n      }\n      if (this.end != 0) {\n        encoder.uint32(0x10);\n        encoder.uint32(this.end);\n      }\n\n      return buf;\n    } // encode PaginationInput\n  } // PaginationInput\n\n  export class WalletRequest {\n    public wallet: Array<u8> = new Array<u8>();\n\n    // Decodes WalletRequest from an ArrayBuffer\n    static decode(buf: ArrayBuffer): WalletRequest {\n      return WalletRequest.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes WalletRequest from a DataView\n    static decodeDataView(view: DataView): WalletRequest {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new WalletRequest();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.wallet = decoder.bytes();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<WalletRequest>(0);\n      return obj;\n    } // decode WalletRequest\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.wallet.length > 0\n          ? 1 + __proto.Sizer.varint64(this.wallet.length) + this.wallet.length\n          : 0;\n\n      return size;\n    }\n\n    // Encodes WalletRequest to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes WalletRequest to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.wallet.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.wallet.length);\n        encoder.bytes(this.wallet);\n      }\n\n      return buf;\n    } // encode WalletRequest\n  } // WalletRequest\n\n  export class WalletResponse {\n    public outpoints: Array<OutpointResponse> = new Array<OutpointResponse>();\n    public balances: BalanceSheet = new BalanceSheet();\n\n    // Decodes WalletResponse from an ArrayBuffer\n    static decode(buf: ArrayBuffer): WalletResponse {\n      return WalletResponse.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes WalletResponse from a DataView\n    static decodeDataView(view: DataView): WalletResponse {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new WalletResponse();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.outpoints.push(\n              OutpointResponse.decodeDataView(\n                new DataView(\n                  decoder.view.buffer,\n                  decoder.pos + decoder.view.byteOffset,\n                  length\n                )\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 2: {\n            const length = decoder.uint32();\n            obj.balances = BalanceSheet.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<WalletResponse>(0);\n      return obj;\n    } // decode WalletResponse\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      for (let n: i32 = 0; n < this.outpoints.length; n++) {\n        const messageSize = this.outpoints[n].size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      if (this.balances != null) {\n        const f: BalanceSheet = this.balances as BalanceSheet;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes WalletResponse to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes WalletResponse to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      for (let n: i32 = 0; n < this.outpoints.length; n++) {\n        const messageSize = this.outpoints[n].size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          this.outpoints[n].encodeU8Array(encoder);\n        }\n      }\n\n      if (this.balances != null) {\n        const f = this.balances as BalanceSheet;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0x12);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode WalletResponse\n  } // WalletResponse\n\n  export class RunesResponse {\n    public runes: Array<Rune> = new Array<Rune>();\n\n    // Decodes RunesResponse from an ArrayBuffer\n    static decode(buf: ArrayBuffer): RunesResponse {\n      return RunesResponse.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes RunesResponse from a DataView\n    static decodeDataView(view: DataView): RunesResponse {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new RunesResponse();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.runes.push(\n              Rune.decodeDataView(\n                new DataView(\n                  decoder.view.buffer,\n                  decoder.pos + decoder.view.byteOffset,\n                  length\n                )\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<RunesResponse>(0);\n      return obj;\n    } // decode RunesResponse\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      for (let n: i32 = 0; n < this.runes.length; n++) {\n        const messageSize = this.runes[n].size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes RunesResponse to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes RunesResponse to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      for (let n: i32 = 0; n < this.runes.length; n++) {\n        const messageSize = this.runes[n].size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          this.runes[n].encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode RunesResponse\n  } // RunesResponse\n\n  export class ProtoBurn {\n    public protocol_tag: Array<u8> = new Array<u8>();\n    public pointer: u32;\n\n    // Decodes ProtoBurn from an ArrayBuffer\n    static decode(buf: ArrayBuffer): ProtoBurn {\n      return ProtoBurn.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes ProtoBurn from a DataView\n    static decodeDataView(view: DataView): ProtoBurn {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new ProtoBurn();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.protocol_tag = decoder.bytes();\n            break;\n          }\n          case 2: {\n            obj.pointer = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<ProtoBurn>(0);\n      return obj;\n    } // decode ProtoBurn\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.protocol_tag.length > 0\n          ? 1 +\n            __proto.Sizer.varint64(this.protocol_tag.length) +\n            this.protocol_tag.length\n          : 0;\n      size += this.pointer == 0 ? 0 : 1 + __proto.Sizer.uint32(this.pointer);\n\n      return size;\n    }\n\n    // Encodes ProtoBurn to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes ProtoBurn to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.protocol_tag.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.protocol_tag.length);\n        encoder.bytes(this.protocol_tag);\n      }\n      if (this.pointer != 0) {\n        encoder.uint32(0x10);\n        encoder.uint32(this.pointer);\n      }\n\n      return buf;\n    } // encode ProtoBurn\n  } // ProtoBurn\n\n  export class uint128 {\n    public lo: u64;\n    public hi: u64;\n\n    // Decodes uint128 from an ArrayBuffer\n    static decode(buf: ArrayBuffer): uint128 {\n      return uint128.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes uint128 from a DataView\n    static decodeDataView(view: DataView): uint128 {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new uint128();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.lo = decoder.uint64();\n            break;\n          }\n          case 2: {\n            obj.hi = decoder.uint64();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<uint128>(0);\n      return obj;\n    } // decode uint128\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size += this.lo == 0 ? 0 : 1 + __proto.Sizer.uint64(this.lo);\n      size += this.hi == 0 ? 0 : 1 + __proto.Sizer.uint64(this.hi);\n\n      return size;\n    }\n\n    // Encodes uint128 to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes uint128 to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.lo != 0) {\n        encoder.uint32(0x8);\n        encoder.uint64(this.lo);\n      }\n      if (this.hi != 0) {\n        encoder.uint32(0x10);\n        encoder.uint64(this.hi);\n      }\n\n      return buf;\n    } // encode uint128\n  } // uint128\n\n  export class Clause {\n    public rune: RuneId = new RuneId();\n    public amount: uint128 = new uint128();\n\n    // Decodes Clause from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Clause {\n      return Clause.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Clause from a DataView\n    static decodeDataView(view: DataView): Clause {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Clause();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.rune = RuneId.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 2: {\n            const length = decoder.uint32();\n            obj.amount = uint128.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Clause>(0);\n      return obj;\n    } // decode Clause\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      if (this.rune != null) {\n        const f: RuneId = this.rune as RuneId;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      if (this.amount != null) {\n        const f: uint128 = this.amount as uint128;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes Clause to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Clause to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.rune != null) {\n        const f = this.rune as RuneId;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.amount != null) {\n        const f = this.amount as uint128;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0x12);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode Clause\n  } // Clause\n\n  export class Predicate {\n    public clauses: Array<Clause> = new Array<Clause>();\n\n    // Decodes Predicate from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Predicate {\n      return Predicate.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Predicate from a DataView\n    static decodeDataView(view: DataView): Predicate {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Predicate();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.clauses.push(\n              Clause.decodeDataView(\n                new DataView(\n                  decoder.view.buffer,\n                  decoder.pos + decoder.view.byteOffset,\n                  length\n                )\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Predicate>(0);\n      return obj;\n    } // decode Predicate\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      for (let n: i32 = 0; n < this.clauses.length; n++) {\n        const messageSize = this.clauses[n].size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes Predicate to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Predicate to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      for (let n: i32 = 0; n < this.clauses.length; n++) {\n        const messageSize = this.clauses[n].size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          this.clauses[n].encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode Predicate\n  } // Predicate\n\n  export class ProtoMessage {\n    public calldata: Array<u8> = new Array<u8>();\n    public predicate: Predicate = new Predicate();\n    public pointer: u32;\n    public refund_pointer: u32;\n\n    // Decodes ProtoMessage from an ArrayBuffer\n    static decode(buf: ArrayBuffer): ProtoMessage {\n      return ProtoMessage.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes ProtoMessage from a DataView\n    static decodeDataView(view: DataView): ProtoMessage {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new ProtoMessage();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.calldata = decoder.bytes();\n            break;\n          }\n          case 2: {\n            const length = decoder.uint32();\n            obj.predicate = Predicate.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 3: {\n            obj.pointer = decoder.uint32();\n            break;\n          }\n          case 4: {\n            obj.refund_pointer = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<ProtoMessage>(0);\n      return obj;\n    } // decode ProtoMessage\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.calldata.length > 0\n          ? 1 +\n            __proto.Sizer.varint64(this.calldata.length) +\n            this.calldata.length\n          : 0;\n\n      if (this.predicate != null) {\n        const f: Predicate = this.predicate as Predicate;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      size += this.pointer == 0 ? 0 : 1 + __proto.Sizer.uint32(this.pointer);\n      size +=\n        this.refund_pointer == 0\n          ? 0\n          : 1 + __proto.Sizer.uint32(this.refund_pointer);\n\n      return size;\n    }\n\n    // Encodes ProtoMessage to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes ProtoMessage to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.calldata.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.calldata.length);\n        encoder.bytes(this.calldata);\n      }\n\n      if (this.predicate != null) {\n        const f = this.predicate as Predicate;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0x12);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.pointer != 0) {\n        encoder.uint32(0x18);\n        encoder.uint32(this.pointer);\n      }\n      if (this.refund_pointer != 0) {\n        encoder.uint32(0x20);\n        encoder.uint32(this.refund_pointer);\n      }\n\n      return buf;\n    } // encode ProtoMessage\n  } // ProtoMessage\n} // metashrew_runes\n","namespace __proto {\n  export const MAX_POS = 0x1000;\n\n  /**\n   * Decoder implements protobuf message decode interface.\n   *\n   * Useful references:\n   *\n   * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding\n   * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128\n   * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba\n   */\n  export class Decoder {\n    public view: DataView;\n    public pos: i32;\n\n    constructor(view: DataView) {\n      this.view = view;\n      this.pos = 0;\n    }\n\n    /**\n     * Returns true if current reader has reached the buffer end\n     * @returns True if current reader has reached the buffer end\n     */\n    @inline\n    eof(): bool {\n      return this.pos >= this.view.byteLength;\n    }\n\n    /**\n     * Returns current buffer length in bytes\n     * @returns Length in bytes\n     */\n    @inline\n    get byteLength(): i32 {\n      return this.view.byteLength;\n    }\n\n    /**\n     * An alias method to fetch tag from the reader. Supposed to return tuple of [field number, wire_type].\n     * TODO: Replace with return tuple when tuples become implemented in AS.\n     * @returns Message tag value\n     */\n    @inline\n    tag(): u32 {\n      return this.uint32();\n    }\n\n    /**\n     * Returns byte at offset, alias for getUint8\n     * @param byteOffset Offset\n     * @returns u8\n     */\n    @inline\n    private u8at(byteOffset: i32): u8 {\n      return this.view.getUint8(byteOffset);\n    }\n\n    /**\n     * Reads and returns varint number (128 + 10 bits max) from a current position.\n     * @returns Returns varint\n     */\n    varint(): u64 {\n      let value: u64;\n\n      // u32\n      value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u32 remainder or u64 byte\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value =\n        (value | ((u64(u8(this.u8at(this.pos))) & 127) << 42)) /* 42!!! */ >>>\n        0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64 remainder\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      return value;\n    }\n\n    @inline\n    int32(): i32 {\n      return i32(this.varint());\n    }\n\n    @inline\n    int64(): i64 {\n      return i32(this.varint());\n    }\n\n    @inline\n    uint32(): u32 {\n      return u32(this.varint());\n    }\n\n    @inline\n    uint64(): u64 {\n      return u64(this.varint());\n    }\n\n    @inline\n    sint32(): i32 {\n      const n: u64 = this.varint();\n      return i32((n >>> 1) ^ -(n & 1));\n    }\n\n    @inline\n    sint64(): i64 {\n      const n: u64 = this.varint();\n      return i64((n >>> 1) ^ -(n & 1));\n    }\n\n    fixed32(): u32 {\n      this.pos += 4;\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)\n      return (\n        u32(u8(this.u8at(this.pos - 4))) |\n        (u32(u8(this.u8at(this.pos - 3))) << 8) |\n        (u32(u8(this.u8at(this.pos - 2))) << 16) |\n        (u32(u8(this.u8at(this.pos - 1))) << 24)\n      );\n    }\n\n    @inline\n    sfixed32(): i32 {\n      return i32(this.fixed32());\n    }\n\n    fixed64(): u64 {\n      this.pos += 8;\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      return (\n        u64(u8(this.u8at(this.pos - 8))) |\n        (u64(u8(this.u8at(this.pos - 7))) << 8) |\n        (u64(u8(this.u8at(this.pos - 6))) << 16) |\n        (u64(u8(this.u8at(this.pos - 5))) << 24) |\n        (u64(u8(this.u8at(this.pos - 4))) << 32) |\n        (u64(u8(this.u8at(this.pos - 3))) << 40) |\n        (u64(u8(this.u8at(this.pos - 2))) << 48) |\n        (u64(u8(this.u8at(this.pos - 1))) << 56)\n      );\n    }\n\n    @inline\n    sfixed64(): i64 {\n      return i64(this.fixed64());\n    }\n\n    @inline\n    float(): f32 {\n      return f32.reinterpret_i32(this.fixed32());\n    }\n\n    @inline\n    double(): f64 {\n      return f64.reinterpret_i64(this.fixed64());\n    }\n\n    @inline\n    bool(): boolean {\n      return this.uint32() > 0;\n    }\n\n    /**\n     * Reads and returns UTF8 string.\n     * @returns String\n     */\n    string(): string {\n      const length = this.uint32();\n      if (this.pos + length > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      const p = this.pos + this.view.byteOffset;\n      const value = String.UTF8.decode(this.view.buffer.slice(p, p + length));\n      this.pos += length;\n      return value;\n    }\n\n    /**\n     * Reads and returns bytes array.\n     * @returns Array<u8> of bytes\n     */\n    bytes(): Array<u8> {\n      const len = this.uint32();\n      if (this.pos + len > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      const a = new Array<u8>(len);\n      for (let i: u32 = 0; i < len; i++) {\n        a[i] = u8(this.u8at(this.pos++));\n      }\n\n      return a;\n    }\n\n    /**\n     * Skips a message field if it can'be recognized by an object's decode() method\n     * @param wireType Current wire type\n     */\n    skipType(wireType: u32): void {\n      switch (wireType) {\n        // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length\n        case 0:\n          this.varint(); // Just read a varint\n          break;\n        // fixed64, sfixed64, double: 8 bytes always\n        case 1:\n          this.skip(8);\n          break;\n        // length-delimited; length is determined by varint32; skip length bytes;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        // tart group: skip till the end of the group, then skip group end marker\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        // fixed32, sfixed32, float: 4 bytes always\n        case 5:\n          this.skip(4);\n          break;\n\n        // Something went beyond our capability to understand\n        default:\n          throw new Error(\n            `Invalid wire type ${wireType} at offset ${this.pos}`\n          );\n      }\n    }\n\n    /**\n     * Fast-forwards cursor by length with boundary check\n     * @param length Byte length\n     */\n    skip(length: u32): void {\n      if (this.pos + length > this.byteLength) {\n        this.throwOutOfRange();\n      }\n      this.pos += length;\n    }\n\n    /**\n     * OutOfRange check. Throws an exception if current position exceeds current buffer range\n     */\n    @inline\n    private throwOutOfRange(): void {\n      throw new Error(`Decoder position ${this.pos} is out of range!`);\n    }\n  }\n\n  class SafeDecoder extends Decoder {\n    public _invalid: boolean;\n    invalid(): boolean {\n      if (this._invalid) return true;\n      if (this.pos > MAX_POS) {\n        this._invalid = true;\n        return true;\n      }\n      return false;\n    }\n    string(): string {\n      if (this.invalid()) return \"\";\n      const length = this.uint32();\n      if (this.pos + length > this.byteLength) {\n        this._invalid = true;\n        return \"\";\n      }\n      const p = this.pos + this.view.byteOffset;\n      const value = String.UTF8.decode(this.view.buffer.slice(p, p + length));\n      this.pos += length;\n      return value;\n    }\n    @inline\n    sfixed64(): i64 {\n      if (this.invalid()) return 0;\n      return i64(this.fixed64());\n    }\n\n    @inline\n    float(): f32 {\n      if (this.invalid()) return 0;\n      return f32.reinterpret_i32(this.fixed32());\n    }\n\n    @inline\n    double(): f64 {\n      if (this.invalid()) return 0;\n      return f64.reinterpret_i64(this.fixed64());\n    }\n\n    @inline\n    bool(): boolean {\n      if (this.invalid()) return false;\n      return this.uint32() > 0;\n    }\n    fixed64(): u64 {\n      if (this.invalid()) return 0;\n      this.pos += 8;\n      if (this.pos > this.byteLength || this.pos > MAX_POS) {\n        this._invalid = true;\n        return <u64>0;\n      }\n\n      return (\n        u64(u8(this.u8at(this.pos - 8))) |\n        (u64(u8(this.u8at(this.pos - 7))) << 8) |\n        (u64(u8(this.u8at(this.pos - 6))) << 16) |\n        (u64(u8(this.u8at(this.pos - 5))) << 24) |\n        (u64(u8(this.u8at(this.pos - 4))) << 32) |\n        (u64(u8(this.u8at(this.pos - 3))) << 40) |\n        (u64(u8(this.u8at(this.pos - 2))) << 48) |\n        (u64(u8(this.u8at(this.pos - 1))) << 56)\n      );\n    }\n    eof(): boolean {\n      if (this.invalid()) return true;\n      return super.eof();\n    }\n    varint(): u64 {\n      if (this.invalid()) return 0;\n      let value: u64;\n\n      // u32\n      value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u32 remainder or u64 byte\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value =\n        (value | ((u64(u8(this.u8at(this.pos))) & 127) << 42)) /* 42!!! */ >>>\n        0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64 remainder\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (this.pos + 1 > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n\n      if (this.pos > this.byteLength || this.pos > MAX_POS) {\n        this._invalid = true;\n        return 0;\n      }\n\n      return value;\n    }\n    fixed32(): u32 {\n      if (this.invalid()) return 0;\n      this.pos += 4;\n      if (this.pos > this.byteLength || this.pos > MAX_POS) {\n        this._invalid = true;\n        return <u32>0;\n      }\n\n      // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)\n      return (\n        u32(u8(this.u8at(this.pos - 4))) |\n        (u32(u8(this.u8at(this.pos - 3))) << 8) |\n        (u32(u8(this.u8at(this.pos - 2))) << 16) |\n        (u32(u8(this.u8at(this.pos - 1))) << 24)\n      );\n    }\n    bytes(): Array<u8> {\n      if (this.invalid()) return new Array<u8>(0);\n      const len = this.uint32();\n      if (this.pos + len > this.byteLength || this.pos + len > MAX_POS) {\n        this._invalid = true;\n        return new Array<u8>(0);\n      }\n      const a = new Array<u8>(len);\n      for (let i: u32 = 0; i < len; i++) {\n        a[i] = u8(this.u8at(this.pos++));\n      }\n\n      return a;\n    }\n    skipType(wireType: u32): void {\n      if (this.invalid()) return;\n      switch (wireType) {\n        // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length\n        case 0:\n          this.varint(); // Just read a varint\n          break;\n        // fixed64, sfixed64, double: 8 bytes always\n        case 1:\n          this.skip(8);\n          break;\n        // length-delimited; length is determined by varint32; skip length bytes;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        // tart group: skip till the end of the group, then skip group end marker\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        // fixed32, sfixed32, float: 4 bytes always\n        case 5:\n          this.skip(4);\n          break;\n\n        // Something went beyond our capability to understand\n        default:\n          this._invalid = true;\n          break;\n      }\n    }\n    skip(length: u32): void {\n      if (this.invalid()) return;\n      if (this.pos + length > this.byteLength || this.pos + length > MAX_POS) {\n        this._invalid = true;\n      }\n      this.pos += length;\n    }\n  }\n\n  /**\n   * Encoder implements protobuf message encode interface. This is the simplest not very effective version, which uses\n   * Array<u8>.\n   *\n   * Useful references:\n   *\n   * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding\n   * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128\n   * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba\n   */\n  export class Encoder {\n    public buf: Array<u8>;\n\n    constructor(buf: Array<u8>) {\n      this.buf = buf;\n    }\n\n    /**\n     * Encodes varint at a current position\n     * @returns Returns varint\n     */\n    varint64(value: u64): void {\n      let v: u64 = value;\n\n      while (v > 127) {\n        this.buf.push(u8((v & 127) | 128));\n        v = v >> 7;\n      }\n\n      this.buf.push(u8(v));\n    }\n\n    @inline\n    int32(value: i32): void {\n      this.varint64(value);\n    }\n\n    @inline\n    int64(value: i64): void {\n      this.varint64(value);\n    }\n\n    @inline\n    uint32(value: u32): void {\n      this.varint64(value);\n    }\n\n    @inline\n    uint64(value: u64): void {\n      this.varint64(value);\n    }\n\n    @inline\n    sint32(value: i32): void {\n      this.varint64((value << 1) ^ (value >> 31));\n    }\n\n    @inline\n    sint64(value: i64): void {\n      this.varint64((value << 1) ^ (value >> 63));\n    }\n\n    @inline\n    fixed32(value: u32): void {\n      this.buf.push(u8(value & 255));\n      this.buf.push(u8((value >> 8) & 255));\n      this.buf.push(u8((value >> 16) & 255));\n      this.buf.push(u8(value >> 24));\n    }\n\n    @inline\n    sfixed32(value: i32): void {\n      this.fixed32(u32(value));\n    }\n\n    @inline\n    fixed64(value: u64): void {\n      this.buf.push(u8(value & 255));\n      this.buf.push(u8((value >> 8) & 255));\n      this.buf.push(u8((value >> 16) & 255));\n      this.buf.push(u8((value >> 24) & 255));\n      this.buf.push(u8((value >> 32) & 255));\n      this.buf.push(u8((value >> 40) & 255));\n      this.buf.push(u8((value >> 48) & 255));\n      this.buf.push(u8(value >> 56));\n    }\n\n    @inline\n    sfixed64(value: i64): void {\n      this.fixed64(u64(value));\n    }\n\n    @inline\n    float(value: f32): void {\n      this.fixed32(u32(i32.reinterpret_f32(value)));\n    }\n\n    @inline\n    double(value: f64): void {\n      this.fixed64(u64(i64.reinterpret_f64(value)));\n    }\n\n    @inline\n    bool(value: boolean): void {\n      this.buf.push(value ? 1 : 0);\n    }\n\n    string(value: string): void {\n      const utf8string = new DataView(String.UTF8.encode(value));\n\n      for (let i = 0; i < utf8string.byteLength; i++) {\n        this.buf.push(utf8string.getUint8(i));\n      }\n    }\n\n    @inline\n    bytes(value: Array<u8>): void {\n      for (let i = 0; i < value.length; i++) {\n        this.buf.push(value[i]);\n      }\n    }\n  }\n\n  /**\n   * Returns byte size required to encode a value of a certain type\n   */\n  export class Sizer {\n    static varint64(value: u64): u32 {\n      return value < 128\n        ? 1 // 2^7\n        : value < 16384\n        ? 2 // 2^14\n        : value < 2097152\n        ? 3 // 2^21\n        : value < 268435456\n        ? 4 // 2^28\n        : value < 34359738368\n        ? 5 // 2^35\n        : value < 4398046511104\n        ? 6 // 2^42\n        : value < 562949953421312\n        ? 7 // 2^49\n        : value < 72057594037927936\n        ? 8 // 2^56\n        : value < 9223372036854775808\n        ? 9 // 2^63\n        : 10;\n    }\n\n    @inline\n    static int32(value: i32): u32 {\n      return Sizer.varint64(u64(value));\n    }\n\n    @inline\n    static int64(value: i64): u32 {\n      return Sizer.varint64(u64(value));\n    }\n\n    @inline\n    static uint32(value: u32): u32 {\n      return Sizer.varint64(value);\n    }\n\n    @inline\n    static uint64(value: u64): u32 {\n      return Sizer.varint64(value);\n    }\n\n    @inline\n    static sint32(value: i32): u32 {\n      return Sizer.varint64((value << 1) ^ (value >> 31));\n    }\n\n    @inline\n    static sint64(value: i64): u32 {\n      return Sizer.varint64((value << 1) ^ (value >> 63));\n    }\n\n    @inline\n    static string(value: string): u32 {\n      return value.length;\n    }\n\n    @inline\n    static bytes(value: Array<u8>): u32 {\n      return value.length;\n    }\n  }\n}\nexport namespace protorune {\n  export class RuneId {\n    public height: u32;\n    public txindex: u32;\n\n    // Decodes RuneId from an ArrayBuffer\n    static decode(buf: ArrayBuffer): RuneId {\n      return RuneId.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes RuneId from a DataView\n    static decodeDataView(view: DataView): RuneId {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new RuneId();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.height = decoder.uint32();\n            break;\n          }\n          case 2: {\n            obj.txindex = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<RuneId>(0);\n      return obj;\n    } // decode RuneId\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size += this.height == 0 ? 0 : 1 + __proto.Sizer.uint32(this.height);\n      size += this.txindex == 0 ? 0 : 1 + __proto.Sizer.uint32(this.txindex);\n\n      return size;\n    }\n\n    // Encodes RuneId to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes RuneId to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.height != 0) {\n        encoder.uint32(0x8);\n        encoder.uint32(this.height);\n      }\n      if (this.txindex != 0) {\n        encoder.uint32(0x10);\n        encoder.uint32(this.txindex);\n      }\n\n      return buf;\n    } // encode RuneId\n  } // RuneId\n\n  export class Rune {\n    public runeId: RuneId = new RuneId();\n    public name: Array<u8> = new Array<u8>();\n    public divisibility: u32;\n    public spacers: u32;\n    public symbol: u32;\n\n    // Decodes Rune from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Rune {\n      return Rune.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Rune from a DataView\n    static decodeDataView(view: DataView): Rune {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Rune();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.runeId = RuneId.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 2: {\n            obj.name = decoder.bytes();\n            break;\n          }\n          case 3: {\n            obj.divisibility = decoder.uint32();\n            break;\n          }\n          case 4: {\n            obj.spacers = decoder.uint32();\n            break;\n          }\n          case 5: {\n            obj.symbol = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Rune>(0);\n      return obj;\n    } // decode Rune\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      if (this.runeId != null) {\n        const f: RuneId = this.runeId as RuneId;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      size +=\n        this.name.length > 0\n          ? 1 + __proto.Sizer.varint64(this.name.length) + this.name.length\n          : 0;\n      size +=\n        this.divisibility == 0\n          ? 0\n          : 1 + __proto.Sizer.uint32(this.divisibility);\n      size += this.spacers == 0 ? 0 : 1 + __proto.Sizer.uint32(this.spacers);\n      size += this.symbol == 0 ? 0 : 1 + __proto.Sizer.uint32(this.symbol);\n\n      return size;\n    }\n\n    // Encodes Rune to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Rune to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.runeId != null) {\n        const f = this.runeId as RuneId;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.name.length > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.name.length);\n        encoder.bytes(this.name);\n      }\n      if (this.divisibility != 0) {\n        encoder.uint32(0x18);\n        encoder.uint32(this.divisibility);\n      }\n      if (this.spacers != 0) {\n        encoder.uint32(0x20);\n        encoder.uint32(this.spacers);\n      }\n      if (this.symbol != 0) {\n        encoder.uint32(0x28);\n        encoder.uint32(this.symbol);\n      }\n\n      return buf;\n    } // encode Rune\n  } // Rune\n\n  export class BalanceSheetItem {\n    public rune: Rune = new Rune();\n    public balance: Array<u8> = new Array<u8>();\n\n    // Decodes BalanceSheetItem from an ArrayBuffer\n    static decode(buf: ArrayBuffer): BalanceSheetItem {\n      return BalanceSheetItem.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes BalanceSheetItem from a DataView\n    static decodeDataView(view: DataView): BalanceSheetItem {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new BalanceSheetItem();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.rune = Rune.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 2: {\n            obj.balance = decoder.bytes();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<BalanceSheetItem>(0);\n      return obj;\n    } // decode BalanceSheetItem\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      if (this.rune != null) {\n        const f: Rune = this.rune as Rune;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      size +=\n        this.balance.length > 0\n          ? 1 +\n            __proto.Sizer.varint64(this.balance.length) +\n            this.balance.length\n          : 0;\n\n      return size;\n    }\n\n    // Encodes BalanceSheetItem to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes BalanceSheetItem to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.rune != null) {\n        const f = this.rune as Rune;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.balance.length > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.balance.length);\n        encoder.bytes(this.balance);\n      }\n\n      return buf;\n    } // encode BalanceSheetItem\n  } // BalanceSheetItem\n\n  export class BalanceSheet {\n    public entries: Array<BalanceSheetItem> = new Array<BalanceSheetItem>();\n\n    // Decodes BalanceSheet from an ArrayBuffer\n    static decode(buf: ArrayBuffer): BalanceSheet {\n      return BalanceSheet.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes BalanceSheet from a DataView\n    static decodeDataView(view: DataView): BalanceSheet {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new BalanceSheet();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.entries.push(\n              BalanceSheetItem.decodeDataView(\n                new DataView(\n                  decoder.view.buffer,\n                  decoder.pos + decoder.view.byteOffset,\n                  length\n                )\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<BalanceSheet>(0);\n      return obj;\n    } // decode BalanceSheet\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      for (let n: i32 = 0; n < this.entries.length; n++) {\n        const messageSize = this.entries[n].size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes BalanceSheet to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes BalanceSheet to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      for (let n: i32 = 0; n < this.entries.length; n++) {\n        const messageSize = this.entries[n].size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          this.entries[n].encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode BalanceSheet\n  } // BalanceSheet\n\n  export class Outpoint {\n    public txid: Array<u8> = new Array<u8>();\n    public vout: u32;\n\n    // Decodes Outpoint from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Outpoint {\n      return Outpoint.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Outpoint from a DataView\n    static decodeDataView(view: DataView): Outpoint {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Outpoint();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.txid = decoder.bytes();\n            break;\n          }\n          case 2: {\n            obj.vout = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Outpoint>(0);\n      return obj;\n    } // decode Outpoint\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.txid.length > 0\n          ? 1 + __proto.Sizer.varint64(this.txid.length) + this.txid.length\n          : 0;\n      size += this.vout == 0 ? 0 : 1 + __proto.Sizer.uint32(this.vout);\n\n      return size;\n    }\n\n    // Encodes Outpoint to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Outpoint to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.txid.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.txid.length);\n        encoder.bytes(this.txid);\n      }\n      if (this.vout != 0) {\n        encoder.uint32(0x10);\n        encoder.uint32(this.vout);\n      }\n\n      return buf;\n    } // encode Outpoint\n  } // Outpoint\n\n  export class OutpointWithProtocol {\n    public txid: Array<u8> = new Array<u8>();\n    public vout: u32;\n    public protocol: Array<u8> = new Array<u8>();\n\n    // Decodes OutpointWithProtocol from an ArrayBuffer\n    static decode(buf: ArrayBuffer): OutpointWithProtocol {\n      return OutpointWithProtocol.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes OutpointWithProtocol from a DataView\n    static decodeDataView(view: DataView): OutpointWithProtocol {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new OutpointWithProtocol();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.txid = decoder.bytes();\n            break;\n          }\n          case 2: {\n            obj.vout = decoder.uint32();\n            break;\n          }\n          case 3: {\n            obj.protocol = decoder.bytes();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<OutpointWithProtocol>(0);\n      return obj;\n    } // decode OutpointWithProtocol\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.txid.length > 0\n          ? 1 + __proto.Sizer.varint64(this.txid.length) + this.txid.length\n          : 0;\n      size += this.vout == 0 ? 0 : 1 + __proto.Sizer.uint32(this.vout);\n      size +=\n        this.protocol.length > 0\n          ? 1 +\n            __proto.Sizer.varint64(this.protocol.length) +\n            this.protocol.length\n          : 0;\n\n      return size;\n    }\n\n    // Encodes OutpointWithProtocol to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes OutpointWithProtocol to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.txid.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.txid.length);\n        encoder.bytes(this.txid);\n      }\n      if (this.vout != 0) {\n        encoder.uint32(0x10);\n        encoder.uint32(this.vout);\n      }\n      if (this.protocol.length > 0) {\n        encoder.uint32(0x1a);\n        encoder.uint32(this.protocol.length);\n        encoder.bytes(this.protocol);\n      }\n\n      return buf;\n    } // encode OutpointWithProtocol\n  } // OutpointWithProtocol\n\n  export class Output {\n    public script: Array<u8> = new Array<u8>();\n    public value: u64;\n\n    // Decodes Output from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Output {\n      return Output.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Output from a DataView\n    static decodeDataView(view: DataView): Output {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Output();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.script = decoder.bytes();\n            break;\n          }\n          case 2: {\n            obj.value = decoder.uint64();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Output>(0);\n      return obj;\n    } // decode Output\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.script.length > 0\n          ? 1 + __proto.Sizer.varint64(this.script.length) + this.script.length\n          : 0;\n      size += this.value == 0 ? 0 : 1 + __proto.Sizer.uint64(this.value);\n\n      return size;\n    }\n\n    // Encodes Output to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Output to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.script.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.script.length);\n        encoder.bytes(this.script);\n      }\n      if (this.value != 0) {\n        encoder.uint32(0x10);\n        encoder.uint64(this.value);\n      }\n\n      return buf;\n    } // encode Output\n  } // Output\n\n  export class OutpointResponse {\n    public balances: BalanceSheet = new BalanceSheet();\n    public outpoint: Outpoint = new Outpoint();\n    public output: Output = new Output();\n    public height: u32;\n    public txindex: u32;\n\n    // Decodes OutpointResponse from an ArrayBuffer\n    static decode(buf: ArrayBuffer): OutpointResponse {\n      return OutpointResponse.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes OutpointResponse from a DataView\n    static decodeDataView(view: DataView): OutpointResponse {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new OutpointResponse();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.balances = BalanceSheet.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 2: {\n            const length = decoder.uint32();\n            obj.outpoint = Outpoint.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 3: {\n            const length = decoder.uint32();\n            obj.output = Output.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 4: {\n            obj.height = decoder.uint32();\n            break;\n          }\n          case 5: {\n            obj.txindex = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<OutpointResponse>(0);\n      return obj;\n    } // decode OutpointResponse\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      if (this.balances != null) {\n        const f: BalanceSheet = this.balances as BalanceSheet;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      if (this.outpoint != null) {\n        const f: Outpoint = this.outpoint as Outpoint;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      if (this.output != null) {\n        const f: Output = this.output as Output;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      size += this.height == 0 ? 0 : 1 + __proto.Sizer.uint32(this.height);\n      size += this.txindex == 0 ? 0 : 1 + __proto.Sizer.uint32(this.txindex);\n\n      return size;\n    }\n\n    // Encodes OutpointResponse to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes OutpointResponse to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.balances != null) {\n        const f = this.balances as BalanceSheet;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.outpoint != null) {\n        const f = this.outpoint as Outpoint;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0x12);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.output != null) {\n        const f = this.output as Output;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0x1a);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.height != 0) {\n        encoder.uint32(0x20);\n        encoder.uint32(this.height);\n      }\n      if (this.txindex != 0) {\n        encoder.uint32(0x28);\n        encoder.uint32(this.txindex);\n      }\n\n      return buf;\n    } // encode OutpointResponse\n  } // OutpointResponse\n\n  export class PaginationInput {\n    public start: u32;\n    public end: u32;\n\n    // Decodes PaginationInput from an ArrayBuffer\n    static decode(buf: ArrayBuffer): PaginationInput {\n      return PaginationInput.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes PaginationInput from a DataView\n    static decodeDataView(view: DataView): PaginationInput {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new PaginationInput();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.start = decoder.uint32();\n            break;\n          }\n          case 2: {\n            obj.end = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<PaginationInput>(0);\n      return obj;\n    } // decode PaginationInput\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size += this.start == 0 ? 0 : 1 + __proto.Sizer.uint32(this.start);\n      size += this.end == 0 ? 0 : 1 + __proto.Sizer.uint32(this.end);\n\n      return size;\n    }\n\n    // Encodes PaginationInput to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes PaginationInput to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.start != 0) {\n        encoder.uint32(0x8);\n        encoder.uint32(this.start);\n      }\n      if (this.end != 0) {\n        encoder.uint32(0x10);\n        encoder.uint32(this.end);\n      }\n\n      return buf;\n    } // encode PaginationInput\n  } // PaginationInput\n\n  export class WalletRequest {\n    public wallet: Array<u8> = new Array<u8>();\n\n    // Decodes WalletRequest from an ArrayBuffer\n    static decode(buf: ArrayBuffer): WalletRequest {\n      return WalletRequest.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes WalletRequest from a DataView\n    static decodeDataView(view: DataView): WalletRequest {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new WalletRequest();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.wallet = decoder.bytes();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<WalletRequest>(0);\n      return obj;\n    } // decode WalletRequest\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.wallet.length > 0\n          ? 1 + __proto.Sizer.varint64(this.wallet.length) + this.wallet.length\n          : 0;\n\n      return size;\n    }\n\n    // Encodes WalletRequest to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes WalletRequest to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.wallet.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.wallet.length);\n        encoder.bytes(this.wallet);\n      }\n\n      return buf;\n    } // encode WalletRequest\n  } // WalletRequest\n\n  export class WalletResponse {\n    public outpoints: Array<OutpointResponse> = new Array<OutpointResponse>();\n    public balances: BalanceSheet = new BalanceSheet();\n\n    // Decodes WalletResponse from an ArrayBuffer\n    static decode(buf: ArrayBuffer): WalletResponse {\n      return WalletResponse.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes WalletResponse from a DataView\n    static decodeDataView(view: DataView): WalletResponse {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new WalletResponse();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.outpoints.push(\n              OutpointResponse.decodeDataView(\n                new DataView(\n                  decoder.view.buffer,\n                  decoder.pos + decoder.view.byteOffset,\n                  length\n                )\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 2: {\n            const length = decoder.uint32();\n            obj.balances = BalanceSheet.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<WalletResponse>(0);\n      return obj;\n    } // decode WalletResponse\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      for (let n: i32 = 0; n < this.outpoints.length; n++) {\n        const messageSize = this.outpoints[n].size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      if (this.balances != null) {\n        const f: BalanceSheet = this.balances as BalanceSheet;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes WalletResponse to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes WalletResponse to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      for (let n: i32 = 0; n < this.outpoints.length; n++) {\n        const messageSize = this.outpoints[n].size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          this.outpoints[n].encodeU8Array(encoder);\n        }\n      }\n\n      if (this.balances != null) {\n        const f = this.balances as BalanceSheet;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0x12);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode WalletResponse\n  } // WalletResponse\n\n  export class ProtorunesWalletRequest {\n    public wallet: Array<u8> = new Array<u8>();\n    public protocol_tag: Array<u8> = new Array<u8>();\n\n    // Decodes ProtorunesWalletRequest from an ArrayBuffer\n    static decode(buf: ArrayBuffer): ProtorunesWalletRequest {\n      return ProtorunesWalletRequest.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes ProtorunesWalletRequest from a DataView\n    static decodeDataView(view: DataView): ProtorunesWalletRequest {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new ProtorunesWalletRequest();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.wallet = decoder.bytes();\n            break;\n          }\n          case 2: {\n            obj.protocol_tag = decoder.bytes();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<ProtorunesWalletRequest>(0);\n      return obj;\n    } // decode ProtorunesWalletRequest\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.wallet.length > 0\n          ? 1 + __proto.Sizer.varint64(this.wallet.length) + this.wallet.length\n          : 0;\n      size +=\n        this.protocol_tag.length > 0\n          ? 1 +\n            __proto.Sizer.varint64(this.protocol_tag.length) +\n            this.protocol_tag.length\n          : 0;\n\n      return size;\n    }\n\n    // Encodes ProtorunesWalletRequest to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes ProtorunesWalletRequest to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.wallet.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.wallet.length);\n        encoder.bytes(this.wallet);\n      }\n      if (this.protocol_tag.length > 0) {\n        encoder.uint32(0x12);\n        encoder.uint32(this.protocol_tag.length);\n        encoder.bytes(this.protocol_tag);\n      }\n\n      return buf;\n    } // encode ProtorunesWalletRequest\n  } // ProtorunesWalletRequest\n\n  export class RunesResponse {\n    public runes: Array<Rune> = new Array<Rune>();\n\n    // Decodes RunesResponse from an ArrayBuffer\n    static decode(buf: ArrayBuffer): RunesResponse {\n      return RunesResponse.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes RunesResponse from a DataView\n    static decodeDataView(view: DataView): RunesResponse {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new RunesResponse();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.runes.push(\n              Rune.decodeDataView(\n                new DataView(\n                  decoder.view.buffer,\n                  decoder.pos + decoder.view.byteOffset,\n                  length\n                )\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<RunesResponse>(0);\n      return obj;\n    } // decode RunesResponse\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      for (let n: i32 = 0; n < this.runes.length; n++) {\n        const messageSize = this.runes[n].size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes RunesResponse to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes RunesResponse to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      for (let n: i32 = 0; n < this.runes.length; n++) {\n        const messageSize = this.runes[n].size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          this.runes[n].encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode RunesResponse\n  } // RunesResponse\n\n  export class ProtoBurn {\n    public protocol_tag: Array<u8> = new Array<u8>();\n    public pointer: u32;\n\n    // Decodes ProtoBurn from an ArrayBuffer\n    static decode(buf: ArrayBuffer): ProtoBurn {\n      return ProtoBurn.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes ProtoBurn from a DataView\n    static decodeDataView(view: DataView): ProtoBurn {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new ProtoBurn();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.protocol_tag = decoder.bytes();\n            break;\n          }\n          case 2: {\n            obj.pointer = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<ProtoBurn>(0);\n      return obj;\n    } // decode ProtoBurn\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.protocol_tag.length > 0\n          ? 1 +\n            __proto.Sizer.varint64(this.protocol_tag.length) +\n            this.protocol_tag.length\n          : 0;\n      size += this.pointer == 0 ? 0 : 1 + __proto.Sizer.uint32(this.pointer);\n\n      return size;\n    }\n\n    // Encodes ProtoBurn to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes ProtoBurn to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.protocol_tag.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.protocol_tag.length);\n        encoder.bytes(this.protocol_tag);\n      }\n      if (this.pointer != 0) {\n        encoder.uint32(0x10);\n        encoder.uint32(this.pointer);\n      }\n\n      return buf;\n    } // encode ProtoBurn\n  } // ProtoBurn\n\n  export class uint128 {\n    public lo: u64;\n    public hi: u64;\n\n    // Decodes uint128 from an ArrayBuffer\n    static decode(buf: ArrayBuffer): uint128 {\n      return uint128.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes uint128 from a DataView\n    static decodeDataView(view: DataView): uint128 {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new uint128();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.lo = decoder.uint64();\n            break;\n          }\n          case 2: {\n            obj.hi = decoder.uint64();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<uint128>(0);\n      return obj;\n    } // decode uint128\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size += this.lo == 0 ? 0 : 1 + __proto.Sizer.uint64(this.lo);\n      size += this.hi == 0 ? 0 : 1 + __proto.Sizer.uint64(this.hi);\n\n      return size;\n    }\n\n    // Encodes uint128 to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes uint128 to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.lo != 0) {\n        encoder.uint32(0x8);\n        encoder.uint64(this.lo);\n      }\n      if (this.hi != 0) {\n        encoder.uint32(0x10);\n        encoder.uint64(this.hi);\n      }\n\n      return buf;\n    } // encode uint128\n  } // uint128\n\n  export class Clause {\n    public rune: RuneId = new RuneId();\n    public amount: uint128 = new uint128();\n\n    // Decodes Clause from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Clause {\n      return Clause.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Clause from a DataView\n    static decodeDataView(view: DataView): Clause {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Clause();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.rune = RuneId.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 2: {\n            const length = decoder.uint32();\n            obj.amount = uint128.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Clause>(0);\n      return obj;\n    } // decode Clause\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      if (this.rune != null) {\n        const f: RuneId = this.rune as RuneId;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      if (this.amount != null) {\n        const f: uint128 = this.amount as uint128;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes Clause to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Clause to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.rune != null) {\n        const f = this.rune as RuneId;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.amount != null) {\n        const f = this.amount as uint128;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0x12);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode Clause\n  } // Clause\n\n  export class Predicate {\n    public clauses: Array<Clause> = new Array<Clause>();\n\n    // Decodes Predicate from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Predicate {\n      return Predicate.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Predicate from a DataView\n    static decodeDataView(view: DataView): Predicate {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Predicate();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.clauses.push(\n              Clause.decodeDataView(\n                new DataView(\n                  decoder.view.buffer,\n                  decoder.pos + decoder.view.byteOffset,\n                  length\n                )\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Predicate>(0);\n      return obj;\n    } // decode Predicate\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      for (let n: i32 = 0; n < this.clauses.length; n++) {\n        const messageSize = this.clauses[n].size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes Predicate to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Predicate to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      for (let n: i32 = 0; n < this.clauses.length; n++) {\n        const messageSize = this.clauses[n].size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          this.clauses[n].encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode Predicate\n  } // Predicate\n\n  export class ProtoMessage {\n    public calldata: Array<u8> = new Array<u8>();\n    public predicate: Predicate = new Predicate();\n    public pointer: u32;\n    public refund_pointer: u32;\n\n    // Decodes ProtoMessage from an ArrayBuffer\n    static decode(buf: ArrayBuffer): ProtoMessage {\n      return ProtoMessage.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes ProtoMessage from a DataView\n    static decodeDataView(view: DataView): ProtoMessage {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new ProtoMessage();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.calldata = decoder.bytes();\n            break;\n          }\n          case 2: {\n            const length = decoder.uint32();\n            obj.predicate = Predicate.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n          case 3: {\n            obj.pointer = decoder.uint32();\n            break;\n          }\n          case 4: {\n            obj.refund_pointer = decoder.uint32();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<ProtoMessage>(0);\n      return obj;\n    } // decode ProtoMessage\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.calldata.length > 0\n          ? 1 +\n            __proto.Sizer.varint64(this.calldata.length) +\n            this.calldata.length\n          : 0;\n\n      if (this.predicate != null) {\n        const f: Predicate = this.predicate as Predicate;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      size += this.pointer == 0 ? 0 : 1 + __proto.Sizer.uint32(this.pointer);\n      size +=\n        this.refund_pointer == 0\n          ? 0\n          : 1 + __proto.Sizer.uint32(this.refund_pointer);\n\n      return size;\n    }\n\n    // Encodes ProtoMessage to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes ProtoMessage to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.calldata.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.calldata.length);\n        encoder.bytes(this.calldata);\n      }\n\n      if (this.predicate != null) {\n        const f = this.predicate as Predicate;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0x12);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      if (this.pointer != 0) {\n        encoder.uint32(0x18);\n        encoder.uint32(this.pointer);\n      }\n      if (this.refund_pointer != 0) {\n        encoder.uint32(0x20);\n        encoder.uint32(this.refund_pointer);\n      }\n\n      return buf;\n    } // encode ProtoMessage\n  } // ProtoMessage\n\n  export class RuntimeInput {\n    public protocol_tag: Array<u8> = new Array<u8>();\n\n    // Decodes RuntimeInput from an ArrayBuffer\n    static decode(buf: ArrayBuffer): RuntimeInput {\n      return RuntimeInput.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes RuntimeInput from a DataView\n    static decodeDataView(view: DataView): RuntimeInput {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new RuntimeInput();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.protocol_tag = decoder.bytes();\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<RuntimeInput>(0);\n      return obj;\n    } // decode RuntimeInput\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size +=\n        this.protocol_tag.length > 0\n          ? 1 +\n            __proto.Sizer.varint64(this.protocol_tag.length) +\n            this.protocol_tag.length\n          : 0;\n\n      return size;\n    }\n\n    // Encodes RuntimeInput to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes RuntimeInput to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.protocol_tag.length > 0) {\n        encoder.uint32(0xa);\n        encoder.uint32(this.protocol_tag.length);\n        encoder.bytes(this.protocol_tag);\n      }\n\n      return buf;\n    } // encode RuntimeInput\n  } // RuntimeInput\n\n  export class Runtime {\n    public balances: BalanceSheet = new BalanceSheet();\n\n    // Decodes Runtime from an ArrayBuffer\n    static decode(buf: ArrayBuffer): Runtime {\n      return Runtime.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes Runtime from a DataView\n    static decodeDataView(view: DataView): Runtime {\n      const decoder = new __proto.SafeDecoder(view);\n      const obj = new Runtime();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            const length = decoder.uint32();\n            obj.balances = BalanceSheet.decodeDataView(\n              new DataView(\n                decoder.view.buffer,\n                decoder.pos + decoder.view.byteOffset,\n                length\n              )\n            );\n            decoder.skip(length);\n\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      if (decoder.invalid()) return changetype<Runtime>(0);\n      return obj;\n    } // decode Runtime\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      if (this.balances != null) {\n        const f: BalanceSheet = this.balances as BalanceSheet;\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          size += 1 + __proto.Sizer.varint64(messageSize) + messageSize;\n        }\n      }\n\n      return size;\n    }\n\n    // Encodes Runtime to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes Runtime to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.balances != null) {\n        const f = this.balances as BalanceSheet;\n\n        const messageSize = f.size();\n\n        if (messageSize > 0) {\n          encoder.uint32(0xa);\n          encoder.uint32(messageSize);\n          f.encodeU8Array(encoder);\n        }\n      }\n\n      return buf;\n    } // encode Runtime\n  } // Runtime\n} // protorune\n","import { Box } from \"metashrew-as/assembly/utils/box\";\nimport { _flush, input } from \"metashrew-as/assembly/indexer/index\";\nimport { Block } from \"metashrew-as/assembly/blockdata/block\";\nimport { parsePrimitive } from \"metashrew-as/assembly/utils/utils\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { ProtoruneRuneId } from \"./indexer/ProtoruneRuneId\";\nimport { DefaultProtorune, Protorune } from \"./indexer\";\nimport { MessageContext } from \"./indexer/protomessage\";\nimport { GENESIS } from \"metashrew-runes/assembly/indexer/constants\";\nimport { IncomingRune } from \"./indexer/protomessage/IncomingRune\";\nimport { SpendablesIndex } from \"metashrew-spendables/assembly/indexer\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\nimport { IndexPointer } from \"metashrew-as/assembly/indexer/tables\";\n\nexport const TEST_PROTORUNE_RUNEID = IndexPointer.for(\n  \"/test/protorune/runeid/\",\n);\n\nclass DepositAllContext extends MessageContext {\n  handle(): bool {\n    this.runes.map<IncomingRune>((rune) => {\n      rune.depositAll();\n      return rune;\n    });\n    return true;\n  }\n}\n\nclass ForwardAllContext extends MessageContext {\n  handle(): bool {\n    this.runes.map<IncomingRune>((rune) => {\n      rune.forwardAll();\n      return rune;\n    });\n    return true;\n  }\n}\n\n// forwards half of each rune, deposits 1/4, refunds 1/4\nclass SimpleMessageContext extends MessageContext {\n  handle(): bool {\n    this.runes.map<IncomingRune>((rune) => {\n      const initAmount = rune.amount;\n      rune.forward(u128.div(initAmount, u128.from(2)));\n      rune.deposit(u128.div(initAmount, u128.from(4)));\n      // no action for the rest, by default should be refunded\n      return rune;\n    });\n    return true;\n  }\n}\n\n// tests refunding existing deposts and forwards\nclass RefundMessageContext extends MessageContext {\n  handle(): bool {\n    this.runes.map<IncomingRune>((rune) => {\n      const initAmount = rune.amount;\n      rune.forward(u128.div(initAmount, u128.from(2)));\n      rune.deposit(u128.div(initAmount, u128.from(4)));\n      rune.refund(u128.div(initAmount, u128.from(8)));\n      rune.refund(u128.div(initAmount, u128.from(4)));\n      rune.refundDeposit(u128.div(initAmount, u128.from(8)));\n      return rune;\n    });\n    return true;\n  }\n}\n\nclass DepositAllProtorune extends Protorune<DepositAllContext> {}\nclass ForwardAllProtorune extends Protorune<ForwardAllContext> {}\nclass SimpleProtorune extends Protorune<SimpleMessageContext> {}\nclass RefundProtorune extends Protorune<RefundMessageContext> {}\n\nfunction _test_ProtoruneRuneId(runeId: ProtoruneRuneId): void {\n  console.log(runeId.block.toString());\n  console.log(runeId.tx.toString());\n  TEST_PROTORUNE_RUNEID.select(String.UTF8.encode(\"block\")).set(\n    runeId.block.toUint8Array().buffer,\n  );\n  TEST_PROTORUNE_RUNEID.select(String.UTF8.encode(\"tx\")).set(\n    runeId.tx.toUint8Array().buffer,\n  );\n  const decoded = runeId.decode();\n  for (let i = 0; i < decoded.length; i++) {\n    console.log(\"decoded[\" + i.toString() + \"]: \" + decoded[i].toString());\n    TEST_PROTORUNE_RUNEID.select(String.UTF8.encode(\"decoded/\"))\n      .select(String.UTF8.encode(i.toString()))\n      .set(decoded[i].toUint8Array().buffer);\n  }\n  _flush();\n}\n\nexport function test_ProtoruneRuneId1(): void {\n  const runeId = ProtoruneRuneId.encode([u128.from(50), u128.from(100)]);\n  _test_ProtoruneRuneId(runeId);\n}\n\nexport function test_ProtoruneRuneId2(): void {\n  const runeId = ProtoruneRuneId.encode([\n    u128.from(50000000),\n    u128.from(1000000000),\n  ]);\n  _test_ProtoruneRuneId(runeId);\n}\n\nexport function test_ProtoruneRuneId3(): void {\n  const runeId = ProtoruneRuneId.encode([\n    u128.from(50000000),\n    u128.from(1000000000),\n    u128.from(1500000000),\n  ]);\n  _test_ProtoruneRuneId(runeId);\n}\n\nexport function test_ProtoruneRuneId4(): void {\n  const runeId = ProtoruneRuneId.encode([\n    u128.from(50000000),\n    u128.from(1000000000),\n    u128.from(1500000000),\n    u128.from(2000000000),\n  ]);\n  _test_ProtoruneRuneId(runeId);\n}\n\nexport function test_ProtoruneRuneId5(): void {\n  const runeId = ProtoruneRuneId.encode([\n    u128.from(50000000),\n    u128.from(1000000000),\n    u128.from(1500000000),\n    u128.from(2000000000),\n    u128.from(50000000),\n    u128.from(1000000000),\n    u128.from(1500000000),\n    u128.from(2000000000),\n  ]);\n  _test_ProtoruneRuneId(runeId);\n}\n\nexport function testProtomessageDepositAll(): void {\n  const data = input();\n  const box = Box.from(data);\n  const height = parsePrimitive<u32>(box);\n  if (height < GENESIS - 6) {\n    _flush();\n    return;\n  }\n  const block = new Block(box);\n  if (height >= GENESIS) {\n    new SpendablesIndex().indexBlock(height, block);\n  }\n  new DepositAllProtorune().indexBlock(height, block);\n  _flush();\n}\n\nexport function testProtomessageForwardAll(): void {\n  const data = input();\n  const box = Box.from(data);\n  const height = parsePrimitive<u32>(box);\n  if (height < GENESIS - 6) {\n    _flush();\n    return;\n  }\n  const block = new Block(box);\n  if (height >= GENESIS) {\n    new SpendablesIndex().indexBlock(height, block);\n  }\n  new ForwardAllProtorune().indexBlock(height, block);\n  _flush();\n}\n\nexport function testSimpleProtorune(): void {\n  const data = input();\n  const box = Box.from(data);\n  const height = parsePrimitive<u32>(box);\n  if (height < GENESIS - 6) {\n    _flush();\n    return;\n  }\n  const block = new Block(box);\n  if (height >= GENESIS) {\n    new SpendablesIndex().indexBlock(height, block);\n  }\n  new SimpleProtorune().indexBlock(height, block);\n  _flush();\n}\nexport function testRefundProtorune(): void {\n  const data = input();\n  const box = Box.from(data);\n  const height = parsePrimitive<u32>(box);\n  if (height < GENESIS - 6) {\n    _flush();\n    return;\n  }\n  const block = new Block(box);\n  if (height >= GENESIS) {\n    new SpendablesIndex().indexBlock(height, block);\n  }\n  new RefundProtorune().indexBlock(height, block);\n  _flush();\n}\n\nexport function testEtching(): void {\n  const data = input();\n  const box = Box.from(data);\n  const height = parsePrimitive<u32>(box);\n  if (height < GENESIS - 6) {\n    _flush();\n    return;\n  }\n  const block = new Block(box);\n  if (height >= GENESIS) {\n    new SpendablesIndex().indexBlock(height, block);\n  }\n  const indexer = new DefaultProtorune(true, true);\n  indexer.indexBlock(height, block);\n  _flush();\n}\n","import { Box } from \"metashrew-as/assembly/utils/box\";\nimport { _flush, input } from \"metashrew-as/assembly/indexer/index\";\nimport { Block } from \"metashrew-as/assembly/blockdata/block\";\nimport { parsePrimitive } from \"metashrew-as/assembly/utils/utils\";\nimport { DefaultProtorune, Protorune } from \"./indexer\";\nimport { MessageContext } from \"./indexer/protomessage\";\nimport { GENESIS } from \"metashrew-runes/assembly/indexer/constants\";\nimport { SpendablesIndex } from \"metashrew-spendables/assembly/indexer\";\n\nexport function trap(): void {\n  unreachable();\n}\n\nexport function _start(): void {\n  const data = input();\n  const box = Box.from(data);\n  const height = parsePrimitive<u32>(box);\n  if (height < GENESIS - 6) {\n    _flush();\n    return;\n  }\n  const block = new Block(box);\n  if (height >= GENESIS) {\n    new SpendablesIndex().indexBlock(height, block);\n  }\n  new DefaultProtorune().indexBlock(height, block);\n  _flush();\n}\n\nexport * from \"./view\";\nexport * from \"./test\";\n","import { toPointer, Pointer, nullptr } from \"./pointer\";\nimport { memcpy } from \"./memcpy\";\nimport { encodeHex, encodeHexUTF8 } from \"./hex\";\n\nexport class Box {\n  public start: usize;\n  public len: usize;\n  constructor(start: usize, len: usize) {\n    this.start = start;\n    this.len = len;\n  }\n  toHexString(): string {\n    return encodeHex(this.start, this.len);\n  }\n  toHexUTF8(): ArrayBuffer {\n    return encodeHexUTF8(this.start, this.len);\n  }\n  static concat(data: Array<Box>): ArrayBuffer {\n    const result = new ArrayBuffer(\n      data.reduce<i32>((r: i32, v: Box, i: i32, ary: Array<Box>) => {\n        return r + <i32>v.len;\n      }, 0),\n    );\n    data.reduce<usize>((r: usize, v: Box, i: i32, ary: Array<Box>) => {\n      memcpy(r, v.start, v.len);\n      return r + v.len;\n    }, changetype<usize>(result));\n    return result;\n  }\n\n  shift(): Box {\n    if (this.len == 0) {\n      return nullptr<Box>();\n    }\n    this.start = this.start + 1;\n    this.len = this.len - 1;\n    return this;\n  }\n\n  sliceFrom(start: usize): Box {\n    return new Box(this.start + start, this.len - start);\n  }\n\n  sliceTo(ptr: usize): Box {\n    if (ptr > this.start + this.len) {\n      throw new Error(\"ptr is out of bounds\");\n    }\n    return new Box(this.start, ptr - this.start);\n  }\n  shrinkFront(distance: usize): Box {\n    this.start = this.start + distance;\n    this.len = this.len - distance;\n    return this;\n  }\n  growFront(distance: usize): Box {\n    this.start = this.start - distance;\n    this.len = this.len + distance;\n    return this;\n  }\n  shrinkBack(distance: usize): Box {\n    this.len = this.len - distance;\n    return this;\n  }\n  growBack(distance: usize): Box {\n    this.len = this.len + distance;\n    return this;\n  }\n  setLength(len: usize): Box {\n    this.len = len;\n    return this;\n  }\n  toArrayBuffer(): ArrayBuffer {\n    const result = new ArrayBuffer(<i32>this.len);\n    memcpy(changetype<usize>(result), this.start, this.len);\n    return result;\n  }\n  isEmpty(): boolean {\n    return this.len == 0;\n  }\n  static from(data: ArrayBuffer): Box {\n    return new Box(changetype<usize>(data), data.byteLength);\n  }\n  static copy(data: ArrayBuffer): Box {\n    const ptr = heap.alloc(data.byteLength);\n    memcpy(ptr, changetype<usize>(data), <usize>data.byteLength);\n    return new Box(ptr, <usize>data.byteLength);\n  }\n  static freeCopy(v: Box): void {\n    heap.free(v.start);\n  }\n  static fromTyped<T>(v: T): Box {\n    // const buffer = new ArrayBuffer(sizeof<T>(v));\n    const buffer = new ArrayBuffer(offsetof<T>());\n    store<T>(changetype<usize>(buffer), v);\n    return Box.copy(buffer);\n  }\n}\nexport class RCBox extends Box {\n  public buffer: ArrayBuffer;\n  constructor(v: ArrayBuffer) {\n    super(changetype<usize>(v), <usize>v.byteLength);\n    this.buffer = v;\n  }\n  static from(v: ArrayBuffer): RCBox {\n    return new RCBox(v);\n  }\n  static fromTyped<T>(v: T): RCBox {\n    // const buffer = new ArrayBuffer(sizeof<T>(v));\n    const buffer = new ArrayBuffer(offsetof<T>());\n    store<T>(changetype<usize>(buffer), v);\n    return RCBox.from(buffer);\n  }\n}\n","import { Box } from \"./box\";\nimport { toPointer, nullptr, Pointer } from \"./pointer\";\nimport { memcpy } from \"./memcpy\";\nimport { console } from \"./logging\";\nimport { u128 } from \"as-bignum/assembly\";\n\nexport function padLeft(v: string, n: i32): string {\n  let result = \"\";\n  for (let i: i32 = 0; i < n - v.length; i++) {\n    result += \"0\";\n  }\n  return result + v;\n}\n\nexport function u128ToHex(v: u128): string {\n  return padLeft(v.hi.toString(16), 16) + padLeft(v.lo.toString(16), 16);\n}\nexport function reverse(data: ArrayBuffer): ArrayBuffer {\n  const result = new ArrayBuffer(data.byteLength);\n  for (let i: i32 = 0; i < result.byteLength; i++) {\n    store<u8>(\n      changetype<usize>(result) + i,\n      load<u8>(changetype<usize>(data) + result.byteLength - i - 1),\n    );\n  }\n  return result;\n}\n\nexport function concat(data: Array<ArrayBuffer>): ArrayBuffer {\n  return Box.concat(\n    data.map<Box>((v: ArrayBuffer, i: i32, ary: Array<ArrayBuffer>) => {\n      return Box.from(v);\n    }),\n  );\n}\n\nexport function primitiveToBuffer<T>(value: T): ArrayBuffer {\n  const buffer = new ArrayBuffer(sizeof<T>());\n  store<T>(changetype<usize>(buffer), value);\n  return buffer;\n}\n\nexport function parsePrimitive<T>(data: Box): T {\n  const result = load<T>(data.start);\n  data.shrinkFront(sizeof<T>());\n  return result;\n}\n\nexport function parseBytes(data: Box, sz: usize): Box {\n  const result = data.sliceFrom(0);\n  result.len = sz;\n  data.shrinkFront(sz);\n  return result;\n}\n\nexport function parseScriptForLength(data: Box): i32 {\n  let length: i32 = 1;\n  const opcode = parsePrimitive<u8>(data);\n  if (opcode == 0x4d) {\n    let sz = <usize>parsePrimitive<u16>(data);\n    parseBytes(data, sz);\n    length += <i32>sz + 2;\n    return length;\n  }\n  if (opcode == 0x4e) {\n    let sz = <usize>parsePrimitive<u32>(data);\n    parseBytes(data, sz);\n    length += <i32>sz + 4;\n    return length;\n  }\n  if (opcode == 0x4f) {\n    toPointer(<usize>0).toBox(<usize>0);\n    return length;\n  }\n  if (opcode == 0x51) {\n    toPointer(<usize>0).toBox(<usize>0); // return a pointer value 0 for -1\n    return length;\n  }\n  if (opcode >= 0x52 && opcode <= 0x60) {\n    toPointer(<usize>0).toBox(<usize>opcode - <usize>0x50);\n    return length;\n  }\n  if (opcode >= 0x01 && opcode <= 0x4b) {\n    parseBytes(data, <usize>opcode);\n    length += <i32>opcode;\n    return length;\n  }\n  if (opcode == 0) {\n    data.sliceFrom(0).setLength(0);\n    return length;\n  }\n  return length;\n}\n\nexport function parsePushOp(data: Box): Box {\n  if (data.len == 0) return data\n  const opcode = parsePrimitive<u8>(data);\n// console.log(\"opcode \" + opcode.toString()\n  if (opcode == 0x4c) {\n    return parseBytes(data, <usize>parsePrimitive<u8>(data));\n  }\n  if (opcode == 0x4d) {\n    return parseBytes(data, <usize>parsePrimitive<u16>(data));\n  }\n  if (opcode == 0x4e) {\n    return parseBytes(data, <usize>parsePrimitive<u32>(data));\n  }\n  if (opcode == 0x4f) {\n    return toPointer(<usize>0).toBox(<usize>0);\n  }\n  if (opcode == 0x51) {\n    return toPointer(<usize>0).toBox(<usize>0); // return a pointer value 0 for -1\n  }\n  if (opcode >= 0x52 && opcode <= 0x60) {\n    return toPointer(<usize>0).toBox(<usize>opcode - <usize>0x50);\n  }\n  if (opcode >= 0x01 && opcode <= 0x4b) {\n    return parseBytes(data, <usize>opcode);\n  }\n  if (opcode == 0) {\n    return data.sliceFrom(0).setLength(0);\n  }\n  return data;\n}\n\n\nexport function _fromPushBox(v: Box): ArrayBuffer {\n  // console.log(\"Box {\");\n  // console.log(\"  start: \" + v.start.toString(10));\n  // console.log(\"  len: \" + v.len.toString(10));\n  // console.log(\"}\");\n  if (v.start === 0) {\n    if (v.len === 0) {\n      const result = new ArrayBuffer(4);\n      store<i32>(changetype<usize>(result), -1);\n      return result;\n    } else {\n      const result = new ArrayBuffer(1);\n      store<u8>(changetype<usize>(result), <u8>v.len);\n      return result;\n    }\n  }\n  return v.toArrayBuffer();\n}\n\nexport function fromPushBox(v: Box): ArrayBuffer {\n  const result = _fromPushBox(v);\n  return result;\n}\n\nexport function isPushOp(op: u8): boolean {\n  return (op >= 0x00 && op <= 0x4f) || (op > 0x50 && op <= 0x60);\n}\n\nexport function decodeTag(box: Box): usize {\n  const v = box.start;\n  if (v === 0) {\n    return box.len;\n  }\n  if (box.len === 0) return <usize>0;\n  const buffer = new ArrayBuffer(sizeof<usize>());\n  if (box.len > <usize>buffer.byteLength) return <usize>0;\n  memcpy(changetype<usize>(buffer), v, box.len);\n  return load<usize>(changetype<usize>(buffer));\n}\n\nexport function isOrdTag(data: Box): boolean {\n  return (load<u32>(data.start) & 0x00ffffff) === 0x64726f;\n}\n\nexport function parseVarInt(data: Box): u64 {\n  const first: u8 = load<u8>(data.start);\n  data.shrinkFront(<usize>1);\n  switch (first) {\n    case 0xff:\n      return <u64>parsePrimitive<u64>(data);\n      break;\n    case 0xfe:\n      return <u64>parsePrimitive<u32>(data);\n      break;\n    case 0xfd:\n      return <u64>parsePrimitive<u16>(data);\n      break;\n    default:\n      return <u64>first;\n  }\n}\n\nexport function parseLenThenBytes(data: Box): Box {\n  const length = parseVarInt(data);\n  return parseBytes(data, <usize>length);\n}\n\n// subsidy of block @ given height\nexport function subsidy(height: u64): u64 {\n  return (50 * 100000000) >> (height / 210000);\n}\n\n// population\nexport function population(ordinal: u64): u64 {\n  let population = 0;\n  for (let i = 0; i < ordinal; i++) {\n    population += ordinal & 1;\n    ordinal >>= 1;\n  }\n  return population;\n}\n\n// first ordinal of subsidy of block @ given height\nexport function firstOrdinal(height: u64): number {\n  let start: u64 = 0;\n  for (let i = 0; i < height; i++) {\n    start += subsidy(height);\n  }\n  return start;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    let array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    let len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(this.dataStart, this.length_, value, start, end);\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    let ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    let len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    let ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    let oldLen = this.length_;\n    let len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    let thisLen = this.length_;\n    let otherLen = other.length_;\n    let outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    let outStart = out.dataStart;\n    let thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    let len = this.length_;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let base = this.dataStart;\n    let element = load<T>(base);\n    let lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    let len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    let ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    let sliceBase = slice.dataStart;\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    let resultStart = result.dataStart;\n    let thisStart = this.dataStart;\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    let offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    let ptr = this.dataStart;\n    let len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      ERROR(\"Cannot call flat() on Array<T> where T is not an Array.\");\n    }\n    // Get the length and data start values\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    // calculate the end size with an initial pass\n    let size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    let byteLength = <usize>size << align;\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    let resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","namespace __proto {\n  /**\n   * Decoder implements protobuf message decode interface.\n   *\n   * Useful references:\n   *\n   * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding\n   * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128\n   * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba\n   */\n  export class Decoder {\n    public view: DataView;\n    public pos: i32;\n\n    constructor(view: DataView) {\n      this.view = view;\n      this.pos = 0;\n    }\n\n    /**\n     * Returns true if current reader has reached the buffer end\n     * @returns True if current reader has reached the buffer end\n     */\n    @inline\n    eof(): bool {\n      return this.pos >= this.view.byteLength;\n    }\n\n    /**\n     * Returns current buffer length in bytes\n     * @returns Length in bytes\n     */\n    @inline\n    get byteLength(): i32 {\n      return this.view.byteLength;\n    }\n\n    /**\n     * An alias method to fetch tag from the reader. Supposed to return tuple of [field number, wire_type].\n     * TODO: Replace with return tuple when tuples become implemented in AS.\n     * @returns Message tag value\n     */\n    @inline\n    tag(): u32 {\n      return this.uint32();\n    }\n\n    /**\n     * Returns byte at offset, alias for getUint8\n     * @param byteOffset Offset\n     * @returns u8\n     */\n    @inline\n    private u8at(byteOffset: i32): u8 {\n      return this.view.getUint8(byteOffset);\n    }\n\n    /**\n     * Reads and returns varint number (128 + 10 bits max) from a current position.\n     * @returns Returns varint\n     */\n    varint(): u64 {\n      let value: u64;\n\n      // u32\n      value = (u64(u8(this.u8at(this.pos))) & 127) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 7)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 14)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 21)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u32 remainder or u64 byte\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value =\n        (value | ((u64(u8(this.u8at(this.pos))) & 127) << 42)) /* 42!!! */ >>>\n        0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 49)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 28)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n      // u64 remainder\n      value = (value | ((u64(u8(this.u8at(this.pos))) & 127) << 35)) >>> 0;\n      if (u8(this.u8at(this.pos++)) < 128) return value;\n\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      return value;\n    }\n\n    @inline\n    int32(): i32 {\n      return i32(this.varint());\n    }\n\n    @inline\n    int64(): i64 {\n      return i32(this.varint());\n    }\n\n    @inline\n    uint32(): u32 {\n      return u32(this.varint());\n    }\n\n    @inline\n    uint64(): u64 {\n      return u64(this.varint());\n    }\n\n    @inline\n    sint32(): i32 {\n      const n: u64 = this.varint();\n      return i32((n >>> 1) ^ -(n & 1));\n    }\n\n    @inline\n    sint64(): i64 {\n      const n: u64 = this.varint();\n      return i64((n >>> 1) ^ -(n & 1));\n    }\n\n    fixed32(): u32 {\n      this.pos += 4;\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      // u32(u8) ensures that u8(-1) becomes u32(4294967295) instead of u8(255)\n      return (\n        u32(u8(this.u8at(this.pos - 4))) |\n        (u32(u8(this.u8at(this.pos - 3))) << 8) |\n        (u32(u8(this.u8at(this.pos - 2))) << 16) |\n        (u32(u8(this.u8at(this.pos - 1))) << 24)\n      );\n    }\n\n    @inline\n    sfixed32(): i32 {\n      return i32(this.fixed32());\n    }\n\n    fixed64(): u64 {\n      this.pos += 8;\n      if (this.pos > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      return (\n        u64(u8(this.u8at(this.pos - 8))) |\n        (u64(u8(this.u8at(this.pos - 7))) << 8) |\n        (u64(u8(this.u8at(this.pos - 6))) << 16) |\n        (u64(u8(this.u8at(this.pos - 5))) << 24) |\n        (u64(u8(this.u8at(this.pos - 4))) << 32) |\n        (u64(u8(this.u8at(this.pos - 3))) << 40) |\n        (u64(u8(this.u8at(this.pos - 2))) << 48) |\n        (u64(u8(this.u8at(this.pos - 1))) << 56)\n      );\n    }\n\n    @inline\n    sfixed64(): i64 {\n      return i64(this.fixed64());\n    }\n\n    @inline\n    float(): f32 {\n      return f32.reinterpret_i32(this.fixed32());\n    }\n\n    @inline\n    double(): f64 {\n      return f64.reinterpret_i64(this.fixed64());\n    }\n\n    @inline\n    bool(): boolean {\n      return this.uint32() > 0;\n    }\n\n    /**\n     * Reads and returns UTF8 string.\n     * @returns String\n     */\n    string(): string {\n      const length = this.uint32();\n      if (this.pos + length > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      const p = this.pos + this.view.byteOffset;\n      const value = String.UTF8.decode(this.view.buffer.slice(p, p + length));\n      this.pos += length;\n      return value;\n    }\n\n    /**\n     * Reads and returns bytes array.\n     * @returns Array<u8> of bytes\n     */\n    bytes(): Array<u8> {\n      const len = this.uint32();\n      if (this.pos + len > this.byteLength) {\n        this.throwOutOfRange();\n      }\n\n      const a = new Array<u8>(len);\n      for (let i: u32 = 0; i < len; i++) {\n        a[i] = u8(this.u8at(this.pos++));\n      }\n\n      return a;\n    }\n\n    /**\n     * Skips a message field if it can'be recognized by an object's decode() method\n     * @param wireType Current wire type\n     */\n    skipType(wireType: u32): void {\n      switch (wireType) {\n        // int32, int64, uint32, uint64, sint32, sint64, bool, enum: varint, variable length\n        case 0:\n          this.varint(); // Just read a varint\n          break;\n        // fixed64, sfixed64, double: 8 bytes always\n        case 1:\n          this.skip(8);\n          break;\n        // length-delimited; length is determined by varint32; skip length bytes;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        // tart group: skip till the end of the group, then skip group end marker\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        // fixed32, sfixed32, float: 4 bytes always\n        case 5:\n          this.skip(4);\n          break;\n\n        // Something went beyond our capability to understand\n        default:\n          throw new Error(\n            `Invalid wire type ${wireType} at offset ${this.pos}`\n          );\n      }\n    }\n\n    /**\n     * Fast-forwards cursor by length with boundary check\n     * @param length Byte length\n     */\n    skip(length: u32): void {\n      if (this.pos + length > this.byteLength) {\n        this.throwOutOfRange();\n      }\n      this.pos += length;\n    }\n\n    /**\n     * OutOfRange check. Throws an exception if current position exceeds current buffer range\n     */\n    @inline\n    private throwOutOfRange(): void {\n      throw new Error(`Decoder position ${this.pos} is out of range!`);\n    }\n  }\n\n  /**\n   * Encoder implements protobuf message encode interface. This is the simplest not very effective version, which uses\n   * Array<u8>.\n   *\n   * Useful references:\n   *\n   * Protocol Buffer encoding: https://developers.google.com/protocol-buffers/docs/encoding\n   * LEB128 encoding AKA varint 128 encoding: https://en.wikipedia.org/wiki/LEB128\n   * ZigZag encoding/decoding (s32/s64): https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba\n   */\n  export class Encoder {\n    public buf: Array<u8>;\n\n    constructor(buf: Array<u8>) {\n      this.buf = buf;\n    }\n\n    /**\n     * Encodes varint at a current position\n     * @returns Returns varint\n     */\n    varint64(value: u64): void {\n      let v: u64 = value;\n\n      while (v > 127) {\n        this.buf.push(u8((v & 127) | 128));\n        v = v >> 7;\n      }\n\n      this.buf.push(u8(v));\n    }\n\n    @inline\n    int32(value: i32): void {\n      this.varint64(value);\n    }\n\n    @inline\n    int64(value: i64): void {\n      this.varint64(value);\n    }\n\n    @inline\n    uint32(value: u32): void {\n      this.varint64(value);\n    }\n\n    @inline\n    uint64(value: u64): void {\n      this.varint64(value);\n    }\n\n    @inline\n    sint32(value: i32): void {\n      this.varint64((value << 1) ^ (value >> 31));\n    }\n\n    @inline\n    sint64(value: i64): void {\n      this.varint64((value << 1) ^ (value >> 63));\n    }\n\n    @inline\n    fixed32(value: u32): void {\n      this.buf.push(u8(value & 255));\n      this.buf.push(u8((value >> 8) & 255));\n      this.buf.push(u8((value >> 16) & 255));\n      this.buf.push(u8(value >> 24));\n    }\n\n    @inline\n    sfixed32(value: i32): void {\n      this.fixed32(u32(value));\n    }\n\n    @inline\n    fixed64(value: u64): void {\n      this.buf.push(u8(value & 255));\n      this.buf.push(u8((value >> 8) & 255));\n      this.buf.push(u8((value >> 16) & 255));\n      this.buf.push(u8((value >> 24) & 255));\n      this.buf.push(u8((value >> 32) & 255));\n      this.buf.push(u8((value >> 40) & 255));\n      this.buf.push(u8((value >> 48) & 255));\n      this.buf.push(u8(value >> 56));\n    }\n\n    @inline\n    sfixed64(value: i64): void {\n      this.fixed64(u64(value));\n    }\n\n    @inline\n    float(value: f32): void {\n      this.fixed32(u32(i32.reinterpret_f32(value)));\n    }\n\n    @inline\n    double(value: f64): void {\n      this.fixed64(u64(i64.reinterpret_f64(value)));\n    }\n\n    @inline\n    bool(value: boolean): void {\n      this.buf.push(value ? 1 : 0);\n    }\n\n    string(value: string): void {\n      const utf8string = new DataView(String.UTF8.encode(value));\n\n      for (let i = 0; i < utf8string.byteLength; i++) {\n        this.buf.push(utf8string.getUint8(i));\n      }\n    }\n\n    @inline\n    bytes(value: Array<u8>): void {\n      for (let i = 0; i < value.length; i++) {\n        this.buf.push(value[i]);\n      }\n    }\n  }\n\n  /**\n   * Returns byte size required to encode a value of a certain type\n   */\n  export class Sizer {\n    static varint64(value: u64): u32 {\n      return value < 128\n        ? 1 // 2^7\n        : value < 16384\n        ? 2 // 2^14\n        : value < 2097152\n        ? 3 // 2^21\n        : value < 268435456\n        ? 4 // 2^28\n        : value < 34359738368\n        ? 5 // 2^35\n        : value < 4398046511104\n        ? 6 // 2^42\n        : value < 562949953421312\n        ? 7 // 2^49\n        : value < 72057594037927936\n        ? 8 // 2^56\n        : value < 9223372036854775808\n        ? 9 // 2^63\n        : 10;\n    }\n\n    @inline\n    static int32(value: i32): u32 {\n      return Sizer.varint64(u64(value));\n    }\n\n    @inline\n    static int64(value: i64): u32 {\n      return Sizer.varint64(u64(value));\n    }\n\n    @inline\n    static uint32(value: u32): u32 {\n      return Sizer.varint64(value);\n    }\n\n    @inline\n    static uint64(value: u64): u32 {\n      return Sizer.varint64(value);\n    }\n\n    @inline\n    static sint32(value: i32): u32 {\n      return Sizer.varint64((value << 1) ^ (value >> 31));\n    }\n\n    @inline\n    static sint64(value: i64): u32 {\n      return Sizer.varint64((value << 1) ^ (value >> 63));\n    }\n\n    @inline\n    static string(value: string): u32 {\n      return value.length;\n    }\n\n    @inline\n    static bytes(value: Array<u8>): u32 {\n      return value.length;\n    }\n  }\n}\nexport namespace metashrew {\n  export class KeyValueFlush {\n    public list: Array<Array<u8>> = new Array<Array<u8>>();\n\n    // Decodes KeyValueFlush from an ArrayBuffer\n    static decode(buf: ArrayBuffer): KeyValueFlush {\n      return KeyValueFlush.decodeDataView(new DataView(buf));\n    }\n\n    // Decodes KeyValueFlush from a DataView\n    static decodeDataView(view: DataView): KeyValueFlush {\n      const decoder = new __proto.Decoder(view);\n      const obj = new KeyValueFlush();\n\n      while (!decoder.eof()) {\n        const tag = decoder.tag();\n        const number = tag >>> 3;\n\n        switch (number) {\n          case 1: {\n            obj.list.push(decoder.bytes());\n            break;\n          }\n\n          default:\n            decoder.skipType(tag & 7);\n            break;\n        }\n      }\n      return obj;\n    } // decode KeyValueFlush\n\n    public size(): u32 {\n      let size: u32 = 0;\n\n      size += __size_bytes_repeated(this.list);\n\n      return size;\n    }\n\n    // Encodes KeyValueFlush to the ArrayBuffer\n    encode(): ArrayBuffer {\n      return changetype<ArrayBuffer>(\n        StaticArray.fromArray<u8>(this.encodeU8Array())\n      );\n    }\n\n    // Encodes KeyValueFlush to the Array<u8>\n    encodeU8Array(\n      encoder: __proto.Encoder = new __proto.Encoder(new Array<u8>())\n    ): Array<u8> {\n      const buf = encoder.buf;\n\n      if (this.list.length > 0) {\n        for (let n: i32 = 0; n < this.list.length; n++) {\n          encoder.uint32(0xa);\n          encoder.uint32(this.list[n].length);\n          encoder.bytes(this.list[n]);\n        }\n      }\n\n      return buf;\n    } // encode KeyValueFlush\n  } // KeyValueFlush\n} // metashrew\n\n// __size_bytes_repeated\n\nfunction __size_bytes_repeated(value: Array<Array<u8>>): u32 {\n  let size: u32 = 0;\n\n  for (let n: i32 = 0; n < value.length; n++) {\n    size += 1 + __proto.Sizer.varint64(value[n].length) + value[n].length;\n  }\n\n  return size;\n}\n","import { memcpy } from \"./memcpy\";\nimport { Box } from \"./box\";\n\nexport function toPointer(v: usize): Pointer {\n  return new Pointer(v);\n}\n\nexport function nullptr<T>(): T {\n  return changetype<T>(0);\n}\n\n\n@final\nexport class Pointer {\n  // just need for making tslint happy\n  [key: number]: number;\n\n\n  @inline constructor(ptr: usize) {\n    return changetype<Pointer>(ptr);\n  }\n\n\n  @inline deref<T>(): U {\n    return <T>load<T>(this.asUsize());\n  }\n\n\n  @inline store<T>(v: T): Pointer {\n    store<T>(this.asUsize(), v);\n    return this;\n  }\n\n\n  @inline asRef<T>(): T {\n    return changetype<T>(this);\n  }\n\n\n  @inline asUsize(): usize {\n    return this.asRef<usize>();\n  }\n\n\n  @inline copyInto<T>(src: T): Pointer {\n    memcpy(this.asUsize(), toPointer(src).asUsize(), sizeof<T>());\n    return this;\n  }\n\n\n  @inline offset<T>(i: usize): Pointer {\n    return toPointer(this.asUsize() + i * sizeof<T>());\n  }\n\n\n  @inline index<T>(i: usize): T {\n    return this.offset(i).asRef();\n  }\n\n  distanceTo(b: Pointer): usize {\n    const au = this.asUsize();\n    const bu = b.asUsize();\n    if (bu > au) return bu - au;\n    else return au - bu;\n  }\n\n\n  @inline\n  toBox(len: usize): Box {\n    return new Box(this.asUsize(), len);\n  }\n}\n","import { console } from \"../utils/logging\";\nimport { Box } from \"../utils/box\";\nimport {\n  parsePrimitive,\n  parseBytes,\n  concat,\n  primitiveToBuffer,\n  reverse,\n} from \"../utils/utils\";\nimport { nullptr, Pointer, toPointer } from \"../utils/pointer\";\nimport { Transaction } from \"./transaction\";\nimport { sha256d } from \"../utils/sha256\";\nimport { encodeHexFromBuffer } from \"../utils/hex\";\n\nexport class Header {\n  public version: i32;\n  public prevBlock: Box;\n  public merkleRoot: Box;\n  public time: u32;\n  public bits: u32;\n  public nonce: u32;\n  public bytes: Box;\n  constructor(data: Box) {\n    let head = data.start;\n    this.version = parsePrimitive<i32>(data);\n    this.prevBlock = parseBytes(data, 32);\n    this.merkleRoot = parseBytes(data, 32);\n    this.time = parsePrimitive<u32>(data);\n    this.bits = parsePrimitive<u32>(data);\n    this.nonce = parsePrimitive<u32>(data);\n    let tail = data.start;\n    this.bytes = toPointer(head).toBox(tail - head);\n  }\n  inspect(): string {\n    return \"Header {\\n\" +\n      \"  version: \" + this.version.toString(10) + \",\\n\" +\n      \"  prevBlock: \" + this.prevBlock.toHexString() + \",\\n\" +\n      \"  merkleRoot: \" + this.merkleRoot.toHexString() + \",\\n\" +\n      \"  time: \" + this.time.toString(10) + \",\\n\" +\n      \"  bits: \" + this.bits.toString(2) + \",\\n\" +\n      \"  nonce: \" + this.nonce.toString(16) + \"\\n\" +\n    \"}\";\n  }\n  toLeBytes(): ArrayBuffer {\n    let vers = primitiveToBuffer<i32>(this.version);\n    let prevBlock = this.prevBlock.toArrayBuffer();\n    let merkleRoot = this.merkleRoot.toArrayBuffer();\n    let time = primitiveToBuffer<u32>(this.time);\n    let bits = primitiveToBuffer<u32>(this.bits);\n    let nonce = primitiveToBuffer<u32>(this.nonce);\n    return concat([vers, prevBlock, merkleRoot, time, bits, nonce]);\n  }\n}\n\nexport class Block {\n  public bytes: Box;\n  public header: Header;\n  public transactions: Array<Transaction>;\n  public prevBlock: Box;\n  public merkleRoot: Box;\n  constructor(data: Box) {\n    this.transactions = nullptr<Array<Transaction>>();\n    this.prevBlock = nullptr<Box>();\n    this.merkleRoot = nullptr<Box>();\n    let head = data.start;\n    this.header = new Header(data);\n    this.transactions = Transaction.parseTransactionsFromBlock(data);\n    let tail = data.start;\n    this.bytes = toPointer(head).toBox(tail - head);\n  }\n\n  // returns the coinbase transaction if there is one\n  coinbase(): Transaction {\n    return this.transactions[0];\n  }\n\n  blockhash(): ArrayBuffer {\n    // console.log(encodeHexFromBuffer(this.header.toLeBytes()) + \"\\n\");\n    return sha256d(this.header.toLeBytes());\n  }\n\n  // returns list of txids in the block transaction(s) body including the coinbase txid\n  txids(): Array<ArrayBuffer> {\n    let txids = new Array<ArrayBuffer>();\n    for (let i = 0; i < this.transactions.length; i++) {\n      txids.push(this.transactions[i].txid());\n    }\n    return txids;\n  }\n}\n","import { console } from \"../utils/logging\";\nimport {\n  reverse,\n  parsePrimitive,\n  parseVarInt,\n  parseLenThenBytes,\n  parseBytes,\n  isPushOp,\n  decodeTag,\n  concat,\n  primitiveToBuffer,\n} from \"../utils/utils\";\nimport { Box } from \"../utils/box\";\nimport { encodeHex, encodeHexFromBuffer } from \"../utils/hex\";\nimport { sha256d, sha256 } from \"../utils/sha256\";\nimport { Script } from \"../utils/yabsp\";\nimport { Inscription, Field } from \"./inscription\";\nimport { Pointer, toPointer, nullptr } from \"../utils/pointer\";\nimport { Address } from \"./address\";\nimport { Witness } from \"./witness\";\n\n// A reference to a transaction output.\nexport class OutPoint {\n  public bytes: Box;\n  public txid: Box;\n  public index: u32;\n  constructor(bytes: Box) {\n    this.bytes = nullptr<Box>();\n    this.txid = nullptr<Box>();\n    this.index = 0;\n    if (bytes.len == 36) {\n      this.bytes = bytes;\n      this.txid = bytes.sliceFrom(0).shrinkBack(<usize>4);\n      this.index = parsePrimitive<u32>(bytes.sliceFrom(32));\n    }\n  }\n  toArrayBuffer(): ArrayBuffer {\n    return this.bytes.toArrayBuffer();\n  }\n  isNull(): boolean {\n    return (\n      encodeHexFromBuffer(this.txid.toArrayBuffer()) ==\n      \"0x0000000000000000000000000000000000000000000000000000000000000000\"\n    );\n  }\n\n  static from(txid: ArrayBuffer, offset: u32): OutPoint {\n    let index = primitiveToBuffer<u32>(offset);\n    return new OutPoint(Box.from(concat([txid, index])));\n  }\n\n  /**\n   * Returns the outpoint as a buffer\n   * @returns {ArrayBuffer} - The outpoint as a buffer\n   */\n  toBuffer(): ArrayBuffer {\n    return this.bytes.toArrayBuffer();\n  }\n}\n\nexport class Input {\n  public bytes: Box;\n  public hash: Box;\n  public index: u32;\n  public script: Box;\n  public sequence: u32;\n  public witness: Witness;\n  constructor(data: Box) {\n    const head = data.start;\n    this.hash = parseBytes(data, 32);\n    this.index = parsePrimitive<u32>(data);\n    this.script = parseLenThenBytes(data);\n    this.sequence = parsePrimitive<u32>(data);\n    this.witness = nullptr<Witness>();\n    const tail = data.start;\n    this.bytes = toPointer(head).toBox(tail - head);\n  }\n\n  /**\n   * Returns the outpoint of the input\n   * @returns {ArrayBuffer} - The outpoint of the input\n   */\n  previousOutput(): OutPoint {\n    let txid = toPointer(this.hash.start).toBox(<usize>32);\n    // let bytes = toPointer(this.hash.start).toBox(<usize>36);\n    return OutPoint.from(\n      reverse(txid.toArrayBuffer()),\n      this.index\n    );\n  }\n\n  inscription(): Inscription | null {\n    if (changetype<usize>(this.witness) === 0) return null;\n    let script = this.witness.tapscript();\n    if (script == nullptr<Box>() || !Witness.isInscribed(script)) return null;\n    return new Inscription(script);\n  }\n}\n\nexport class Output {\n  public bytes: Box;\n  public value: u64;\n  public script: Box;\n  public segwit: boolean;\n  constructor(data: Box, segwit: boolean = false) {\n    const head = data.start;\n    this.value = parsePrimitive<u64>(data);\n    this.script = parseLenThenBytes(data);\n    const tail = data.start;\n    this.bytes = toPointer(head).toBox(tail - head);\n    this.segwit = segwit;\n  }\n\n  /**\n   * Returns the address of the output, returns null if the output is not a known or valid address\n   * @returns {ArrayBuffer | null} - The address of the output or null if the output is not a known or valid address\n   */\n  intoAddress(): ArrayBuffer | null {\n    let scr = Script.from(this.script);\n    return Address.from(scr);\n  }\n}\n\nexport class Transaction {\n  public bytes: Box;\n  public version: u32;\n  public flag: boolean;\n  public ins: Array<Input>;\n  public outs: Array<Output>;\n  public locktime: u32;\n  public witnessDataBytes: Box;\n  public legacyInputOutputBytes: Box;\n  private _txid: ArrayBuffer;\n  constructor(data: Box) {\n    this.bytes = nullptr<Box>();\n    this.ins = new Array<Input>();\n    this.outs = new Array<Output>();\n    this.witnessDataBytes = nullptr<Box>();\n    this.legacyInputOutputBytes = nullptr<Box>();\n    this.flag = false;\n    this._txid = new ArrayBuffer(0);\n\n    const head = data.start;\n    this.version = parsePrimitive<u32>(data);\n    const saved = data.sliceFrom(0);\n    const marker = parsePrimitive<u8>(data);\n    const flag = parsePrimitive<u8>(data);\n    if (marker === <u8>0 && flag === <u8>1) {\n      this.flag = true;\n    } else {\n      data.start = saved.start;\n      data.len = saved.len;\n    }\n\n    let inputLegacyHead = data.start;\n    const vinLen = <i32>parseVarInt(data);\n    for (let i = 0; i < vinLen; i++) {\n      this.ins[i] = new Input(data);\n    }\n\n    const voutLen = <i32>parseVarInt(data);\n    for (let i = 0; i < voutLen; i++) {\n      if (this.flag) this.outs.push(new Output(data, true));\n      else this.outs.push(new Output(data));\n    }\n    let outputLegacyTail = data.start;\n    this.legacyInputOutputBytes = toPointer(inputLegacyHead).toBox(\n      outputLegacyTail - inputLegacyHead,\n    );\n\n    if (this.flag) {\n      let witnessHead = data.start;\n      for (let i = 0; i < vinLen; i++) {\n        this.ins[i].witness = new Witness(data);\n      }\n      let witnessTail = data.start;\n      this.witnessDataBytes = toPointer(witnessHead).toBox(\n        witnessTail - witnessHead,\n      );\n    }\n\n    this.locktime = parsePrimitive<u32>(data);\n    let tail = data.start;\n    this.bytes = toPointer(head).toBox(tail - head);\n\n    // let testbytes = toPointer(head).toBox((tail - head) + 4)\n    // console.log(\"\\n\\n 4 bytes larger then end => \" + encodeHexFromBuffer( testbytes.toArrayBuffer() ));\n  }\n\n  legacyBytes(): Array<Box> {\n    if (this.flag) {\n      let version = toPointer(this.bytes.start).toBox(4);\n      let locktime = toPointer(this.bytes.start + this.bytes.len - 4).toBox(4);\n      let result = new Array<Box>();\n      result.push(version);\n      result.push(this.legacyInputOutputBytes);\n      result.push(locktime);\n      return result;\n    } else {\n      let result = new Array<Box>();\n      result.push(this.bytes);\n      return result;\n    }\n  }\n\n  txid(): ArrayBuffer {\n    if (this._txid.byteLength > 0) {\n      return this._txid;\n    }\n    this._txid = sha256d(Box.concat(this.legacyBytes()));\n    return this._txid;\n  }\n\n  parseInscriptions(): Array<Inscription> {\n    return Transaction.parseInscriptionsFromTransaction(this);\n  }\n\n  static parseInscriptionsFromTransaction(tx: Transaction): Array<Inscription> {\n    let insc = new Array<Inscription>();\n    let vins = tx.ins;\n    let vinLen = tx.ins.length;\n\n    for (let j = 0; j < vinLen; j++) {\n      let script = vins[j].witness.tapscript();\n      if (script == nullptr<Box>()) continue;\n      let inscription = new Inscription(script);\n      insc.push(inscription);\n    }\n\n    return insc;\n  }\n\n  static parseTransactionsFromBlock(data: Box): Array<Transaction> {\n    const txsLen = parseVarInt(data);\n    let result = new Array<Transaction>(<i32>txsLen);\n    for (let i = 0; i < <i32>txsLen; i++) {\n      result[i] = new Transaction(data);\n    }\n    return result;\n  }\n}\n","import { Box } from \"../utils/box\";\nimport {\n  isPushOp,\n  parsePrimitive,\n  parseLenThenBytes,\n  parseVarInt,\n  parsePushOp,\n  isOrdTag,\n  decodeTag,\n  concat,\n} from \"../utils/utils\";\nimport { console } from \"../utils/logging\";\nimport { toPointer, nullptr, Pointer } from \"../utils/pointer\";\nimport { toPointer, nullptr, Pointer } from \"../utils/pointer\";\n\nexport class WitnessPart {\n  public bytes: Box;\n  public firstByte: u8;\n  public isScript: boolean;\n  public taprootAnnex: boolean;\n\n  constructor(data: Box) {\n    this.bytes = parseLenThenBytes(data);\n    this.firstByte = parsePrimitive<u8>(this.bytes.sliceFrom(0));\n\n    // check first byte of witness part\n    // determines if part is a script or has taproot annex byte (0x50)\n    switch (this.firstByte) {\n      case 0x50:\n        this.taprootAnnex = true;\n        this.isScript = false;\n        break;\n      case 0x30:\n        this.isScript = false;\n        this.taprootAnnex = false;\n        break;\n      default:\n        this.taprootAnnex = false;\n        this.isScript = true;\n    }\n\n    if (this.bytes.len <= 1) {\n      this.isScript = false;\n    }\n  }\n}\n\nfunction containsPushOp(data: Box): boolean {\n  if (data.len < 1) return false;\n  return isPushOp(load<u8>(data.start));\n}\n\nexport class Witness {\n  public bytes: Box;\n  public parts: Array<WitnessPart>;\n\n  constructor(data: Box) {\n    this.bytes = nullptr<Box>();\n    const head: usize = data.start;\n    const len = <i32>parseVarInt(data);\n    this.parts = new Array<WitnessPart>(len);\n    for (let i = 0; i < len; i++) {\n      this.parts[i] = new WitnessPart(data);\n    }\n    const tail: usize = data.start;\n    this.bytes = toPointer(head).toBox(tail - head);\n  }\n  static isInscribed(data: Box): boolean {\n    const view = data.sliceFrom(0);\n\n    let head = view.start;\n    let len = view.len;\n    let tail = view.start + len;\n\n    // find the inscription\n    while (head < tail - 1) {\n      if (load<u8>(head) == 0x00 && load<u8>(head + 1) == 0x63) {\n        head += 2;\n        len -= 2;\n        break;\n      }\n      head++;\n      len--;\n    }\n    while (tail > head) {\n      if (load<u8>(tail) == 0x68) break;\n      tail--;\n      len--;\n    }\n    let inscBox = toPointer(head).toBox(len);\n    if (!containsPushOp(inscBox)) return false;\n    let ordTag = parsePushOp(inscBox);\n    return isOrdTag(ordTag);\n  }\n  taprootAnnex(): boolean {\n    if (this.parts.length >= 2) {\n      return this.parts[this.parts.length - 1].taprootAnnex;\n    }\n    return false;\n  }\n\n  // get tapscript following rules in BIP341\n  // [ref](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)\n  tapscript(): Box {\n    var len = this.parts.length;\n    var script: Box = nullptr<Box>();\n    // fail if witness stack is empty\n    if (len < 1) {\n      return nullptr<Box>();\n    }\n\n    if (len >= 2) {\n      // let m: Array<WitnessPart>;\n      let mLen = this.parts.length;\n      // check for taproot annex\n      if (this.parts[len - 1].taprootAnnex) {\n        //m = this.parts.slice(0, len - 1);\n        mLen--;\n      } else {\n        //m = this.parts.slice(0, len);\n      }\n\n      // keypath spend\n      // TODO: validate the remaining signature\n      if (mLen <= 1) return nullptr<Box>();\n\n      // if this is a signature\n      if (!this.parts[mLen - 2].isScript) {\n        return script;\n      }\n\n      let control = this.parts[mLen - 1].bytes;\n      if (control.len < 33 || (control.len - 33) % 32 != 0) return script;\n\n      // return copy so it can be parsed;\n      script = this.parts[mLen - 2].bytes.sliceFrom(0);\n      return script;\n    } else {\n      return script;\n    }\n  }\n}\n","import { Box } from \"metashrew-as/assembly/utils/box\";\nimport { input, _flush } from \"metashrew-as/assembly/indexer/index\";\nimport { Block } from \"metashrew-as/assembly/blockdata/block\";\nimport { IndexPointer } from \"metashrew-as/assembly/indexer/tables\";\nimport {\n  Transaction,\n  Input,\n  Output,\n  OutPoint,\n} from \"metashrew-as/assembly/blockdata/transaction\";\nimport { sha256 } from \"metashrew-as/assembly/utils/sha256\";\nimport {\n  OUTPOINTS_FOR_ADDRESS,\n  OUTPOINT_SPENDABLE_BY,\n  OUTPOINT_TO_OUTPUT,\n} from \"./tables\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\nimport { spendables } from \"./protobuf\";\nimport { encodeHexFromBuffer } from \"metashrew-as/assembly/utils/hex\";\nimport { parsePrimitive, primitiveToBuffer } from \"metashrew-as/assembly/utils\";\n\nexport function outputToBytes(\n  hash: ArrayBuffer,\n  vout: u32,\n  log: bool = false,\n): ArrayBuffer {\n  const res = OutPoint.from(hash, vout).toArrayBuffer();\n  return res;\n}\n\nexport function arrayBufferToArray(data: ArrayBuffer): Array<u8> {\n  const result = new Array<u8>(data.byteLength);\n  store<usize>(changetype<usize>(result), changetype<usize>(data));\n  store<usize>(\n    changetype<usize>(result) + sizeof<usize>(),\n    changetype<usize>(data),\n  );\n  return result;\n}\n\nexport function bytesToOutput(data: ArrayBuffer): spendables.Output {\n  const output = new Output(Box.from(data));\n  const result = new spendables.Output();\n  result.script = arrayBufferToArray(output.script.toArrayBuffer());\n  result.value = output.value;\n  return result;\n}\n\nexport class SpendablesIndex {\n  indexBlock(height: u32, block: Block): void {\n    for (let i = 0; i < block.transactions.length; i++) {\n      const tx = block.transactions[i];\n\n      for (let inp = 0; inp < block.transactions[i].ins.length; inp++) {\n        const input = tx.ins[inp];\n        const output = input.previousOutput().toArrayBuffer();\n        const lookup = OUTPOINT_SPENDABLE_BY.select(output);\n        lookup.nullify();\n      }\n      const txid = tx.txid();\n      for (let i: i32 = 0; i < tx.outs.length; i++) {\n        const output = tx.outs[i];\n        const outpoint = outputToBytes(txid, i);\n        const address = output.intoAddress();\n        OUTPOINT_TO_OUTPUT.select(outpoint).set(output.bytes.toArrayBuffer());\n        if (address) {\n          OUTPOINTS_FOR_ADDRESS.select(address).append(outpoint);\n          OUTPOINT_SPENDABLE_BY.select(outpoint).set(address);\n        }\n      }\n    }\n  }\n\n  findOutpointsForAddress(address: ArrayBuffer): Array<ArrayBuffer> {\n    const addressPtr = OUTPOINTS_FOR_ADDRESS.select(address);\n    const keys = new Array<ArrayBuffer>(0);\n\n    for (let i: u32 = 0; i < addressPtr.length(); i++) {\n      const item = addressPtr.selectIndex(i).get();\n      const _address = OUTPOINT_SPENDABLE_BY.select(item).get();\n      if (\n        memory.compare(\n          changetype<usize>(address),\n          changetype<usize>(_address),\n          address.byteLength,\n        ) == 0\n      ) {\n        keys.push(item);\n      }\n    }\n\n    return keys;\n  }\n}\n","/*\nexport function memcpy(dest: usize, src: usize, n: usize): usize {\n  var ret = dest;\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && src % 4) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if (dest % 4 == 0) {\n    while (n >= 16) {\n      store<u32>(dest, load<u32>(src));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      store<u32>(dest + 8, load<u32>(src + 8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16;\n      dest += 16;\n      n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest, load<u32>(src));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8;\n      src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4;\n      src += 4;\n    }\n    if (n & 2) {\n      // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2;\n      src += 2;\n    }\n    if (n & 1) {\n      // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return ret;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest % 4) {\n      // known to be != 0\n      case 1:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, (w >> 24) | (x << 8));\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, (x >> 24) | (w << 8));\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, (w >> 24) | (x << 8));\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, (x >> 24) | (w << 8));\n          src += 16;\n          dest += 16;\n          n -= 16;\n        }\n        break;\n      case 2:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, (w >> 16) | (x << 16));\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, (x >> 16) | (w << 16));\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, (w >> 16) | (x << 16));\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, (x >> 16) | (w << 16));\n          src += 16;\n          dest += 16;\n          n -= 16;\n        }\n        break;\n      case 3:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, (w >> 8) | (x << 24));\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, (x >> 8) | (w << 24));\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, (w >> 8) | (x << 24));\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, (x >> 8) | (w << 24));\n          src += 16;\n          dest += 16;\n          n -= 16;\n        }\n        break;\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n  return ret;\n}\n*/\n\nexport function memcpy(dest: usize, src: usize, len: usize): usize {\n  memory.copy(dest, src, len);\n  return dest;\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  let ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  let buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  let bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  let array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","import { reverse } from \"./utils\";\nimport { sha256 } from \"fast-sha256-as/assembly/sha256.ts\";\n\nexport { sha256 };\n\nexport function sha256d(data: ArrayBuffer): ArrayBuffer {\n  return reverse(sha256(sha256(data)));\n}\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): Int8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): Uint8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    value = ~(value >> 31) & (((255 - value) >> 31) | value);\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): Uint8ClampedArray {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    let len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): Int16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    let len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): Uint16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    let len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    FILL<u32>(this.dataStart, this.length, u32(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): Int32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    let len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    FILL<u32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): Uint32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    let len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    FILL<u64>(this.dataStart, this.length, u64(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): Int64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    let len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    FILL<u64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): Uint64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    let len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    FILL<f32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): Float32Array {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    let len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    FILL<f64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): Float64Array {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  let slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  let to    = target < 0 ? max(len + target, 0) : min(target, len);\n  let from  = start < 0 ? max(len + start, 0) : min(start, len);\n  let last  = end < 0 ? max(len + end, 0) : min(end, len);\n  let count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  let byteLength = len << alignof<T>();\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  let len = array.length;\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  let dataStart  = array.dataStart;\n  let j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  let byteLength = j << alignof<T>();\n  let data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  let dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  let dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  let byteLength: i32;\n  let bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<\n  TArray extends ArrayLike<number>,\n  UArray extends ArrayLike<number>\n>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<valueof<UArray>>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n  let sourceLen = source.length;\n  if (offset < 0 || sourceLen + offset > target.length) {\n    // offset is out of bounds\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  // @ts-ignore: dataStart\n  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));\n  // @ts-ignore: dataStart\n  let sourceStart = source.dataStart;\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (\n    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&\n    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&\n    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)\n  ) {\n    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));\n  } else {\n    for (let i = 0; i < sourceLen; i++) {\n      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));\n      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<valueof<UArray>>()) {\n          store<valueof<TArray>>(ptr,\n            isFinite<valueof<UArray>>(value)\n              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))\n              : 0\n          );\n        } else {\n          if (!isSigned<valueof<UArray>>()) {\n            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));\n          } else if (sizeof<valueof<TArray>>() <= 4) {\n            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));\n          } else {\n            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));\n          }\n        }\n      } else {\n        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {\n          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);\n        } else {\n          store<valueof<TArray>>(ptr, <valueof<TArray>>value);\n        }\n      }\n    }\n  }\n}\n","import { strtol, strtod, strtob } from \"./util/string\";\n\ntype auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVector<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function eq<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ne<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rem<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i32 {\n    return strtol<i32>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i32, right: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u32, right: u32): u32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i64, right: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u64, right: u64): u64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): bool {\n    return strtob(value);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f32, right: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f32, right: f32): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f64 {\n    return strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f64, right: f64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f64, right: f64): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd<T>(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd<T>(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect<T>(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_q15mulr<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_add<T>(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_q15mulr_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_i8x16_i7x16_s(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_i8x16_i7x16_add_s(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max(a: v128, b: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\n@external.js(\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\n@external.js(\"console.log(message, ...[a0, a1, a2, a3, a4].slice(0, n));\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\n@external.js(\"return Date.now() * Math.random();\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","import { console } from \"../utils/logging\";\nimport { bech32m, bech32, toWords } from \"../utils/b32\";\nimport { base58 } from \"../utils/b58\";\nimport { concat } from \"../utils/utils\";\nimport { sha256 } from \"../utils/sha256\";\nimport { Script } from \"../utils/yabsp\";\nimport { Box } from \"../utils/box\";\n\nexport class Address {\n  /**\n   * Returns the address from a given script\n   * @param {Script} script - The script to extract the address from\n   * @returns {ArrayBuffer | null} - The address or null if the script is not a valid address\n   */\n  static from(script: Script): ArrayBuffer | null {\n    if (script.is_p2pkh()) {\n      let bytes: Box = script.data.sliceFrom(3).setLength(20);\n      let prefix = new Uint8Array(1);\n      prefix[0] = 0x00;\n      return Address.toBase58Check(prefix.buffer, bytes.toArrayBuffer());\n    } else if (script.is_p2sh()) {\n      let bytes: Box = script.data.sliceFrom(2).setLength(20);\n      let prefix = new Uint8Array(1);\n      prefix[0] = 0x05;\n      return Address.toBase58Check(prefix.buffer, bytes.toArrayBuffer());\n    } else if (script.is_witness_program()) {\n      let bytes = script.data.sliceFrom(2).toArrayBuffer();\n      let version = load<u8>(script.witness_version) === 0x00 ? 0x00 : 0x01;\n      return Address.toBech32(String.UTF8.encode(\"bc\"), bytes, <u8>version);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns the bech32 encoding of the given data\n   * @param {ArrayBuffer} prefix - The prefix to use for the encoding\n   * @param {ArrayBuffer} data - The data to encode\n   * @param {u8} version - The version to use for the encoding\n   * @returns {ArrayBuffer} - The bech32 encoding of the data\n   */\n  static toBech32(\n    prefix: ArrayBuffer,\n    data: ArrayBuffer,\n    version: u8,\n  ): ArrayBuffer {\n    let words = toWords(data);\n    words.unshift(version);\n\n    if (version === 0) {\n      return bech32(prefix, words);\n    } else {\n      return bech32m(prefix, words);\n    }\n  }\n\n  /**\n   * Returns the base58check encoding of the given data\n   * @param {ArrayBuffer} prefix - The prefix to use for the encoding\n   * @param {ArrayBuffer} data - The data to encode\n   * @returns {ArrayBuffer} - The base58check encoding of the data\n   */\n  static toBase58Check(prefix: ArrayBuffer, data: ArrayBuffer): ArrayBuffer {\n    let checksum: ArrayBuffer = sha256(sha256(concat([prefix, data]))).slice(\n      0,\n      4,\n    );\n    let hash: Uint8Array = Uint8Array.wrap(concat([prefix, data, checksum]));\n    let encoded = base58(hash);\n    return encoded;\n  }\n}\n","export function REVERSE<T>(ptr: usize, len: usize): void {\n  if (len > 1) {\n    let\n      i: usize = 0,\n      tail: usize,\n      hlen: usize = len >> 1;\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (sizeof<T>() == 1) {\n        // TODO: Decide later: Does we need this fast path cases?\n        //\n        // if (len == 4) {\n        //   store<u32>(ptr, bswap(load<u32>(ptr)));\n        //   return;\n        // }\n        // if (len == 8) {\n        //   store<u64>(ptr, bswap(load<u64>(ptr)));\n        //   return;\n        // }\n        tail = len - 8;\n        while (i + 7 < hlen) {\n          let front = ptr + i;\n          let back  = ptr + tail - i;\n          let temp  = bswap(load<u64>(front));\n          store<u64>(front, bswap(load<u64>(back)));\n          store<u64>(back, temp);\n          i += 8;\n        }\n      }\n\n      if (sizeof<T>() == 2) {\n        tail = len - 2;\n        while (i + 1 < hlen) {\n          let front = ptr + (i << 1);\n          let back  = ptr + (tail - i << 1);\n          let temp  = rotr(load<u32>(back), 16);\n          store<u32>(back, rotr(load<u32>(front), 16));\n          store<u32>(front, temp);\n          i += 2;\n        }\n      }\n    }\n\n    tail = len - 1;\n    while (i < hlen) {\n      let front = ptr + (i << alignof<T>());\n      let back  = ptr + (tail - i << alignof<T>());\n      let temp  = load<T>(front);\n      store<T>(front, load<T>(back));\n      store<T>(back, temp);\n      i++;\n    }\n  }\n}\n\nexport function FILL<T>(\n  ptr: usize,\n  len: usize,\n  value: T,\n  start: isize,\n  end: isize\n): void {\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        ptr + <usize>start,\n        u8(value),\n        <usize>(end - start)\n      );\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL <= 1) {\n      if (isInteger<T>()) {\n        // @ts-ignore\n        if (value == <T>0 | value == <T>-1) {\n          if (start < end) {\n            memory.fill(\n              ptr + (<usize>start << alignof<T>()),\n              u8(value),\n              <usize>(end - start) << alignof<T>()\n            );\n          }\n          return;\n        }\n      } else if (isFloat<T>()) {\n        // for floating non-negative zeros we can use fast memory.fill\n        if ((sizeof<T>() == 4 && reinterpret<u32>(f32(value)) == 0) ||\n            (sizeof<T>() == 8 && reinterpret<u64>(f64(value)) == 0)) {\n          if (start < end) {\n            memory.fill(\n              ptr + (<usize>start << alignof<T>()),\n              0,\n              <usize>(end - start) << alignof<T>()\n            );\n          }\n          return;\n        }\n      }\n    }\n    for (; start < end; ++start) {\n      store<T>(ptr + (<usize>start << alignof<T>()), value);\n    }\n  }\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol, strtod } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f64 {\n    return strtod(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","import { RunesBlock } from \"metashrew-runes/assembly/indexer/RunesBlock\";\nimport { RunestoneMessage } from \"metashrew-runes/assembly/indexer/RunestoneMessage\";\nimport { RunesTransaction } from \"metashrew-runes/assembly/indexer/RunesTransaction\";\nimport { Block } from \"metashrew-as/assembly/blockdata/block\";\nimport { Field } from \"metashrew-runes/assembly/indexer/Field\";\nimport { ProtoruneField } from \"./fields/ProtoruneField\";\nimport { OutPoint } from \"metashrew-as/assembly/blockdata/transaction\";\nimport { fieldTo, min } from \"metashrew-runes/assembly/utils\";\nimport { Edict } from \"metashrew-runes/assembly/indexer/Edict\";\nimport { ProtoMessage, MessageContext } from \"./protomessage\";\nimport { ProtoruneBalanceSheet } from \"./ProtoruneBalanceSheet\";\nimport { BalanceSheet } from \"metashrew-runes/assembly/indexer/BalanceSheet\";\nimport { Protostone } from \"./Protostone\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\nimport { RunesIndex } from \"metashrew-runes/assembly/indexer\";\n\nimport { Protoburn } from \"./Protoburn\";\n\nfunction uniq<T>(v: Array<T>): Array<T> {\n  const seen = new Map<T, bool>();\n  const result = new Array<T>(0);\n  for (let i = 0; i < v.length; i++) {\n    if (!seen.has(v[i])) result.push(v[i]);\n    seen.set(v[i], true);\n  }\n  return result;\n}\n\nclass BurnCycle {\n  public max: i32;\n  public cycles: Map<string, i32>;\n  constructor(max: i32) {\n    this.max = max;\n    this.cycles = new Map<string, i32>();\n  }\n  next(rune: ArrayBuffer): i32 {\n    if (!this.cycles.has(changetype<string>(rune))) {\n      this.cycles.set(changetype<string>(rune), 0);\n    }\n    const cycle = this.cycles.get(changetype<string>(rune));\n    this.cycles.set(changetype<string>(rune), (cycle + 1) % this.max);\n    return cycle;\n  }\n  peek(rune: ArrayBuffer): i32 {\n    if (!this.cycles.has(changetype<string>(rune))) {\n      this.cycles.set(changetype<string>(rune), 0);\n    }\n    return this.cycles.get(changetype<string>(rune));\n  }\n}\n\nexport class Protorune<T extends MessageContext> extends RunesIndex {\n  etchEnabled: bool;\n  openMint: bool;\n  constructor(etchEnabled: bool = false, openMint: bool = false) {\n    super();\n    this.etchEnabled = etchEnabled;\n    this.openMint = openMint;\n  }\n  processRunestone(\n    block: RunesBlock,\n    tx: RunesTransaction,\n    txid: ArrayBuffer,\n    height: u32,\n    i: u32,\n  ): RunestoneMessage {\n    const baseRunestone = tx.runestone();\n    const runestone = Protostone.from(baseRunestone);\n    runestone.etchEnabled = this.etchEnabled;\n    runestone.openMint = this.openMint;\n    const unallocatedTo = runestone.fields.has(Field.POINTER)\n      ? fieldTo<u32>(runestone.fields.get(Field.POINTER))\n      : <u32>tx.defaultOutput();\n    if (changetype<usize>(runestone) === 0)\n      return changetype<RunestoneMessage>(0);\n    const balancesByOutput = changetype<Map<u32, ProtoruneBalanceSheet>>(\n      baseRunestone.process(tx, txid, height, i),\n    );\n    const protostones = runestone.protostones(tx.outs.length + 1);\n    const burns = protostones.burns();\n\n    const runestoneOutputIndex = tx.runestoneOutputIndex();\n    const edicts = Edict.fromDeltaSeries(runestone.edicts);\n    if (burns.length > 0) {\n      this.processProtoburns(\n        unallocatedTo,\n        balancesByOutput,\n        txid,\n        runestoneOutputIndex,\n        runestone,\n        edicts,\n        burns,\n      );\n    }\n    this.processProtostones(protostones.flat(), block, height, tx, txid, i);\n    return changetype<RunestoneMessage>(runestone);\n  }\n  processProtoburns<S extends Protoburn>(\n    unallocatedTo: u32,\n    balancesByOutput: Map<u32, ProtoruneBalanceSheet>,\n    txid: ArrayBuffer,\n    runestoneOutputIndex: i32,\n    runestone: Protostone,\n    edicts: Array<Edict>,\n    protoburns: Array<S>,\n  ): void {\n    const runestoneBalanceSheet = new ProtoruneBalanceSheet();\n    (balancesByOutput.has(runestoneOutputIndex)\n      ? balancesByOutput.get(runestoneOutputIndex)\n      : new ProtoruneBalanceSheet()\n    ).pipe(changetype<BalanceSheet>(runestoneBalanceSheet));\n    const burns: Array<Edict> = new Array<Edict>(protoburns.length);\n    const burnSheets = new Array<ProtoruneBalanceSheet>(protoburns.length);\n    const cycles = new BurnCycle(protoburns.length);\n    for (let i = 0; i < protoburns.length; i++) {\n      burnSheets[i] = new ProtoruneBalanceSheet();\n    }\n    const pullSet = new Map<u32, bool>();\n    for (let i = 0; i < protoburns.length; i++) {\n      if (protoburns[i].from.length > 0) {\n        const from = uniq(protoburns[i].from);\n        for (let j = 0; j < from.length; j++) {\n          if (!pullSet.has(from[j]) && from[j] < <u32>edicts.length) {\n            const index = <i32>from[j];\n            pullSet.set(from[j], true);\n            if (edicts[index].output === u128.from(runestoneOutputIndex)) {\n              const rune = edicts[index].runeId().toBytes();\n              const remaining = runestoneBalanceSheet.get(rune);\n              const toApply = min(remaining, edicts[index].amount);\n              if (toApply.isZero()) continue;\n              runestoneBalanceSheet.decrease(rune, toApply);\n              burnSheets[i].increase(rune, toApply);\n\n            }\n          }\n        }\n      }\n    }\n    for (let i = 0; i < edicts.length; i++) {\n      if (pullSet.has(i)) continue;\n      if (edicts[i].output === u128.from(runestoneOutputIndex)) {\n        const rune = edicts[i].runeId().toBytes();\n        const cycle = cycles.peek(rune);\n        const remaining = runestoneBalanceSheet.get(rune);\n        const toApply = min(remaining, edicts[i].amount);\n        if (toApply.isZero()) continue;\n        cycles.next(rune);\n        runestoneBalanceSheet.decrease(rune, toApply);\n        burnSheets[cycle].increase(rune, toApply);\n      }\n    }\n    if (runestoneOutputIndex === unallocatedTo) {\n      for (let i = 0; i < runestoneBalanceSheet.runes.length; i++) {\n        const rune = runestoneBalanceSheet.runes[i];\n        const cycle = cycles.peek(rune);\n        const toApply = runestoneBalanceSheet.get(rune);\n        if (toApply.isZero()) continue;\n        cycles.next(rune);\n        runestoneBalanceSheet.decrease(rune, toApply);\n        burnSheets[cycle].increase(rune, toApply);\n      }\n    }\n    for (let i = 0; i < protoburns.length; i++) {\n      protoburns[i].process(\n        burnSheets[i],\n        OutPoint.from(txid, protoburns[i].pointer).toArrayBuffer(),\n      );\n    }\n  }\n  processProtostones<S extends Protostone>(\n    protostones: Array<S>,\n    block: RunesBlock,\n    height: u64,\n    tx: RunesTransaction,\n    txid: ArrayBuffer,\n    txindex: u32,\n  ): void {\n    for (let i = 0; i < protostones.length; i++) {\n      const protostone = protostones[i];\n      if (protostone.isMessage()) {\n        protostone\n          .toMessage(tx.outs.length + 1 + i)\n          .handle<T>(tx, block, height, txindex);\n      } else if (protostone.edicts.length) {\n        protostone.process(tx, txid, <u32>height, txindex);\n      }\n    }\n  }\n  initializeSubprotocols(): void {\n    changetype<T>(0).initializeProtocol<T>();\n  }\n  indexBlock(height: u32, block: Block): void {\n    this.initializeSubprotocols();\n    super.indexBlock(height, block);\n  }\n}\n\nexport class DefaultProtorune extends Protorune<MessageContext> { }\n","import { Block, OutPoint } from \"metashrew-as/assembly/blockdata\";\nimport { IncomingRune } from \"./IncomingRune\";\nimport { AtomicTransaction } from \"metashrew-as/assembly/indexer/atomic\";\nimport { RuneId } from \"metashrew-runes/assembly/indexer/RuneId\";\nimport { ProtoruneBalanceSheet } from \"../ProtoruneBalanceSheet\";\nimport { ProtoruneTable, PROTOCOLS_TO_INDEX } from \"../tables/protorune\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { RunesTransaction } from \"metashrew-runes/assembly/indexer/RunesTransaction\";\nimport { console } from \"metashrew-as/assembly/utils\";\n\nexport class MessageContext {\n  runtime: AtomicTransaction = new AtomicTransaction();\n  public runes: Array<IncomingRune> = new Array<IncomingRune>();\n  transaction: RunesTransaction = changetype<RunesTransaction>(0);\n  block: Block = changetype<Block>(0);\n  height: u64 = 0;\n  outpoint: OutPoint = changetype<OutPoint>(0);\n  pointer: OutPoint = changetype<OutPoint>(0);\n  refund_pointer: OutPoint = changetype<OutPoint>(0);\n  calldata: ArrayBuffer = new ArrayBuffer(0);\n  txid: ArrayBuffer;\n  baseSheet: ProtoruneBalanceSheet;\n  runeIdToIndex: Map<ArrayBuffer, i32> = new Map<ArrayBuffer, i32>();\n  table: ProtoruneTable;\n  sheets: Map<u32, ProtoruneBalanceSheet>;\n  txindex: u32;\n  runtimeBalance: ProtoruneBalanceSheet;\n\n  constructor(\n    protocolTag: u128,\n    transaction: RunesTransaction,\n    block: Block,\n    height: u64,\n    txindex: u32,\n    index: u32,\n    pointer: u32,\n    refund_pointer: u32,\n    calldata: ArrayBuffer,\n  ) {\n    this.txindex = txindex;\n    this.transaction = transaction;\n    this.block = block;\n    this.height = height;\n    const txid = transaction.txid();\n    const outpoint = OutPoint.from(txid, index);\n    this.outpoint = outpoint;\n    const pointerOutpoint = OutPoint.from(txid, pointer);\n    this.pointer = pointerOutpoint;\n    const refundPointerOutpoint = OutPoint.from(txid, refund_pointer);\n    this.refund_pointer = refundPointerOutpoint;\n    this.calldata = calldata;\n    this.txid = txid;\n    this.baseSheet = new ProtoruneBalanceSheet();\n    this.sheets = new Map<u32, ProtoruneBalanceSheet>();\n    const table = ProtoruneTable.for(protocolTag);\n    this.table = table;\n    this.runtimeBalance = ProtoruneBalanceSheet.load(table.RUNTIME_BALANCE);\n    const sheet = ProtoruneBalanceSheet.load(\n      table.OUTPOINT_TO_RUNES.select(outpoint.toArrayBuffer()),\n    );\n    this.sheets.set(index, sheet);\n    this.sheets.set(\n      pointer,\n      ProtoruneBalanceSheet.load(\n        table.OUTPOINT_TO_RUNES.select(pointerOutpoint.toArrayBuffer()),\n      ),\n    );\n    this.sheets.set(\n      refund_pointer,\n      ProtoruneBalanceSheet.load(\n        table.OUTPOINT_TO_RUNES.select(refundPointerOutpoint.toArrayBuffer()),\n      ),\n    );\n    for (let i = 0; i < sheet.runes.length; i++) {\n      const runeId = RuneId.fromBytesU128(sheet.runes[i]);\n      this.runeIdToIndex.set(sheet.runes[i], i);\n      const rune = new IncomingRune(\n        this,\n        runeId,\n        sheet.balances[i],\n        this.table,\n      );\n      this.runes.push(rune);\n    }\n  }\n  initializeProtocol<T extends MessageContext>(): u128 {\n    const tag = changetype<T>(0).protocolTag();\n    PROTOCOLS_TO_INDEX.add(tag);\n    return tag;\n  }\n  checkBalances(): bool {\n    const checkingSheet = ProtoruneBalanceSheet.loadFromAtomicTx(\n      this.table.OUTPOINT_TO_RUNES.select(this.refund_pointer.toArrayBuffer()),\n      this.runtime,\n    );\n    ProtoruneBalanceSheet.loadFromAtomicTx(\n      this.table.OUTPOINT_TO_RUNES.select(this.pointer.toArrayBuffer()),\n      this.runtime,\n    ).pipe(checkingSheet);\n    ProtoruneBalanceSheet.loadFromAtomicTx(\n      this.table.OUTPOINT_TO_RUNES.select(this.outpoint.toArrayBuffer()),\n      this.runtime,\n    ).pipe(checkingSheet);\n    this.runtimeBalance.pipe(checkingSheet);\n    if (this.baseSheet.runes.length != checkingSheet.runes.length) return false;\n    for (let i = 0; i < this.baseSheet.runes.length; i++) {\n      if (\n        this.baseSheet.get(this.baseSheet.runes[i]) !=\n        checkingSheet.get(this.baseSheet.runes[i])\n      )\n        return false;\n    }\n    return true;\n  }\n\n  run(): void {\n    if (this.sheets.has(this.pointer.index)) {\n      const sheet = this.sheets.get(this.pointer.index);\n      for (let i = 0; i < sheet.runes.length; i++) {\n        if (this.runeIdToIndex.has(sheet.runes[i])) {\n          this.runes[this.runeIdToIndex.get(sheet.runes[i])].pointer_index = i;\n        }\n      }\n      sheet.saveToAtomicTx(\n        this.table.OUTPOINT_TO_RUNES.select(this.pointer.toArrayBuffer()),\n        this.runtime,\n      );\n      sheet.pipe(this.baseSheet);\n    }\n\n    const sheet = this.sheets.has(this.refund_pointer.index)\n      ? this.sheets.get(this.refund_pointer.index)\n      : new ProtoruneBalanceSheet();\n    if (this.sheets.has(this.outpoint.index)) {\n      this.sheets.get(this.outpoint.index).pipe(sheet);\n    }\n    for (let i = 0; i < sheet.runes.length; i++) {\n      if (this.runeIdToIndex.has(sheet.runes[i])) {\n        this.runes[\n          this.runeIdToIndex.get(sheet.runes[i])\n        ].refund_pointer_index = i;\n      }\n    }\n    sheet.saveToAtomicTx(\n      this.table.OUTPOINT_TO_RUNES.select(this.refund_pointer.toArrayBuffer()),\n      this.runtime,\n    );\n    sheet.pipe(this.baseSheet);\n\n    this.runtime.checkpoint();\n    const result = this.handle();\n    if (!result) {\n      this.runtime.rollback();\n    }\n    const balanceCheck = this.checkBalances();\n    if (!balanceCheck) {\n      this.runtime.rollback();\n    }\n    this.runtime.checkpoint();\n    this.runtimeBalance.clearAndSave(this.table.RUNTIME_BALANCE);\n    this.runtime.commit();\n  }\n\n  handle(): bool {\n    return false;\n  }\n  protocolTag(): u128 {\n    //change value here\n    return new u128(0, 64);\n  }\n}\n","import { Box } from \"metashrew-as/assembly/utils/box\";\nimport { RunesBlock } from \"./RunesBlock\";\nimport { RunestoneMessage } from \"./RunestoneMessage\";\nimport { RunesTransaction } from \"./RunesTransaction\";\nimport { Block } from \"metashrew-as/assembly/blockdata/block\";\nimport { scriptParse } from \"metashrew-as/assembly/utils/yabsp\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\nimport {\n  OUTPOINT_TO_HEIGHT,\n  HEIGHT_TO_BLOCKHASH,\n  BLOCKHASH_TO_HEIGHT,\n  GENESIS,\n} from \"./constants\";\nimport { OutPoint } from \"metashrew-as/assembly/blockdata/transaction\";\nimport {\n  isEqualArrayBuffer,\n  fieldToArrayBuffer,\n  stripNullRight,\n} from \"../utils\";\nimport { encodeHexFromBuffer } from \"metashrew-as/assembly/utils\";\n\nexport class RunesIndex {\n  indexOutpoints(\n    tx: RunesTransaction,\n    txid: ArrayBuffer,\n    height: u32,\n  ): void {\n    for (let i: i32 = 0; i < tx.outs.length; i++) {\n      OUTPOINT_TO_HEIGHT.select(\n        OutPoint.from(txid, <u32>i).toArrayBuffer(),\n      ).setValue<u32>(height);\n    }\n  }\n  findCommitment(\n    name: ArrayBuffer,\n    tx: RunesTransaction,\n    height: u32,\n  ): bool {\n    for (let i = 0; i < tx.ins.length; i++) {\n      const input = tx.ins[i];\n      // check that there is 1 data push\n      const inscription = input.inscription();\n\n      if (changetype<usize>(inscription) === 0 || inscription == null) continue;\n      const commitment = inscription.field(0);\n      if (!commitment) continue;\n      const previousOutpoint = tx.ins[i].previousOutput().toArrayBuffer();\n      const previousOutpointHeight =\n        OUTPOINT_TO_HEIGHT.select(previousOutpoint).getValue<u32>();\n      if (height - previousOutpointHeight >= 6) return true;\n    }\n    return false;\n  }\n  processRunestone(block: RunesBlock, tx: RunesTransaction, txid: ArrayBuffer, height: u32, vout: u32): RunestoneMessage {\n    const runestone = tx.runestone();\n    if (changetype<usize>(runestone) === 0) return changetype<RunestoneMessage>(0);\n    runestone.process(tx, txid, height, vout);\n    return runestone;\n  } \n  indexBlock(height: u32, _block: Block): void {\n    if (height == GENESIS) {\n      RunestoneMessage.etchGenesisRune();\n    }\n    const block = changetype<RunesBlock>(_block);\n    HEIGHT_TO_BLOCKHASH.selectValue<u32>(height).set(block.blockhash());\n    BLOCKHASH_TO_HEIGHT.select(block.blockhash()).setValue<u32>(height);\n    block.saveTransactions(height);\n    for (let i: i32 = 0; i < block.transactions.length; i++) {\n      const tx = block.getTransaction(i);\n      const txid = tx.txid();\n      this.indexOutpoints(tx, txid, height);\n      this.processRunestone(block, tx, txid, height, i);\n    }\n  }\n}\n","import { u128 } from \"as-bignum/assembly\";\nimport { Field } from \"./Field\";\nimport { Box } from \"metashrew-as/assembly/utils/box\";\nimport { readULEB128ToU128 } from \"../leb128\";\nimport {\n  u128ToHex,\n  fieldToArrayBuffer,\n  fieldToU128,\n  fieldTo,\n  toArrayBuffer,\n  fromArrayBuffer,\n  toPrimitive,\n  min,\n  nameToArrayBuffer,\n  getReservedNameFor,\n  fieldToName,\n  isNullPtr,\n} from \"../utils\";\nimport { Flag } from \"./Flag\";\nimport { RuneId } from \"./RuneId\";\nimport { Edict } from \"./Edict\";\nimport {\n  AMOUNT,\n  SPACERS,\n  RUNE_ID_TO_ETCHING,\n  ETCHING_TO_RUNE_ID,\n  RUNE_ID_TO_HEIGHT,\n  DIVISIBILITY,\n  PREMINE,\n  MINTS_REMAINING,\n  HEIGHTSTART,\n  HEIGHTEND,\n  OFFSETSTART,\n  OFFSETEND,\n  SYMBOL,\n  CAP,\n  ETCHINGS,\n  OUTPOINT_TO_RUNES,\n  GENESIS,\n  HEIGHT_INTERVAL,\n  MINIMUM_NAME,\n  TWENTY_SIX,\n  RESERVED_NAME,\n  MAX_BYTES_LEB128_INT,\n} from \"./constants\";\nimport { BalanceSheet } from \"./BalanceSheet\";\nimport { RunesTransaction } from \"./RunesTransaction\";\nimport {\n  Input,\n  OutPoint,\n  Output,\n} from \"metashrew-as/assembly/blockdata/transaction\";\nimport {\n  encodeHexFromBuffer,\n  parsePrimitive,\n  SUBSIDY_HALVING_INTERVAL,\n} from \"metashrew-as/assembly/utils\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\n\nexport class RunestoneMessage {\n  public fields: Map<u64, Array<u128>>;\n  public edicts: Array<StaticArray<u128>>;\n  public unallocatedTo: u32;\n  constructor(\n    fields: Map<u64, Array<u128>>,\n    edicts: Array<StaticArray<u128>>,\n    defaultOutput: i32,\n  ) {\n    this.fields = fields;\n    this.edicts = edicts;\n\n    this.unallocatedTo = this.fields.has(Field.POINTER)\n      ? fieldTo<u32>(this.fields.get(Field.POINTER))\n      : <u32>defaultOutput;\n  }\n  inspect(): string {\n    let result = \"RunestoneMessage {\\n\";\n    let fieldInts = this.fields.keys();\n    for (let i = 0; i < fieldInts.length; i++) {\n      result += \"  \" + fieldInts[i].toString(10) + \": [\\n\";\n      const ary = this.fields.get(fieldInts[i]);\n      for (let j = 0; j < ary.length; j++) {\n        result += \"    \" + u128ToHex(ary[j]) + \",\\n\";\n      }\n      result += \"  ]\\n\";\n    }\n    result += \"  edicts: [\";\n    for (let i = 0; i < this.edicts.length; i++) {\n      result += \"    \";\n      for (let j = 0; j < this.edicts[i].length; j++) {\n        result += u128ToHex(this.edicts[i][j]);\n      }\n      if (i !== this.edicts.length - 1) result += \", \";\n    }\n    result += \"]\\n}\";\n    return result;\n  }\n  getFlag(position: u64): bool {\n    if (!this.fields.has(Field.FLAGS)) return false;\n    const flags = fieldToU128(this.fields.get(Field.FLAGS));\n    return !u128.and(flags, u128.from(1) << (<i32>position)).isZero();\n  }\n  isEtching(): bool {\n    return this.getFlag(Flag.ETCHING);\n  }\n  mintTo(): ArrayBuffer {\n    if (!this.fields.has(Field.MINT)) return changetype<ArrayBuffer>(0);\n    return fieldToArrayBuffer(this.fields.get(Field.MINT));\n  }\n  static parse(data: ArrayBuffer, defaultOutput: i32): RunestoneMessage {\n    const input = Box.from(data);\n    let fields = new Map<u64, Array<u128>>();\n    let edicts = new Array<StaticArray<u128>>(0);\n    while (input.len > 0) {\n      const fieldKeyHeap = u128.from(0);\n      const size = readULEB128ToU128(input, fieldKeyHeap);\n      if (size > MAX_BYTES_LEB128_INT) return changetype<RunestoneMessage>(0);\n      input.shrinkFront(size);\n      const fieldKey = fieldKeyHeap.lo;\n      if (fieldKey > 22 && fieldKey % 2 == 0)\n        return changetype<RunestoneMessage>(0); // cenotaph\n      if (fieldKey === 0) {\n        while (input.len > 0) {\n          const edict = new StaticArray<u128>(4);\n          for (let i = 0; i < 4; i++) {\n            const edictInt = u128.from(0);\n            const size = readULEB128ToU128(input, edictInt);\n            if (size > MAX_BYTES_LEB128_INT)\n              return changetype<RunestoneMessage>(0);\n            input.shrinkFront(size);\n            edict[i] = edictInt;\n          }\n          edicts.push(edict);\n        }\n      } else {\n        const value = u128.from(0);\n        const size = readULEB128ToU128(input, value);\n        if (size > MAX_BYTES_LEB128_INT) return changetype<RunestoneMessage>(0);\n        input.shrinkFront(size);\n        let field: Array<u128> = changetype<Array<u128>>(0);\n        if (!fields.has(fieldKey)) {\n          field = new Array<u128>(0);\n          fields.set(fieldKey, field);\n        } else {\n          field = fields.get(fieldKey);\n        }\n        field.push(value);\n      }\n    }\n    return new RunestoneMessage(fields, edicts, defaultOutput);\n  }\n\n  buildRuneIdForMint(bytes: ArrayBuffer): ArrayBuffer {\n    return RuneId.fromBytes(bytes).toBytes();\n  }\n\n  mint(height: u32, balanceSheet: BalanceSheet): bool {\n    let mintTo = this.mintTo();\n    if (changetype<usize>(mintTo) !== 0 && mintTo.byteLength == 32) {\n      const name = RUNE_ID_TO_ETCHING.select(mintTo).get();\n      const remaining = fromArrayBuffer(MINTS_REMAINING.select(name).get());\n      if (!remaining.isZero()) {\n        const heightStart = HEIGHTSTART.select(name).getValue<u64>();\n        const heightEnd = HEIGHTEND.select(name).getValue<u64>();\n        const offsetStart = OFFSETSTART.select(name).getValue<u64>();\n        const offsetEnd = OFFSETEND.select(name).getValue<u64>();\n        const etchingHeight = RUNE_ID_TO_HEIGHT.select(mintTo).getValue<u32>();\n        if (\n          (heightStart === 0 || height >= heightStart) &&\n          (heightEnd === 0 || height < heightEnd) &&\n          (offsetStart === 0 || height >= offsetStart + etchingHeight) &&\n          (offsetEnd === 0 || height < etchingHeight + offsetEnd)\n        ) {\n          MINTS_REMAINING.select(name).set(\n            toArrayBuffer(remaining - u128.from(1)),\n          );\n          balanceSheet.increase(\n            mintTo,\n            fromArrayBuffer(AMOUNT.select(name).get()),\n          );\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  static etchGenesisRune(): void {\n    const name = nameToArrayBuffer(\"UNCOMMONGOODS\");\n    const spacers = 128;\n    const runeId = new RuneId(1, 0).toBytes();\n    ETCHING_TO_RUNE_ID.select(name).set(runeId);\n    RUNE_ID_TO_ETCHING.select(runeId).set(name);\n    RUNE_ID_TO_HEIGHT.select(runeId).setValue<u32>(GENESIS);\n    DIVISIBILITY.select(name).setValue<u8>(1);\n    AMOUNT.select(name).set(toArrayBuffer(u128.from(1)));\n    CAP.select(name).set(toArrayBuffer(u128.Max));\n    MINTS_REMAINING.select(name).set(toArrayBuffer(u128.Max));\n    OFFSETEND.select(name).setValue<u64>(SUBSIDY_HALVING_INTERVAL);\n    SPACERS.select(name).setValue<u32>(128);\n    SYMBOL.select(name).setValue<u8>(<u8>\"\\u{29C9}\".charCodeAt(0));\n    ETCHINGS.append(name);\n  }\n\n  getReservedNameFor(height: u64, tx: u32): ArrayBuffer {\n    let nameU128: u128;\n    if (this.fields.has(Field.RUNE)) nameU128 = this.fields.get(Field.RUNE)[0];\n    else nameU128 = getReservedNameFor(height, tx);\n    let interval: i64 = (height - GENESIS) / HEIGHT_INTERVAL;\n    let minimum_name = MINIMUM_NAME;\n    if (interval > 0)\n      while (interval > 0) {\n        minimum_name = --minimum_name / TWENTY_SIX;\n        interval--;\n      }\n    if (nameU128 < minimum_name || nameU128 >= RESERVED_NAME)\n      return changetype<ArrayBuffer>(0);\n    return toArrayBuffer(nameU128);\n  }\n\n  buildRuneId(height: u64, tx: u32): ArrayBuffer {\n    return new RuneId(height, tx).toBytes();\n  }\n\n  etch(\n    height: u64,\n    tx: u32,\n    initialBalanceSheet: BalanceSheet,\n    transaction: RunesTransaction,\n  ): bool {\n    if (!this.isEtching()) return false;\n    const name = this.getReservedNameFor(height, tx);\n    if (isNullPtr<ArrayBuffer>(name)) return false;\n    if (ETCHING_TO_RUNE_ID.select(name).get().byteLength !== 0) return false; // already taken / commitment not foun\n    const runeId = this.buildRuneId(height, tx);\n    RUNE_ID_TO_ETCHING.select(runeId).set(name);\n    ETCHING_TO_RUNE_ID.select(name).set(runeId);\n    RUNE_ID_TO_HEIGHT.select(runeId).setValue<u32>(<u32>height);\n    if (this.fields.has(Field.DIVISIBILITY))\n      DIVISIBILITY.select(name).setValue<u8>(\n        fieldTo<u8>(this.fields.get(Field.DIVISIBILITY)),\n      );\n    if (this.fields.has(Field.PREMINE)) {\n      const premine = fieldToU128(this.fields.get(Field.PREMINE));\n      BalanceSheet.fromPairs([runeId], [premine]).pipe(initialBalanceSheet);\n      PREMINE.select(name).set(toArrayBuffer(premine));\n    }\n    if (this.getFlag(Flag.TERMS)) {\n      if (this.fields.has(Field.AMOUNT))\n        AMOUNT.select(name).set(\n          toArrayBuffer(fieldToU128(this.fields.get(Field.AMOUNT))),\n        );\n\n      if (this.fields.has(Field.CAP)) {\n        CAP.select(name).set(\n          toArrayBuffer(fieldToU128(this.fields.get(Field.CAP))),\n        );\n        MINTS_REMAINING.select(name).set(\n          fieldToArrayBuffer(this.fields.get(Field.CAP)),\n        );\n      }\n      if (this.fields.has(Field.HEIGHTSTART))\n        HEIGHTSTART.select(name).setValue<u64>(\n          fieldTo<u64>(this.fields.get(Field.HEIGHTSTART)),\n        );\n      if (this.fields.has(Field.HEIGHTEND))\n        HEIGHTEND.select(name).setValue<u64>(\n          fieldTo<u64>(this.fields.get(Field.HEIGHTEND)),\n        );\n      if (this.fields.has(Field.OFFSETSTART))\n        OFFSETSTART.select(name).setValue<u64>(\n          fieldTo<u64>(this.fields.get(Field.OFFSETSTART)),\n        );\n      if (this.fields.has(Field.OFFSETEND))\n        OFFSETEND.select(name).setValue<u64>(\n          fieldTo<u64>(this.fields.get(Field.OFFSETEND)),\n        );\n    }\n    if (this.fields.has(Field.SPACERS))\n      SPACERS.select(name).setValue<u32>(\n        fieldTo<u32>(this.fields.get(Field.SPACERS)),\n      );\n    if (this.fields.has(Field.SYMBOL))\n      SYMBOL.select(name).setValue<u8>(\n        fieldTo<u8>(this.fields.get(Field.SYMBOL)),\n      );\n    ETCHINGS.append(name);\n    return true;\n  }\n\n  //TODO: This should really be a function in transaction.ts in metashrew-as in class Output\n  isNonOpReturnOutput(output: Output): bool {\n    let view = output.script.sliceFrom(0);\n    return parsePrimitive<u8>(view) != 0x6a;\n  }\n\n  numNonOpReturnOutputs(outputs: Array<Output>): u128 {\n    let counter = 0;\n    for (let i = 0; i < outputs.length; i++) {\n      if (this.isNonOpReturnOutput(outputs[i])) {\n        counter++;\n      }\n    }\n    return new u128(counter, 0);\n  }\n\n  updateBalancesForEdict(\n    balancesByOutput: Map<u32, BalanceSheet>,\n    balanceSheet: BalanceSheet,\n    edictAmount: u128,\n    edictOutput: u32,\n    runeId: ArrayBuffer,\n  ): void {\n    let outputBalanceSheet = changetype<BalanceSheet>(0);\n    if (!balancesByOutput.has(edictOutput)) {\n      balancesByOutput.set(\n        edictOutput,\n        (outputBalanceSheet = new BalanceSheet()),\n      );\n    } else outputBalanceSheet = balancesByOutput.get(edictOutput);\n    const amount = edictAmount.isZero()\n      ? balanceSheet.get(runeId)\n      : min(edictAmount, balanceSheet.get(runeId));\n    balanceSheet.decrease(runeId, amount);\n    outputBalanceSheet.increase(runeId, amount);\n  }\n\n  processEdict(\n    balancesByOutput: Map<u32, BalanceSheet>,\n    balanceSheet: BalanceSheet,\n    edict: Edict,\n    outputs: Array<Output>,\n  ): bool {\n    if (edict.block.isZero() && !edict.transactionIndex.isZero()) {\n      return true;\n    }\n    const runeId = edict.runeId().toBytes();\n\n    const edictOutput = toPrimitive<u32>(edict.output);\n    if (edictOutput > <u32>outputs.length) {\n      return true;\n    } else if (edictOutput == outputs.length) {\n      if (edict.amount.isZero()) {\n        const numNonOpReturnOuts: u128 = this.numNonOpReturnOutputs(outputs);\n        if (!numNonOpReturnOuts.isZero()) {\n          const amountSplit = u128.div(\n            balanceSheet.get(runeId),\n            numNonOpReturnOuts,\n          );\n          const amountSplitPlus1 = amountSplit.preInc();\n          const numRemainder = u128.rem(\n            balanceSheet.get(runeId),\n            numNonOpReturnOuts,\n          );\n          let extraCounter: u64 = 0;\n          for (let i = 0; i < outputs.length; i++) {\n            if (this.isNonOpReturnOutput(outputs[i])) {\n              if (extraCounter < numRemainder.lo) {\n                this.updateBalancesForEdict(\n                  balancesByOutput,\n                  balanceSheet,\n                  amountSplitPlus1,\n                  i,\n                  runeId,\n                );\n                extraCounter++;\n              } else {\n                this.updateBalancesForEdict(\n                  balancesByOutput,\n                  balanceSheet,\n                  amountSplit,\n                  i,\n                  runeId,\n                );\n              }\n            }\n          }\n        }\n      } else {\n        for (let i = 0; i < outputs.length; i++) {\n          if (this.isNonOpReturnOutput(outputs[i])) {\n            this.updateBalancesForEdict(\n              balancesByOutput,\n              balanceSheet,\n              edict.amount,\n              i,\n              runeId,\n            );\n          }\n        }\n      }\n\n      return false;\n    } else {\n      this.updateBalancesForEdict(\n        balancesByOutput,\n        balanceSheet,\n        edict.amount,\n        edictOutput,\n        runeId,\n      );\n      return false;\n    }\n  }\n\n  processEdicts(\n    balancesByOutput: Map<u32, BalanceSheet>,\n    balanceSheet: BalanceSheet,\n    outputs: Array<Output>,\n  ): bool {\n    const edicts = Edict.fromDeltaSeries(this.edicts);\n    for (let e = 0; e < edicts.length; e++) {\n      if (\n        this.processEdict(balancesByOutput, balanceSheet, edicts[e], outputs)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n  loadBalanceSheet(tx: RunesTransaction): BalanceSheet {\n    return BalanceSheet.concat(\n      tx.ins.map<BalanceSheet>((v: Input, i: i32, ary: Array<Input>) =>\n        BalanceSheet.load(\n          OUTPOINT_TO_RUNES.select(v.previousOutput().toArrayBuffer()),\n        ),\n      ),\n    );\n  }\n  saveBalanceSheet(\n    sheet: BalanceSheet,\n    txid: ArrayBuffer,\n    output: u32,\n    isCenotaph: bool,\n  ): void {\n    sheet.save(\n      OUTPOINT_TO_RUNES.select(OutPoint.from(txid, output).toArrayBuffer()),\n      isCenotaph,\n    );\n  }\n\n  handleLeftoverRunes(\n    balanceSheet: BalanceSheet,\n    balancesByOutput: Map<u32, BalanceSheet>,\n  ): void {\n    const unallocatedTo = this.unallocatedTo;\n\n    if (balancesByOutput.has(unallocatedTo)) {\n      balanceSheet.pipe(balancesByOutput.get(unallocatedTo));\n    } else {\n      balancesByOutput.set(unallocatedTo, balanceSheet);\n    }\n  }\n\n  process(\n    tx: RunesTransaction,\n    txid: ArrayBuffer,\n    height: u32,\n    txindex: u32,\n  ): Map<u32, BalanceSheet> {\n    let balanceSheet = this.loadBalanceSheet(tx);\n    const balancesByOutput = new Map<u32, BalanceSheet>();\n\n    this.mint(height, balanceSheet);\n    this.etch(<u64>height, <u32>txindex, balanceSheet, tx);\n\n    const isCenotaph = this.processEdicts(\n      balancesByOutput,\n      balanceSheet,\n      tx.outs,\n    );\n\n    this.handleLeftoverRunes(balanceSheet, balancesByOutput);\n\n    const runesToOutputs = balancesByOutput.keys();\n\n    for (let x = 0; x < runesToOutputs.length; x++) {\n      const sheet = balancesByOutput.get(runesToOutputs[x]);\n      this.saveBalanceSheet(sheet, txid, runesToOutputs[x], isCenotaph);\n    }\n    return balancesByOutput;\n  }\n}\n","import { Box } from \"metashrew-as/assembly/utils/box\";\nimport { u256, u128 } from \"as-bignum/assembly\";\nimport { RESERVED_NAME, TWENTY_SIX } from \"./indexer/constants\";\nimport { Edict } from \"./indexer/Edict\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\n\nexport function min<T>(a: T, b: T): T {\n  if (a > b) return b;\n  return a;\n}\n\nexport function padLeft(v: string, n: i32): string {\n  let result = \"\";\n  for (let i: i32 = 0; i < n - v.length; i++) {\n    result += \"0\";\n  }\n  return result + v;\n}\n\nexport function u128ToHex(v: u128): string {\n  return padLeft(v.hi.toString(16), 16) + padLeft(v.lo.toString(16), 16);\n}\n\nexport function fromU128Pair(lo: u128, hi: u128): u256 {\n  return new u256(lo.lo, lo.hi, hi.lo, hi.hi);\n}\n\nexport function inspectEdicts(ary: Array<Edict>): string {\n  return (\n    \"[\\n\" +\n    ary\n      .map<string>((v: Edict, i: i32, ary: Array<Edict>) => \"  \" + v.toString())\n      .join(\"\\n\") +\n    \"\\n]\"\n  );\n}\n\nexport function stripNullRight(data: ArrayBuffer): ArrayBuffer {\n  const box = Box.from(data);\n  while (box.len > 0) {\n    if (load<u8>(box.start + box.len - <usize>1) === 0x00) {\n      box.len--;\n    } else break;\n  }\n  return box.toArrayBuffer();\n}\n\nexport function isEqualArrayBuffer(a: ArrayBuffer, b: ArrayBuffer): bool {\n  if (a.byteLength !== b.byteLength) return false;\n  return (\n    memory.compare(changetype<usize>(a), changetype<usize>(b), a.byteLength) ==\n    0\n  );\n}\n\nexport function toPrimitive<T>(v: u128): T {\n  return <T>v.lo;\n}\n\nexport function isNullPtr<T>(v: T): bool {\n  return changetype<usize>(v) == 0;\n}\n\nexport function fieldTo<T>(data: Array<u128>): T {\n  return toPrimitive<T>(data[0]);\n}\n\nexport function fieldToName(data: u128): string {\n  let v = data + u128.from(1);\n  let str = \"\";\n  while (!v.isZero()) {\n    let y = (v % TWENTY_SIX).toU32();\n    if (y == 0) y = 26;\n    str = String.fromCharCode(64 + y) + str;\n    v--;\n    v = v / TWENTY_SIX;\n  }\n  return str;\n}\n\nexport function nameToArrayBuffer(name: string): ArrayBuffer {\n  let y = u128.from(0);\n  let x = u128.from(0);\n  for (let i = 0; i < name.length; i++) {\n    const char = name.charCodeAt(i) - 64;\n    y = u128.from(char == 26 ? 0 : char);\n    x *= TWENTY_SIX;\n    x += y;\n  }\n  x--;\n  return toArrayBuffer(x);\n}\n\nexport function fieldToU128(data: Array<u128>): u128 {\n  if (data.length === 0) return u128.from(0);\n  return data[0];\n}\n\nexport function toArrayBuffer(data: u128): ArrayBuffer {\n  const bytes = data.toBytes();\n  return changetype<Uint8Array>(bytes).buffer;\n}\n\nexport function fieldToArrayBuffer(data: Array<u128>): ArrayBuffer {\n  return Box.concat(\n    data.map((v: u128, i: i32, ary: Array<u128>) => Box.from(toArrayBuffer(v))),\n  );\n}\n\nexport function fromBox(data: Box): u128 {\n  return u128.fromBytesLE(\n    changetype<u8[]>(Uint8Array.wrap(data.toArrayBuffer())),\n  );\n}\n\nexport function fromArrayBuffer(data: ArrayBuffer): u128 {\n  if (data.byteLength === 0) return u128.from(0);\n  const result = u128.fromBytes(changetype<u8[]>(Uint8Array.wrap(data)));\n  return result;\n}\n\nexport function getReservedNameFor(block: u64, txindex: u32): u128 {\n  const add = (u128.from(block) << 32) | u128.from(txindex);\n  return RESERVED_NAME + add;\n}\n","export function bswap<T extends number>(value: T): T {\n  if (isInteger<T>()) {\n    if (sizeof<T>() == 1) {\n      return value;\n    }\n    if (sizeof<T>() == 2) {\n      return <T>(<u16>value << 8 | (<u16>value >> 8));\n    }\n    if (sizeof<T>() == 4) {\n      return <T>(\n        rotl(<u32>value & 0xFF00FF00, 8) |\n        rotr(<u32>value & 0x00FF00FF, 8)\n      );\n    }\n    if (sizeof<T>() == 8) {\n      let a = (<u64>value >> 8) & 0x00FF00FF00FF00FF;\n      let b = (<u64>value & 0x00FF00FF00FF00FF) << 8;\n      let v = a | b;\n\n      a = (v >>> 16) & 0x0000FFFF0000FFFF;\n      b = (v & 0x0000FFFF0000FFFF) << 16;\n\n      return <T>rotr(a | b, 32);\n    }\n  }\n  ERROR(\"Unsupported generic type\");\n}\n","import { HEIGHT_TO_TRANSACTION_IDS } from \"./constants\";\nimport { toArrayBuffer } from \"../utils\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { Box } from \"metashrew-as/assembly/utils\";\n\nexport class RuneId {\n  public block: u128;\n  public tx: u128;\n  constructor(block: u64, tx: u32) {\n    this.block = u128.fromU64(block);\n    this.tx = u128.fromU32(tx);\n  }\n  txid(): ArrayBuffer {\n    return HEIGHT_TO_TRANSACTION_IDS.selectValue<u32>(<u32>this.block.toU64())\n      .selectIndex(this.tx.toU32())\n      .get();\n  }\n  toBytes(): ArrayBuffer {\n    let bytes = this.block.toBytes();\n    bytes = bytes.concat(this.tx.toBytes());\n    return changetype<Uint8Array>(bytes).buffer;\n  }\n  inspect(): string {\n    return this.block.toString() + \":\" + this.tx.toString();\n  }\n  static fromBytesU128(ary: ArrayBuffer): RuneId {\n    return RuneId.fromBytes(ary);\n  }\n\n  static fromBytes(ary: ArrayBuffer): RuneId {\n    const _ary = Uint8Array.wrap(ary);\n\n    const parsed = _ary.reduce<Array<u8>>((acc, c, i, init) => {\n      acc[i] = c;\n      return acc;\n    }, new Array<u8>(_ary.byteLength));\n    const block = u128.fromBytes(parsed.slice(0, 16)).toU64();\n    const tx = u128.fromBytes(parsed.slice(16)).toU32();\n    return new RuneId(block, tx);\n  }\n  static fromU128(v: u128): RuneId {\n    const block = v.hi;\n    const tx = <u32>v.lo;\n    return new RuneId(block, tx);\n  }\n}\n","import { IndexPointer } from \"metashrew-as/assembly/indexer/tables\";\nimport { Block } from \"metashrew-as/assembly/blockdata/block\";\nimport { RunesTransaction } from \"./RunesTransaction\";\nimport { HEIGHT_TO_TRANSACTION_IDS } from \"./constants\";\n\n@final\nexport class RunesBlock extends Block {\n  saveTransactions(height: u32): void {\n    const ptr = HEIGHT_TO_TRANSACTION_IDS.selectValue<u32>(height);\n    for (let i: i32 = 0; i < this.transactions.length; i++) {\n      ptr.append(this.getTransaction(i).txid());\n    }\n  }\n  @inline\n  static from(block: Block): RunesBlock {\n    return changetype<RunesBlock>(block);\n  }\n  @inline\n  getTransaction(index: i32): RunesTransaction {\n    return changetype<RunesTransaction>(this.transactions[index]);\n  }\n}\n","import {\n  Transaction,\n  Output,\n  OutPoint,\n} from \"metashrew-as/assembly/blockdata/transaction\";\nimport { scriptParse } from \"metashrew-as/assembly/utils/yabsp\";\nimport { Box } from \"metashrew-as/assembly/utils/box\";\nimport { RunestoneMessage } from \"./RunestoneMessage\";\nimport { RUNESTONE_TAG, OP_RETURN } from \"./constants\";\n\nclass TagOutput {\n  runestone: i32;\n  constructor() {\n    this.runestone = -1;\n  }\n}\n\n@final\nexport class RunesTransaction extends Transaction {\n  runestoneOutputIndex(): i32 {\n    for (let i = 0; i < this.outs.length; i++) {\n      if (load<u16>(this.outs[i].script.start) === RUNESTONE_TAG) return i;\n    }\n    return -1;\n  }\n\n  runestoneOutput(): Output | null {\n    const i = this.runestoneOutputIndex();\n    if (i === -1) return null;\n    else return this.outs[i];\n  }\n  defaultOutput(): i32 {\n    for (let i = 0; i < this.outs.length; i++) {\n      if (load<u8>(this.outs[i].script.start) !== OP_RETURN) return i;\n    }\n    return -1;\n  }\n  static from(tx: Transaction): RunesTransaction {\n    return changetype<RunesTransaction>(tx);\n  }\n  runestone(): RunestoneMessage {\n    const runestoneOutputIndex = this.runestoneOutputIndex();\n    if (runestoneOutputIndex !== -1) {\n      const runestoneOutput = this.outs[runestoneOutputIndex];\n      const parsed = scriptParse(runestoneOutput.script).slice(2);\n      if (\n        parsed.findIndex((v: Box, i: i32, ary: Array<Box>) => {\n          return v.start === usize.MAX_VALUE;\n        }) !== -1\n      )\n        return changetype<RunestoneMessage>(0); // non-data push: cenotaph\n      const payload = Box.concat(parsed);\n      const message = RunestoneMessage.parse(payload, this.defaultOutput());\n      if (changetype<usize>(message) === 0)\n        return changetype<RunestoneMessage>(0);\n\n      //process message here\n      return message;\n    }\n    return changetype<RunestoneMessage>(0);\n  }\n  outpoint(vout: i32): ArrayBuffer {\n    return OutPoint.from(this.txid(), <u32>vout).toArrayBuffer();\n  }\n}\n","import { Box } from \"metashrew-as/assembly/utils/box\";\nimport { u128 } from \"as-bignum/assembly\";\nexport function readULEB128ToU128(buf: Box, to: u128): usize {\n  const slice = buf.sliceFrom(0);\n  let shift: i32 = 0;\n  let result: u128 = u128.from(0);\n  let byte: u8 = 0;\n  if (slice.len === 0) {\n    return 0;\n  }\n  while (true) {\n    byte = load<u8>(slice.start);\n    if (slice.len === 0) return usize.MAX_VALUE;\n    slice.shrinkFront(1);\n    result |= u128.from(byte & 0x7f) << shift;\n    if ((byte & 0x80) === 0) break;\n    shift += 7;\n  }\n  to.hi = result.hi;\n  to.lo = result.lo;\n  return slice.start - buf.start;\n}\n","import { IndexPointer } from \"metashrew-as/assembly/indexer/tables\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { fromArrayBuffer } from \"../utils\";\nimport { RuneId } from \"./RuneId\";\nimport { console } from \"metashrew-as/assembly/utils\";\n\nexport class BalanceSheet {\n  public runes: Array<ArrayBuffer>;\n  public balances: Array<u128>;\n  public index: Map<string, i32>;\n  constructor() {\n    this.index = new Map<string, i32>();\n    this.balances = new Array<u128>(0);\n    this.runes = new Array<ArrayBuffer>(0);\n  }\n  inspect(): string {\n    let base = \"runes: [\\n\";\n    for (let i = 0; i < this.runes.length; i++) {\n      base += \"  \" + RuneId.fromBytes(this.runes[i]).inspect() + \"\\n\";\n    }\n\n    base += \"]\\nbalances: [\\n\";\n    for (let i = 0; i < this.balances.length; i++)\n      base += \"  \" + this.balances[i].toString() + \"\\n\";\n    base += \"]\";\n\n    return base;\n  }\n  static fromPairs(\n    runes: Array<ArrayBuffer>,\n    balances: Array<u128>,\n  ): BalanceSheet {\n    const balanceSheet = new BalanceSheet();\n    for (let i = 0; i < runes.length; i++) {\n      balanceSheet.set(runes[i], balances[i]);\n    }\n    return balanceSheet;\n  }\n  @inline\n  getIndex(rune: ArrayBuffer): i32 {\n    if (this.has(rune)) return this.index.get(changetype<string>(rune));\n    return -1;\n  }\n  @inline\n  has(rune: ArrayBuffer): bool {\n    return this.index.has(changetype<string>(rune));\n  }\n  get(rune: ArrayBuffer): u128 {\n    const i = this.getIndex(rune);\n    if (i !== -1) return this.balances[i];\n    return u128.from(0);\n  }\n  set(rune: ArrayBuffer, v: u128): void {\n    if (this.has(rune)) {\n      const i = this.getIndex(rune);\n      this.balances[i] = v;\n    } else {\n      this.index.set(changetype<string>(rune), this.runes.length);\n      this.runes.push(rune);\n      this.balances.push(v);\n    }\n  }\n  increase(rune: ArrayBuffer, v: u128): void {\n    let record = this.get(rune);\n    this.set(rune, v + record);\n  }\n  decrease(rune: ArrayBuffer, v: u128): boolean {\n    const record = this.get(rune);\n    if (record < v) return false;\n    this.set(rune, record - v);\n    return true;\n  }\n  pipe(b: BalanceSheet): void {\n    for (let i = 0; i < this.runes.length; i++) {\n      b.increase(this.runes[i], this.balances[i]);\n    }\n  }\n  static merge(a: BalanceSheet, b: BalanceSheet): BalanceSheet {\n    const balanceSheet = new BalanceSheet();\n    a.pipe(balanceSheet);\n    b.pipe(balanceSheet);\n    return balanceSheet;\n  }\n  static concat(ary: Array<BalanceSheet>): BalanceSheet {\n    return ary.reduce<BalanceSheet>(\n      (r: BalanceSheet, v: BalanceSheet, i: i32, ary: Array<BalanceSheet>) => {\n        return BalanceSheet.merge(r, v);\n      },\n      new BalanceSheet(),\n    );\n  }\n  save(ptr: IndexPointer, isCenotaph: bool = false): void {\n    const runesPtr = ptr.keyword(\"/runes\");\n    const balancesPtr = ptr.keyword(\"/balances\");\n\n    for (let i = 0; i < this.runes.length; i++) {\n      if (this.balances[i] != u128.Zero && !isCenotaph) {\n        runesPtr.append(this.runes[i]);\n\n        const buf = changetype<Uint8Array>(this.balances[i].toBytes()).buffer;\n        balancesPtr.append(buf);\n      }\n    }\n  }\n  static load(ptr: IndexPointer): BalanceSheet {\n    const runesPtr = ptr.keyword(\"/runes\");\n    const balancesPtr = ptr.keyword(\"/balances\");\n    const length = runesPtr.lengthKey().getValue<u32>();\n    const result = new BalanceSheet();\n\n    for (let i: u32 = 0; i < length; i++) {\n      result.set(\n        runesPtr.selectIndex(i).get(),\n        fromArrayBuffer(balancesPtr.selectIndex(i).get()),\n      );\n    }\n    return result;\n  }\n}\n","import { u128 } from \"as-bignum/assembly\";\nimport { RuneId } from \"./RuneId\";\n\nexport class Edict {\n  public block: u128;\n  public transactionIndex: u128;\n  public amount: u128;\n  public output: u128;\n  constructor(block: u128, transactionIndex: u128, amount: u128, output: u128) {\n    this.block = block;\n    this.transactionIndex = transactionIndex;\n    this.amount = amount;\n    this.output = output;\n  }\n  runeId(): RuneId {\n    return new RuneId(this.block.lo, <u32>this.transactionIndex.lo);\n  }\n  static zero(): Edict {\n    return new Edict(u128.from(0), u128.from(0), u128.from(0), u128.from(0));\n  }\n  static diff(previous: Edict, values: StaticArray<u128>): Edict {\n    return new Edict(\n      previous.block + values[0],\n      !values[0].isZero() ? values[1] : previous.transactionIndex + values[1],\n      values[2],\n      values[3],\n    );\n  }\n  static fromDeltaSeries(deltas: Array<StaticArray<u128>>): Array<Edict> {\n    let last = Edict.zero();\n    const result = new Array<Edict>(0);\n    // deltas.sort((a: StaticArray<u128>, b: StaticArray<u128>): i32 => {\n    //   const left = fromU128Pair(a[0], a[1]);\n    //   const right = fromU128Pair(b[0], b[1]);\n    //   if (left < right) return -1;\n    //   else if (left == right) return 0;\n    //   else return 1;\n    // });\n    for (let i: i32 = 0; i < deltas.length; i++) {\n      last = Edict.diff(last, deltas[i]);\n      result.push(last);\n    }\n    return result;\n  }\n  toString(): string {\n    return (\n      \"Edict {\\n\" +\n      \"   runeId: \" +\n      this.runeId().inspect() +\n      \",\\n  amount: \" +\n      this.amount.toString() +\n      \",\\n  output: \" +\n      this.output.toString() +\n      \"\\n}\"\n    );\n  }\n}\n","import { Box } from \"metashrew-as/assembly/utils/box\";\nimport { input } from \"metashrew-as/assembly/indexer/index\";\nimport { BalanceSheet } from \"metashrew-runes/assembly/indexer/BalanceSheet\";\nimport { RuneId } from \"metashrew-runes/assembly/indexer/RuneId\";\nimport {\n  OUTPOINT_TO_RUNES,\n  HEIGHT_TO_TRANSACTION_IDS,\n  RUNE_ID_TO_ETCHING,\n  DIVISIBILITY,\n  OUTPOINT_TO_HEIGHT,\n  SPACERS,\n  SYMBOL,\n} from \"metashrew-runes/assembly/indexer/constants\";\nimport { ProtoruneTable } from \"../indexer/tables/protorune\";\nimport { OutPoint, Output } from \"metashrew-as/assembly/blockdata/transaction\";\nimport { arrayBufferToArray } from \"metashrew-spendables/assembly/indexer\";\nimport { OUTPOINT_TO_OUTPUT } from \"metashrew-spendables/assembly/tables\";\nimport { metashrew_runes as protobuf } from \"metashrew-runes/assembly/proto/metashrew-runes\";\nimport { protorune as protobuf_protorune } from \"../proto/protorune\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { fromArrayBuffer, fieldToName } from \"metashrew-runes/assembly/utils\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\nimport { encodeHexFromBuffer } from \"metashrew-as/assembly/utils\";\n\nexport function txindexForOutpoint(outpoint: ArrayBuffer): u32 {\n  const box = Box.from(outpoint);\n  box.len -= 4;\n  const txid = box.toArrayBuffer();\n  const ptr = HEIGHT_TO_TRANSACTION_IDS.selectValue<u32>(\n    OUTPOINT_TO_HEIGHT.select(outpoint).getValue<u32>(),\n  );\n  const length = ptr.length();\n  for (let i = 0; i < <i32>length; i++) {\n    if (\n      memory.compare(\n        changetype<usize>(txid),\n        changetype<usize>(ptr.selectIndex(i).get()),\n        txid.byteLength,\n      ) === 0\n    )\n      return i;\n  }\n  return ~0;\n}\n\nexport function balanceSheetToProtobuf(\n  sheet: BalanceSheet,\n): protobuf.BalanceSheet {\n  const runes = sheet.runes.reduce<Array<protobuf.Rune>>((a, d, i, init) => {\n    const _runeId = RuneId.fromBytesU128(d);\n    const name = RUNE_ID_TO_ETCHING.select(d).get();\n    const spacers = SPACERS.select(name);\n    const divisibility = <u32>DIVISIBILITY.select(name).getValue<u8>();\n    const rune = new protobuf.Rune();\n    const runeId = new protobuf.RuneId();\n    runeId.height = <u32>_runeId.block.toU64();\n    runeId.txindex = _runeId.tx.toU32();\n    rune.runeId = runeId;\n    rune.name = Uint8Array.wrap(\n      String.UTF8.encode(fieldToName(fromArrayBuffer(name))),\n    ).reduce<Array<u8>>((a, d) => {\n      a.push(d);\n      return a;\n    }, new Array<u8>());\n    rune.divisibility = divisibility;\n    rune.symbol = <u32>SYMBOL.select(name).getValue<u8>();\n    rune.spacers = SPACERS.select(name).getValue<u32>();\n    a.push(rune);\n    return a;\n  }, new Array<protobuf.Rune>());\n  const balances = sheet.balances.map<Array<u8>>((d, i, ary: Array<u128>) => {\n    return d.toBytes(true);\n  });\n  const balanceSheet = new protobuf.BalanceSheet();\n  for (let i = 0; i < balances.length; i++) {\n    const entry = new protobuf.BalanceSheetItem();\n    entry.rune = runes[i];\n    entry.balance = balances[i];\n    balanceSheet.entries.push(entry);\n  }\n  return balanceSheet;\n}\n\nexport function balanceSheetToProtobufForProtocol(\n  sheet: BalanceSheet,\n  table: ProtoruneTable,\n): protobuf.BalanceSheet {\n  const runes = new Array<protobuf.Rune>();\n  for (let i = 0; i < sheet.runes.length; i++) {\n    const d = sheet.runes[i];\n    const _runeId = RuneId.fromBytesU128(d);\n    const name = table.RUNE_ID_TO_ETCHING.select(d).get();\n    const spacers = table.SPACERS.select(name);\n    const divisibility = <u32>table.DIVISIBILITY.select(name).getValue<u8>();\n    const rune = new protobuf.Rune();\n    const runeId = new protobuf.RuneId();\n    runeId.height = <u32>_runeId.block.toU64();\n    runeId.txindex = _runeId.tx.toU32();\n    rune.runeId = runeId;\n    rune.name = Uint8Array.wrap(\n      String.UTF8.encode(fieldToName(fromArrayBuffer(name))),\n    ).reduce<Array<u8>>((a, d) => {\n      a.push(d);\n      return a;\n    }, new Array<u8>());\n    rune.divisibility = divisibility;\n    rune.symbol = <u32>table.SYMBOL.select(name).getValue<u8>();\n    rune.spacers = table.SPACERS.select(name).getValue<u32>();\n    runes.push(rune);\n  }\n  const balances = sheet.balances.map<Array<u8>>((d, i, ary: Array<u128>) => {\n    return d.toBytes(true);\n  });\n  const balanceSheet = new protobuf.BalanceSheet();\n  for (let i = 0; i < balances.length; i++) {\n    const entry = new protobuf.BalanceSheetItem();\n    entry.rune = runes[i];\n    entry.balance = balances[i];\n    balanceSheet.entries.push(entry);\n  }\n  return balanceSheet;\n}\nexport function outpointBase(\n  inp: protobuf.Outpoint,\n): protobuf.OutpointResponse {\n  const txid = changetype<Uint8Array>(inp.txid).buffer;\n  const pos = inp.vout;\n  const outpoint = OutPoint.from(txid, pos).toArrayBuffer();\n\n  const op = OUTPOINT_TO_RUNES.select(outpoint);\n  const output = new Output(\n    Box.from(OUTPOINT_TO_OUTPUT.select(outpoint).get()),\n  );\n  const balanceSheet = balanceSheetToProtobuf(BalanceSheet.load(op));\n\n  const message = new protobuf.OutpointResponse();\n  message.outpoint = inp;\n  message.output.script = arrayBufferToArray(output.script.toArrayBuffer());\n  message.output.value = output.value;\n  message.balances = balanceSheet;\n  message.height = OUTPOINT_TO_HEIGHT.select(outpoint).getValue<u32>();\n  message.txindex = txindexForOutpoint(outpoint);\n  return message;\n}\nexport function outpointBaseForProtocol(\n  inp: protobuf_protorune.OutpointWithProtocol,\n): protobuf.OutpointResponse {\n  const txid = changetype<Uint8Array>(inp.txid).buffer;\n  const pos = inp.vout;\n  const outpoint = OutPoint.from(txid, pos).toArrayBuffer();\n  const table = ProtoruneTable.for_str(\n    String.UTF8.decode(changetype<Uint8Array>(inp.protocol).buffer),\n  );\n  const op = table.OUTPOINT_TO_RUNES.select(outpoint);\n  const output = new Output(\n    Box.from(OUTPOINT_TO_OUTPUT.select(outpoint).get()),\n  );\n  const balanceSheet = balanceSheetToProtobuf(BalanceSheet.load(op));\n\n  const message = new protobuf.OutpointResponse();\n  message.outpoint = new protobuf.Outpoint();\n  message.outpoint.txid = inp.txid;\n  message.outpoint.vout = inp.vout;\n  message.output.script = arrayBufferToArray(output.script.toArrayBuffer());\n  message.output.value = output.value;\n  message.balances = balanceSheet;\n  message.height = OUTPOINT_TO_HEIGHT.select(outpoint).getValue<u32>();\n  message.txindex = txindexForOutpoint(outpoint);\n  return message;\n}\n\nexport function outpoint(): ArrayBuffer {\n  const _input = input().slice(4);\n  const inp = protobuf.Outpoint.decode(_input);\n  return outpointBase(inp).encode();\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait32(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait64(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    let index: usize = 0;\n    let total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare let __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  let w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest == src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n;\n    store<u8>(dest, c);\n    store<u8>(dend - 1, c);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend - 2, c);\n    store<u8>(dend - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n;\n    store<u32>(dest, c32);\n    store<u32>(dend - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend - 12, c32);\n    store<u32>(dend - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend - 28, c32);\n    store<u32>(dend - 24, c32);\n    store<u32>(dend - 20, c32);\n    store<u32>(dend - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","import { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { ArrayBuffer } from \"./arraybuffer\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \"./util/error\";\n\n// TODO: there is probably a smarter way to check byteOffset for accesses larger than 1 byte\n\nexport class DataView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  constructor(\n    buffer: ArrayBuffer,\n    byteOffset: i32 = 0,\n    byteLength: i32 = buffer.byteLength\n  ) {\n    if (\n      i32(<u32>byteLength > <u32>BLOCK_MAXSIZE) |\n      i32(<u32>byteOffset + byteLength > <u32>buffer.byteLength)\n    ) throw new RangeError(E_INVALIDLENGTH);\n    this.buffer = buffer; // links\n    let dataStart = changetype<usize>(buffer) + <usize>byteOffset;\n    this.dataStart = dataStart;\n    this.byteLength = byteLength;\n  }\n\n  getFloat32(byteOffset: i32, littleEndian: bool = false): f32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    return littleEndian\n      ? load<f32>(this.dataStart + <usize>byteOffset)\n      : reinterpret<f32>(bswap<u32>(load<u32>(this.dataStart + <usize>byteOffset)));\n  }\n\n  getFloat64(byteOffset: i32, littleEndian: bool = false): f64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    return littleEndian\n      ? load<f64>(this.dataStart + <usize>byteOffset)\n      : reinterpret<f64>(bswap<u64>(load<u64>(this.dataStart + <usize>byteOffset)));\n  }\n\n  getInt8(byteOffset: i32): i8 {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>byteOffset);\n  }\n\n  getInt16(byteOffset: i32, littleEndian: bool = false): i16 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result: i16 = load<i16>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u16>(result);\n  }\n\n  getInt32(byteOffset: i32, littleEndian: bool = false): i32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result: i32 = load<i32>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u32>(result);\n  }\n\n  getUint8(byteOffset: i32): u8 {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>byteOffset);\n  }\n\n  getUint16(byteOffset: i32, littleEndian: bool = false): u16 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result: u16 = load<u16>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u16>(result);\n  }\n\n  getUint32(byteOffset: i32, littleEndian: bool = false): u32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result: u32 = load<u32>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u32>(result);\n  }\n\n  setFloat32(byteOffset: i32, value: f32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    if (littleEndian) store<f32>(this.dataStart + <usize>byteOffset, value);\n    else store<u32>(this.dataStart + <usize>byteOffset, bswap<u32>(reinterpret<u32>(value)));\n  }\n\n  setFloat64(byteOffset: i32, value: f64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    if (littleEndian) store<f64>(this.dataStart + <usize>byteOffset, value);\n    else store<u64>(this.dataStart + <usize>byteOffset, bswap<u64>(reinterpret<u64>(value)));\n  }\n\n  setInt8(byteOffset: i32, value: i8): void {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>byteOffset, value);\n  }\n\n  setInt16(byteOffset: i32, value: i16, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\n  }\n\n  setInt32(byteOffset: i32, value: i32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\n  }\n\n  setUint8(byteOffset: i32, value: u8): void {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>byteOffset, value);\n  }\n\n  setUint16(byteOffset: i32, value: u16, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\n  }\n\n  setUint32(byteOffset: i32, value: u32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\n  }\n\n  // Non-standard additions that make sense in WebAssembly, but won't work in JS:\n\n  getInt64(byteOffset: i32, littleEndian: bool = false): i64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result: i64 = load<i64>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u64>(result);\n  }\n\n  getUint64(byteOffset: i32, littleEndian: bool = false): u64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result = load<u64>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u64>(result);\n  }\n\n  setInt64(byteOffset: i32, value: i64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\n  }\n\n  setUint64(byteOffset: i32, value: u64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\n  }\n\n  toString(): string {\n    return \"[object DataView]\";\n  }\n}\n","import {\n  ETCHINGS,\n  ETCHING_TO_RUNE_ID,\n  SPACERS,\n  DIVISIBILITY,\n  SYMBOL,\n} from \"metashrew-runes/assembly/indexer/constants\";\nimport { metashrew_runes as protobuf } from \"metashrew-runes/assembly/proto/metashrew-runes\";\nimport { input } from \"metashrew-as/assembly/indexer\";\nimport { RuneId } from \"metashrew-runes/assembly/indexer/RuneId\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { fromArrayBuffer, fieldToName } from \"metashrew-runes/assembly/utils\";\n\nexport function runes(): ArrayBuffer {\n  const inp = protobuf.PaginationInput.decode(input().slice(4));\n  const start = inp.start;\n  const end = inp.end;\n  let _list: Array<ArrayBuffer> = new Array<ArrayBuffer>(0);\n  if (inp.end == 0) {\n    _list = ETCHINGS.getList();\n  } else {\n    for (let i = start; i < end; i++) {\n      _list.push(ETCHINGS.selectIndex(i).get());\n    }\n  }\n  const list = _list.map<protobuf.Rune>((d) => {\n    const name = fromArrayBuffer(d);\n    const rune = new protobuf.Rune();\n    const runeId = new protobuf.RuneId();\n    const _runeId = RuneId.fromBytesU128(ETCHING_TO_RUNE_ID.select(d).get());\n\n    runeId.height = <u32>_runeId.block.toU64();\n    runeId.txindex = _runeId.tx.toU32();\n\n    rune.runeId = runeId;\n    rune.name = Uint8Array.wrap(String.UTF8.encode(fieldToName(name))).reduce<\n      Array<u8>\n    >((a, d) => {\n      a.push(d);\n      return a;\n    }, new Array<u8>());\n    rune.divisibility = <u32>DIVISIBILITY.select(d).getValue<u8>();\n    rune.symbol = <u32>SYMBOL.select(d).getValue<u8>();\n    rune.spacers = SPACERS.select(d).getValue<u32>();\n    return rune;\n  });\n  const message = new protobuf.RunesResponse();\n  message.runes = list;\n\n  return message.encode();\n}\n","import { SpendablesIndex } from \"metashrew-spendables/assembly/indexer\";\nimport {\n  balanceSheetToProtobuf,\n  outpointBase,\n  outpointBaseForProtocol,\n} from \"./outpoint\";\nimport { ProtoruneBalanceSheet } from \"../indexer/ProtoruneBalanceSheet\";\nimport { metashrew_runes as protobuf } from \"metashrew-runes/assembly/proto/metashrew-runes\";\nimport { protorune, protorune as protoruneProtobuf } from \"../proto/protorune\";\nimport { Output } from \"metashrew-as/assembly/blockdata/transaction\";\nimport { Box } from \"metashrew-as/assembly/utils/box\";\nimport { parsePrimitive } from \"metashrew-as/assembly/utils/utils\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\nimport { input } from \"metashrew-as/assembly/indexer\";\nimport { OUTPOINT_TO_RUNES } from \"metashrew-runes/assembly/indexer/constants\";\nimport { ProtoruneTable } from \"../indexer/tables/protorune\";\n\nexport function wallet_test(): ArrayBuffer {\n  const address = String.UTF8.encode(\n    \"bc1pl35wn7k578zg55exz799m6v6pnu563wg34t7yg7jsnmxpmvw5fdscdsmvu\",\n  );\n  const outpoint =\n    \"a92ba4aab6ac3fe26667665ca6bcd75eff2cd05963ab665d259a31113ae831a401000000\";\n\n  new SpendablesIndex().findOutpointsForAddress(address);\n\n  return new ArrayBuffer(0);\n}\n\nexport function runesbyaddress(): ArrayBuffer {\n  const _address = protobuf.WalletRequest.decode(input().slice(4)).wallet;\n  const address = changetype<Uint8Array>(_address).buffer;\n\n  const _outpoints = new SpendablesIndex().findOutpointsForAddress(address);\n  const outpoints = new Array<protobuf.OutpointResponse>();\n  const balanceSheets = new Array<ProtoruneBalanceSheet>();\n  for (let i = 0; i < _outpoints.length; i++) {\n    const inp = new protobuf.Outpoint();\n    inp.txid = changetype<Array<u8>>(\n      Uint8Array.wrap(_outpoints[i].slice(0, 32)),\n    );\n    inp.vout = parsePrimitive<u32>(Box.from(_outpoints[i].slice(32)));\n    const op = outpointBase(inp);\n    if (op.balances.entries.length == 0) {\n      continue;\n    }\n    balanceSheets.push(\n      ProtoruneBalanceSheet.load(OUTPOINT_TO_RUNES.select(_outpoints[i])),\n    );\n    outpoints.push(op);\n  }\n\n  const message = new protobuf.WalletResponse();\n  message.outpoints = outpoints;\n  message.balances = balanceSheetToProtobuf(\n    balanceSheets.reduce<ProtoruneBalanceSheet>(\n      (\n        r: ProtoruneBalanceSheet,\n        v: ProtoruneBalanceSheet,\n        i: i32,\n        ary: Array<ProtoruneBalanceSheet>,\n      ) => {\n        return ProtoruneBalanceSheet.merge(r, v);\n      },\n      new ProtoruneBalanceSheet(),\n    ),\n  );\n\n  return message.encode();\n}\n\nexport function protorunesbyaddress(): ArrayBuffer {\n  const request = protoruneProtobuf.ProtorunesWalletRequest.decode(\n    input().slice(4),\n  );\n  const address = changetype<Uint8Array>(request.wallet).buffer;\n  const protocol_tag = changetype<Uint8Array>(request.protocol_tag).buffer;\n  const protorune_pointer = ProtoruneTable.for_str(\n    String.UTF8.decode(protocol_tag),\n  );\n\n  const _outpoints = new SpendablesIndex().findOutpointsForAddress(address);\n  const outpoints = new Array<protobuf.OutpointResponse>();\n  const balanceSheets = new Array<ProtoruneBalanceSheet>();\n  for (let i = 0; i < _outpoints.length; i++) {\n    const inp = new protoruneProtobuf.OutpointWithProtocol();\n    inp.txid = changetype<Array<u8>>(\n      Uint8Array.wrap(_outpoints[i].slice(0, 32)),\n    );\n    inp.vout = parsePrimitive<u32>(Box.from(_outpoints[i].slice(32)));\n    inp.protocol = request.protocol_tag;\n    const op = outpointBaseForProtocol(inp);\n    if (op.balances.entries.length == 0) {\n      continue;\n    }\n    balanceSheets.push(\n      ProtoruneBalanceSheet.load(\n        protorune_pointer.OUTPOINT_TO_RUNES.select(_outpoints[i]),\n      ),\n    );\n    outpoints.push(op);\n  }\n\n  const message = new protobuf.WalletResponse();\n  message.outpoints = outpoints;\n  message.balances = balanceSheetToProtobuf(\n    balanceSheets.reduce(\n      (\n        r: ProtoruneBalanceSheet,\n        v: ProtoruneBalanceSheet,\n        i: i32,\n        ary: Array<ProtoruneBalanceSheet>,\n      ) => {\n        return ProtoruneBalanceSheet.merge(r, v);\n      },\n      new ProtoruneBalanceSheet(),\n    ),\n  );\n\n  return message.encode();\n}\n","import { IndexPointer } from \"metashrew-as/assembly/indexer/tables\";\nimport { AtomicTransaction } from \"metashrew-as/assembly/indexer/atomic\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { fromArrayBuffer } from \"metashrew-runes/assembly/utils\";\nimport { RuneId } from \"metashrew-runes/assembly/indexer/RuneId\";\nimport { BalanceSheet } from \"metashrew-runes/assembly/indexer/BalanceSheet\";\nimport { console } from \"metashrew-as/assembly/utils\";\nimport { encodeHexFromBuffer } from \"metashrew-as/assembly/utils/hex\";\n\nexport class ProtoruneBalanceSheet extends BalanceSheet {\n  static fromPairs(\n    runes: Array<ArrayBuffer>,\n    balances: Array<u128>,\n  ): ProtoruneBalanceSheet {\n    return ProtoruneBalanceSheet.from(BalanceSheet.fromPairs(runes, balances));\n  }\n  static merge(\n    a: ProtoruneBalanceSheet,\n    b: ProtoruneBalanceSheet,\n  ): ProtoruneBalanceSheet {\n    return ProtoruneBalanceSheet.from(\n      BalanceSheet.merge(\n        changetype<BalanceSheet>(a),\n        changetype<BalanceSheet>(b),\n      ),\n    );\n  }\n  static concat(ary: Array<ProtoruneBalanceSheet>): ProtoruneBalanceSheet {\n    return ProtoruneBalanceSheet.from(\n      BalanceSheet.concat(\n        ary.map<BalanceSheet>(\n          (\n            v: ProtoruneBalanceSheet,\n            i: i32,\n            ary: Array<ProtoruneBalanceSheet>,\n          ) => changetype<BalanceSheet>(v),\n        ),\n      ),\n    );\n  }\n  saveToAtomicTx(ptr: IndexPointer, tx: AtomicTransaction): void {\n    const runesPtr = ptr.keyword(\"/runes\");\n    const balancesPtr = ptr.keyword(\"/balances\");\n\n    for (let i = 0; i < this.runes.length; i++) {\n      tx.appendIndexPointerList(runesPtr, this.runes[i]);\n\n      const buf = changetype<Uint8Array>(this.balances[i].toBytes()).buffer;\n      tx.appendIndexPointerList(balancesPtr, buf);\n    }\n  }\n\n  static loadFromAtomicTx(\n    ptr: IndexPointer,\n    tx: AtomicTransaction,\n    inspect: bool = false,\n  ): ProtoruneBalanceSheet {\n    const runesPtr = ptr.keyword(\"/runes\");\n    const balancesPtr = ptr.keyword(\"/balances\");\n\n    const length = tx.getValue<u32>(runesPtr.lengthKey().unwrap());\n    const result = new ProtoruneBalanceSheet();\n\n    for (let i: u32 = 0; i < length; i++) {\n      result.set(\n        tx.get(runesPtr.selectIndex(i).unwrap()),\n        fromArrayBuffer(tx.get(balancesPtr.selectIndex(i).unwrap())),\n      );\n    }\n    return result;\n  }\n\n  clearAndSave(ptr: IndexPointer): void {\n    const runesPtr = ptr.keyword(\"/runes\").lengthKey();\n    const balancesPtr = ptr.keyword(\"/balances\").lengthKey();\n\n    runesPtr.setValue<u32>(0);\n    balancesPtr.setValue<u32>(0);\n    this.save(ptr);\n  }\n\n  save(ptr: IndexPointer, isCenotaph: bool = false): void {\n    const runesPtr = ptr.keyword(\"/runes\");\n    const balancesPtr = ptr.keyword(\"/balances\");\n\n    for (let i = 0; i < this.runes.length; i++) {\n      if (this.balances[i] != u128.Zero && !isCenotaph) {\n        runesPtr.append(this.runes[i]);\n\n        const buf = changetype<Uint8Array>(this.balances[i].toBytes()).buffer;\n        balancesPtr.append(buf);\n      }\n    }\n  }\n  saveIndex(i: u32, ptr: IndexPointer, isCenotaph: bool = false): void {\n    const runesPtr = ptr.keyword(\"/runes\");\n    const balancesPtr = ptr.keyword(\"/balances\");\n\n    if (this.balances[i] != u128.Zero && !isCenotaph) {\n      runesPtr.append(this.runes[i]);\n\n      const buf = changetype<Uint8Array>(this.balances[i].toBytes()).buffer;\n      balancesPtr.append(buf);\n    }\n  }\n  static load(ptr: IndexPointer): ProtoruneBalanceSheet {\n    return ProtoruneBalanceSheet.from(BalanceSheet.load(ptr));\n  }\n  static from(v: BalanceSheet): ProtoruneBalanceSheet {\n    return changetype<ProtoruneBalanceSheet>(v);\n  }\n}\n","import { protorune as protobuf } from \"../proto/protorune\";\nimport { input } from \"metashrew-as/assembly/indexer\";\nimport { ProtoruneTable } from \"../indexer/tables/protorune\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { fromArrayBuffer } from \"metashrew-runes/assembly/utils\";\nimport { RuneId } from \"metashrew-runes/assembly/indexer/RuneId\";\nimport { encodeHexFromBuffer } from \"metashrew-as/assembly/utils/hex\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\nimport { ProtoruneBalanceSheet } from \"../indexer/ProtoruneBalanceSheet\";\nimport { balanceSheetToProtobufForProtocol } from \"./outpoint\";\n\nexport function runtime(): ArrayBuffer {\n  const inp = protobuf.RuntimeInput.decode(input().slice(4));\n\n  const protocol = String.UTF8.decode(\n    changetype<Uint8Array>(inp.protocol_tag).buffer,\n  );\n  const table = ProtoruneTable.for_str(protocol);\n\n  const message = new protobuf.Runtime();\n\n  const bal = ProtoruneBalanceSheet.load(table.RUNTIME_BALANCE);\n  const sheet = changetype<protobuf.BalanceSheet>(\n    balanceSheetToProtobufForProtocol(bal, table),\n  );\n  message.balances = sheet;\n\n  return message.encode();\n}\n","import { Box } from \"metashrew-as/assembly/utils\";\nimport { readULEB128ToU128 } from \"metashrew-runes/assembly/leb128\";\nimport { toArrayBuffer } from \"metashrew-runes/assembly/utils\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { reverse } from \"metashrew-as/assembly/utils\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\n\nexport function alignArrayBuffer(v: ArrayBuffer): Box {\n  const box = Box.from(v);\n  while (box.len !== 0) {\n    if (load<u8>(box.start) === 0) box.shrinkFront(1);\n    else break;\n  }\n  return box;\n}\n\nexport function alignU128ToArrayBuffer(v: u128): Box {\n  return alignArrayBuffer(reverse(toArrayBuffer(v)));\n}\n\nexport function snapTo15Bytes(v: Box): Box {\n  const box = v.sliceFrom(0);\n  box.shrinkFront(1);\n  return box;\n}\n\nexport function concatByteArray15BytesPerU128(v: Array<u128>): ArrayBuffer {\n  return Box.concat(\n    v.map<Box>((v, i, ary) =>\n      i === ary.length - 1\n        ? alignU128ToArrayBuffer(v)\n        : snapTo15Bytes(Box.from(reverse(toArrayBuffer(v)))),\n    ),\n  );\n}\n\nexport function concatByteArrayTruncateZeros(v: Array<u128>): ArrayBuffer {\n  let foundFirstNonZero = false;\n  let result = new Array<Box>();\n\n  for (let i = 0; i < v.length; i++) {\n    let value = v[i];\n\n    if (!foundFirstNonZero) {\n      if (value.isZero()) {\n        continue; // Skip this element\n      } else {\n        result.push(alignU128ToArrayBuffer(value));\n        foundFirstNonZero = true; // Mark the first nonzero element\n        continue;\n      }\n    }\n    result.push(Box.from(reverse(toArrayBuffer(value))));\n  }\n\n  return Box.concat(result);\n}\n\nexport function byteLengthForNVarInts(input: Box, n: u64): usize {\n  const clone = input.sliceFrom(0);\n  const start = clone.start;\n  for (let i: i32 = 0; i < <i32>n; i++) {\n    clone.shrinkFront(readULEB128ToU128(clone, u128.from(0)));\n  }\n  return clone.start - start;\n}\n\nexport function checkForNonDataPush(parsed: Array<Box>): ArrayBuffer {\n  if (\n    parsed.findIndex((v: Box, i: i32, ary: Array<Box>) => {\n      return v.start === usize.MAX_VALUE;\n    }) !== -1\n  )\n    return new ArrayBuffer(0);\n  return Box.concat(parsed);\n}\n\nexport function fieldToArrayBuffer15Bytes(data: Array<u128>): ArrayBuffer {\n  return Box.concat(\n    data.map((v: u128, i: i32, ary: Array<u128>) =>\n      Box.from(toArrayBuffer(v).slice(0, MAX_U128_BYTES_COMPAT_W_RUNES)),\n    ),\n  );\n}\n\nexport function toLEB128(data: u128): ArrayBuffer {\n  let result: Array<u8> = [];\n  let tempValue = data;\n  const sevenBitMask = u128.from(0x7f);\n  const continuationBit = u128.from(0x80);\n  // Encode the u128 value using LEB128\n  while (tempValue > sevenBitMask) {\n    // Extract 7 bits and add continuation bit (0x80)\n    const extracted: u128 = (tempValue & sevenBitMask) | continuationBit;\n    result.push(<u8>extracted.lo);\n    // Shift the value right by 7 bits for the next byte\n    tempValue = tempValue >> (<i32>7);\n  }\n\n  // Add the final byte without continuation bit\n  const lastByte = <u8>(tempValue & sevenBitMask).lo;\n  result.push(lastByte);\n\n  const final = changetype<ArrayBuffer>(StaticArray.fromArray<u8>(result));\n\n  return final;\n}\n\nexport function logArrayBuffer(arr: ArrayBuffer): void {\n  const tempArray = Uint8Array.wrap(arr);\n  console.log(\"Got arraybuffer of size \" + tempArray.length.toString());\n  tempArray.forEach((val, i) => {\n    console.log(\n      `byte[${i}] = 0x${val.toString(16).padStart(2, \"0\")} (${String.fromCharCode(val)})`,\n    );\n  });\n}\n","import { u128 } from \"as-bignum/assembly\";\nimport { ProtoruneField } from \"./fields/ProtoruneField\";\nimport { ProtoruneTable } from \"./tables/protorune\";\nimport { Box } from \"metashrew-as/assembly/utils/box\";\nimport { reverse } from \"metashrew-as/assembly/utils/utils\";\nimport { readULEB128ToU128 } from \"metashrew-runes/assembly/leb128\";\nimport { BalanceSheet } from \"metashrew-runes/assembly/indexer/BalanceSheet\";\nimport {\n  Input,\n  OutPoint,\n  Output,\n} from \"metashrew-as/assembly/blockdata/transaction\";\nimport { RunesTransaction } from \"metashrew-runes/assembly/indexer/RunesTransaction\";\nimport { RunestoneMessage } from \"metashrew-runes/assembly/indexer/RunestoneMessage\";\nimport { ProtoMessage } from \"./protomessage\";\nimport { Protoburn } from \"./Protoburn\";\nimport {\n  u128ToHex,\n  fieldToU128,\n  toArrayBuffer,\n  fieldToArrayBuffer,\n  toPrimitive,\n  fieldTo,\n} from \"metashrew-runes/assembly/utils\";\nimport { fieldToArrayBuffer15Bytes } from \"../utils\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\nimport { PROTOCOL_FIELD } from \"../constants\";\nimport { Edict } from \"metashrew-runes/assembly/indexer/Edict\";\nimport { Field } from \"metashrew-runes/assembly/indexer/Field\";\nimport { encodeHexFromBuffer } from \"metashrew-as/assembly/utils\";\nimport { concatByteArray15BytesPerU128, byteLengthForNVarInts } from \"../utils\";\nimport { ProtoruneRuneId } from \"./ProtoruneRuneId\";\nimport { RuneId } from \"metashrew-runes/assembly/indexer/RuneId\";\n\nfunction logProtoruneField(ary: Array<u128>): void {\n  console.log(Box.from(concatByteArray15BytesPerU128(ary)).toHexString());\n}\n\nclass BalanceSheetReduce {\n  public table: ProtoruneTable;\n  public sheets: Array<BalanceSheet>;\n  constructor(table: ProtoruneTable) {\n    this.table = table;\n    this.sheets = new Array<BalanceSheet>(0);\n  }\n  concat(): BalanceSheet {\n    return BalanceSheet.concat(this.sheets);\n  }\n}\n\nexport class ProtoMessageReduce {\n  public accumulated: Array<ProtoMessage>;\n  public voutStart: u32;\n  constructor(voutStart: u32) {\n    this.voutStart = voutStart;\n    this.accumulated = new Array<ProtoMessage>();\n  }\n  static from(voutStart: u32): ProtoMessageReduce {\n    return new ProtoMessageReduce(voutStart);\n  }\n}\n\nexport class ProtostoneTable {\n  public list: Array<Protostone>;\n  public voutStart: u32;\n  constructor(v: Array<Protostone>, voutStart: u32) {\n    this.list = v;\n    this.voutStart = voutStart;\n  }\n  static from(\n    ary: Array<u128>,\n    voutStart: u32,\n    unallocatedTo: u32,\n  ): ProtostoneTable {\n    const list = Protostone.parseFromFieldData(ary, unallocatedTo);\n    return new ProtostoneTable(list, voutStart);\n  }\n  burns(): Array<Protoburn> {\n    return this.list\n      .filter((v: Protostone) => v.protocolTag === u128.from(13) && v.isBurn())\n      .map(\n        (v: Protostone) =>\n          new Protoburn([\n            v.fields.get(ProtoruneField.BURN)[0],\n            v.fields.get(ProtoruneField.POINTER)[0]\n\t  ].concat(v.fields.has(ProtoruneField.FROM) ? v.fields.get(ProtoruneField.FROM) : []))\n      );\n  }\n  messages(): Array<ProtoMessage> {\n    return this.list.reduce(\n      (\n        r: ProtoMessageReduce,\n        v: Protostone,\n        i: i32,\n        ary: Array<Protostone>,\n      ) => {\n        if (v.isMessage()) {\n          r.accumulated.push(ProtoMessage.from(v, r.voutStart + i));\n        }\n        return r;\n      },\n      ProtoMessageReduce.from(this.voutStart),\n    ).accumulated;\n  }\n  flat(): Array<Protostone> {\n    return this.list;\n  }\n}\n\nexport class Protostone extends RunestoneMessage {\n  public fields: Map<u64, Array<u128>>;\n  public edicts: Array<StaticArray<u128>>;\n  public nextIndex: i32 = -1;\n  public protocolTag: u128 = u128.Zero;\n  public table: ProtoruneTable;\n  public etchEnabled: bool = false;\n  public openMint: bool = false;\n  constructor(\n    fields: Map<u64, Array<u128>>,\n    edicts: Array<StaticArray<u128>>,\n    protocolTag: u128,\n    unallocatedTo: u32,\n  ) {\n    super(fields, edicts, unallocatedTo);\n    this.fields = fields;\n    this.edicts = edicts;\n    this.protocolTag = protocolTag;\n    this.table = ProtoruneTable.for(protocolTag);\n  }\n  protostones(voutStart: u32): ProtostoneTable {\n    if (!this.fields.has(PROTOCOL_FIELD))\n      return ProtostoneTable.from(\n        new Array<u128>(),\n        voutStart,\n        this.unallocatedTo,\n      );\n    return ProtostoneTable.from(\n      this.fields.get(PROTOCOL_FIELD),\n      voutStart,\n      this.unallocatedTo,\n    );\n  }\n  static from(v: RunestoneMessage): Protostone {\n    return changetype<Protostone>(v);\n  }\n  inspect(): string {\n    let result = \"Protostone {\\n\";\n    let fieldInts = this.fields.keys();\n    for (let i = 0; i < fieldInts.length; i++) {\n      result += \"  \" + fieldInts[i].toString(10) + \": [\\n\";\n      const ary = this.fields.get(fieldInts[i]);\n      for (let j = 0; j < ary.length; j++) {\n        result += \"    \" + u128ToHex(ary[j]) + \",\\n\";\n      }\n      result += \"  ]\\n\";\n    }\n    result += \"}\\n\";\n    // result += \"  edicts: [\";\n    // for (let i = 0; i < this.edicts.length; i++) {\n    //   result += \"    \";\n    //   for (let j = 0; j < this.edicts[i].length; j++) {\n    //     result += u128ToHex(this.edicts[i][j]);\n    //   }\n    //   if (i !== this.edicts.length - 1) result += \", \";\n    // }\n    // result += \"]\\n}\";\n    return result;\n  }\n\n  buildRuneIdForMint(bytes: ArrayBuffer): ArrayBuffer {\n    return ProtoruneRuneId.fromBytes(bytes).toBytes();\n  }\n\n  buildRuneId(height: u64, tx: u32): ArrayBuffer {\n    return new ProtoruneRuneId(height, tx).toBytes();\n  }\n\n  getReservedNameFor(height: u64, tx: u32): ArrayBuffer {\n    //@TODO: override this\n    return super.getReservedNameFor(height, tx);\n  }\n\n  mint(height: u32, balanceSheet: BalanceSheet): bool {\n    if (!this.openMint) return this.openMint;\n    return super.mint(height, balanceSheet);\n  }\n  etch(\n    height: u64,\n    tx: u32,\n    initialBalanceSheet: BalanceSheet,\n    transaction: RunesTransaction,\n  ): bool {\n    if (!this.etchEnabled) return this.etchEnabled;\n    const res = super.etch(height, tx, initialBalanceSheet, transaction);\n    this.table.INTERNAL_MINT.select(\n      new RuneId(height, tx).toBytes(),\n    ).setValue<bool>(true);\n    return res;\n  }\n  isMessage(): bool {\n    return this.fields.has(ProtoruneField.MESSAGE);\n  }\n  toMessage(vout: u32): ProtoMessage {\n    return ProtoMessage.from(this, vout);\n  }\n  isBurn(): bool {\n    return this.fields.has(ProtoruneField.BURN);\n  }\n  toBurn(): Protoburn {\n    return new Protoburn([\n      this.fields.get(ProtoruneField.BURN)[0],\n      this.fields.get(ProtoruneField.POINTER)[0],\n    ]);\n  }\n  isSplit(): bool {\n    return this.fields.has(ProtoruneField.SPLIT);\n  }\n  chunk(): ArrayBuffer {\n    const chunks = this.fields.get(ProtoruneField.CHUNK);\n    if (chunks.length == 0) return new ArrayBuffer(0);\n    return fieldToArrayBuffer(chunks);\n  }\n\n  splits(): Array<u32> {\n    const splits = this.fields.get(ProtoruneField.SPLIT);\n\n    if (splits.length > 0) {\n      return splits.map<u32>((d) => d.toU32());\n    }\n    return changetype<Array<u32>>(0);\n  }\n\n  static parseFromFieldData(\n    fieldData: Array<u128>,\n    unallocatedTo: u32,\n  ): Array<Protostone> {\n    const input = Box.from(concatByteArray15BytesPerU128(fieldData));\n    const result: Array<Protostone> = new Array<Protostone>();\n    while (input.len > 0) {\n      const protocolTag = u128.from(0);\n      let size = readULEB128ToU128(input, protocolTag);\n      if (protocolTag.isZero()) {\n        // For the very last u128, not all bytes may be used (due to LEB format)\n        //console.log(\"Found protocol id 0, breaking...\");\n        break;\n      }\n      if (size === usize.MAX_VALUE) return changetype<Protostone[]>(0); //can choose to continue or return\n      input.shrinkFront(size);\n\n      const len = u128.from(0); //assuming len is encoded as the number of bytes needed to read\n      size = readULEB128ToU128(input, len);\n      if (size === usize.MAX_VALUE) return changetype<Protostone[]>(0); //can choose to continue or return\n      input.shrinkFront(size);\n      const byteLength = byteLengthForNVarInts(input, len.lo);\n      const protostone = Protostone.parseIntoProtostone(\n        input.sliceTo(input.start + byteLength),\n        protocolTag,\n        unallocatedTo,\n      );\n      result.push(protostone);\n      input.shrinkFront(<u32>byteLength);\n    }\n    return result;\n  }\n  saveBalanceSheet(\n    sheet: BalanceSheet,\n    txid: ArrayBuffer,\n    output: u32,\n    isCenotaph: bool,\n  ): void {\n    sheet.save(\n      this.table.OUTPOINT_TO_RUNES.select(\n        OutPoint.from(txid, output).toArrayBuffer(),\n      ),\n      isCenotaph,\n    );\n  }\n  loadBalanceSheet(tx: RunesTransaction): BalanceSheet {\n    return tx.ins\n      .reduce<BalanceSheetReduce>(\n        (r: BalanceSheetReduce, v: Input, i: i32, ary: Array<Input>) => {\n          r.sheets.push(\n            BalanceSheet.load(\n              r.table.OUTPOINT_TO_RUNES.select(\n                v.previousOutput().toArrayBuffer(),\n              ),\n            ),\n          );\n          return r;\n        },\n        new BalanceSheetReduce(this.table),\n      )\n      .concat();\n  }\n  static parseIntoProtostone(\n    input: Box,\n    protocolTag: u128,\n    unallocatedTo: u32,\n  ): Protostone {\n    // console.log(\"Inside protostone.parse\" + input.toHexString());\n    let fields = new Map<u64, Array<u128>>();\n    let edicts = new Array<StaticArray<u128>>(0);\n    while (input.len > 0) {\n      const fieldKeyHeap = u128.from(0);\n      const size = readULEB128ToU128(input, fieldKeyHeap);\n      if (size === usize.MAX_VALUE) return changetype<Protostone>(0);\n      input.shrinkFront(size);\n      const fieldKey = fieldKeyHeap.lo;\n      // console.log(\"GOT FIELDKEY \" + fieldKey.toString());\n      if (fieldKey === 0) {\n        while (input.len > 0) {\n          const edict = new StaticArray<u128>(4);\n          for (let i = 0; i < 4; i++) {\n            const edictInt = u128.from(0);\n            const size = readULEB128ToU128(input, edictInt);\n            if (usize.MAX_VALUE === size) return changetype<Protostone>(0);\n            input.shrinkFront(size);\n            edict[i] = edictInt;\n          }\n          edicts.push(edict);\n        }\n      } else {\n        const value = u128.from(0);\n        const size = readULEB128ToU128(input, value);\n        if (usize.MAX_VALUE === size) return changetype<Protostone>(0);\n        input.shrinkFront(size);\n        let field: Array<u128> = changetype<Array<u128>>(0);\n        if (!fields.has(fieldKey)) {\n          field = new Array<u128>(0);\n          fields.set(fieldKey, field);\n        } else {\n          field = fields.get(fieldKey);\n        }\n        field.push(value);\n      }\n    }\n    return new Protostone(fields, edicts, protocolTag, unallocatedTo);\n  }\n\n  processEdict(\n    balancesByOutput: Map<u32, BalanceSheet>,\n    balanceSheet: BalanceSheet,\n    edict: Edict,\n    outputs: Array<Output>,\n  ): bool {\n    if (edict.block.isZero() && !edict.transactionIndex.isZero()) {\n      return true;\n    }\n    const runeId = edict.runeId().toBytes();\n\n    const edictOutput = toPrimitive<u32>(edict.output);\n    if (edictOutput == outputs.length) {\n      if (edict.amount.isZero()) {\n        const numNonOpReturnOuts: u128 = this.numNonOpReturnOutputs(outputs);\n        if (!numNonOpReturnOuts.isZero()) {\n          const amountSplit = u128.div(\n            balanceSheet.get(runeId),\n            numNonOpReturnOuts,\n          );\n          const amountSplitPlus1 = amountSplit.preInc();\n          const numRemainder = u128.rem(\n            balanceSheet.get(runeId),\n            numNonOpReturnOuts,\n          );\n          let extraCounter: u64 = 0;\n          for (let i = 0; i < outputs.length; i++) {\n            if (this.isNonOpReturnOutput(outputs[i])) {\n              if (extraCounter < numRemainder.lo) {\n                this.updateBalancesForEdict(\n                  balancesByOutput,\n                  balanceSheet,\n                  amountSplitPlus1,\n                  i,\n                  runeId,\n                );\n                extraCounter++;\n              } else {\n                this.updateBalancesForEdict(\n                  balancesByOutput,\n                  balanceSheet,\n                  amountSplit,\n                  i,\n                  runeId,\n                );\n              }\n            }\n          }\n        }\n      } else {\n        for (let i = 0; i < outputs.length; i++) {\n          if (this.isNonOpReturnOutput(outputs[i])) {\n            this.updateBalancesForEdict(\n              balancesByOutput,\n              balanceSheet,\n              edict.amount,\n              i,\n              runeId,\n            );\n          }\n        }\n      }\n\n      return false;\n    } else {\n      this.updateBalancesForEdict(\n        balancesByOutput,\n        balanceSheet,\n        edict.amount,\n        edictOutput,\n        runeId,\n      );\n      return false;\n    }\n  }\n}\n","import { ProtoruneBalanceSheet } from \"./ProtoruneBalanceSheet\";\nimport { Box } from \"metashrew-as/assembly/utils/box\";\nimport { ProtoruneTable } from \"./tables/protorune\";\nimport * as base from \"metashrew-runes/assembly/indexer/constants\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\n\nexport class Protoburn {\n  public protocolTag: u128;\n  public pointer: u32;\n  public from: Array<u32>;\n  public table: ProtoruneTable;\n  constructor(data: Array<u128>) {\n    const protocolTag = data[0];\n    this.pointer = data[1].toU32();\n    this.protocolTag = protocolTag;\n    this.from = data.slice(2).map<u32>((v) => v.toU32());\n    this.table = ProtoruneTable.for(protocolTag);\n  }\n\n  hookBurn(rune: ArrayBuffer, amount: u128): void {}\n\n  process(balanceSheet: ProtoruneBalanceSheet, outpoint: ArrayBuffer): void {\n    for (let i = 0; i < balanceSheet.runes.length; i++) {\n      const runeId = balanceSheet.runes[i];\n      const name = base.RUNE_ID_TO_ETCHING.select(runeId).get();\n      this.table.RUNE_ID_TO_ETCHING.select(runeId).set(name);\n      this.table.ETCHING_TO_RUNE_ID.select(name).set(runeId);\n      this.table.SPACERS.select(name).set(base.SPACERS.select(name).get());\n      this.table.DIVISIBILITY.select(name).set(\n        base.DIVISIBILITY.select(name).get(),\n      );\n      this.table.SYMBOL.select(name).set(base.SYMBOL.select(name).get());\n      this.table.ETCHINGS.append(name);\n      balanceSheet.saveIndex(i, this.table.OUTPOINT_TO_RUNES.select(outpoint));\n      this.hookBurn(runeId, balanceSheet.balances[i]);\n    }\n  }\n}\n","import { Block } from \"metashrew-as/assembly/blockdata\";\nimport { RunesTransaction } from \"metashrew-runes/assembly/indexer/RunesTransaction\";\nimport { MessageContext } from \"./MessageContext\";\nimport { BalanceSheet } from \"metashrew-runes/assembly/indexer/BalanceSheet\";\nimport { Protostone } from \"../Protostone\";\nimport { ProtoruneField } from \"../fields/ProtoruneField\";\nimport { fieldTo, fieldToArrayBuffer, stripNullRight } from \"metashrew-runes/assembly/utils\";\nimport { encodeHexFromBuffer } from \"metashrew-as/assembly/utils/hex\";\nimport { console } from \"metashrew-as/assembly/utils/logging\";\nimport { u128 } from \"as-bignum/assembly\";\n\nexport class ProtoMessage {\n  public vout: u32;\n  public calldata: ArrayBuffer;\n  public pointer: u32;\n  public refund_pointer: u32;\n  public protocolTag: u128;\n  constructor(\n    vout: u32,\n    pointer: u32,\n    refund_pointer: u32,\n    _calldata: ArrayBuffer,\n    protocolTag: u128,\n  ) {\n    this.vout = vout;\n    this.pointer = pointer;\n    this.refund_pointer = refund_pointer;\n    const calldata = Uint8Array.wrap(stripNullRight(_calldata)).reverse()\n      .buffer;\n    this.calldata = calldata;\n    this.protocolTag = protocolTag;\n  }\n  handle<T extends MessageContext>(\n    tx: RunesTransaction,\n    block: Block,\n    height: u64,\n    i: u32,\n  ): void {\n    const context = instantiate<T>(\n      changetype<T>(0).protocolTag(),\n      tx,\n      block,\n      height,\n      i,\n      this.vout,\n      this.pointer,\n      this.refund_pointer,\n      this.calldata,\n    );\n\n    changetype<T>(context).run();\n  }\n  static from(protostone: Protostone, vout: u32): ProtoMessage {\n    if (\n      !protostone.fields.has(ProtoruneField.MESSAGE) ||\n      !protostone.fields.has(ProtoruneField.POINTER) ||\n      !protostone.fields.has(ProtoruneField.REFUND)\n    )\n      return changetype<ProtoMessage>(0);\n\n    let calldata: ArrayBuffer = fieldToArrayBuffer(\n      protostone.fields.get(ProtoruneField.MESSAGE),\n    );\n    return new ProtoMessage(\n      vout,\n      fieldTo<u32>(protostone.fields.get(ProtoruneField.POINTER)),\n      fieldTo<u32>(protostone.fields.get(ProtoruneField.REFUND)),\n      calldata,\n      protostone.protocolTag\n    );\n  }\n}\n","import { AtomicTransaction } from \"metashrew-as/assembly/indexer/atomic\";\nimport { RuneId } from \"metashrew-runes/assembly/indexer/RuneId\";\nimport { u128 } from \"as-bignum/assembly\";\nimport { MessageContext } from \"./MessageContext\";\nimport { ProtoruneTable } from \"../tables/protorune\";\nimport { fromArrayBuffer, toArrayBuffer } from \"metashrew-runes/assembly/utils\";\nimport { console } from \"metashrew-as/assembly/utils\";\nimport { encodeHexFromBuffer } from \"metashrew-as/assembly/utils/hex\";\nimport { logArrayBuffer } from \"../../utils\";\n\nexport class IncomingRune {\n  runeId: RuneId;\n  amount: u128;\n  depositAmount: u128;\n  initialAmount: u128;\n  pointer_index: i32 = -1;\n  refund_pointer_index: i32 = -1;\n  outpoint_index: i32 = -1;\n  runtime: AtomicTransaction = new AtomicTransaction();\n  context: MessageContext = changetype<MessageContext>(0);\n  table: ProtoruneTable;\n  constructor(\n    context: MessageContext,\n    runeId: RuneId,\n    amount: u128,\n    table: ProtoruneTable,\n  ) {\n    this.context = context;\n    this.runeId = runeId;\n    this.initialAmount = amount;\n    this.amount = new u128(amount.lo, amount.hi);\n    this.depositAmount = new u128(0, 0);\n    this.table = table;\n  }\n\n  refundAll(): bool {\n    return (\n      this.refund(this.initialAmount - this.amount) &&\n      this.refundDeposit(this.depositAmount)\n    );\n  }\n  /**\n   * Refunds an amount from the pointer. If nothing has been forwarded,\n   * (ie this context pointer balance is 0), then returns false\n   * @param value amount to refund\n   * @returns true if refund value successful, false if not refunded\n   */\n  refund(value: u128): bool {\n    const refundPtr = this.table.OUTPOINT_TO_RUNES.select(\n      this.context.refund_pointer.toArrayBuffer(),\n    ).keyword(\"/balances\");\n    const ptr = this.table.OUTPOINT_TO_RUNES.select(\n      this.context.pointer.toArrayBuffer(),\n    ).keyword(\"/balances\");\n    if (this.pointer_index == -1) return false;\n    const pointerIndex = ptr.selectIndex(this.pointer_index).unwrap();\n    const currentValue = fromArrayBuffer(\n      this.context.runtime.get(pointerIndex),\n    );\n    if (value > currentValue || currentValue + value > this.initialAmount)\n      return false;\n    const newValue: u128 = currentValue - value;\n    if (newValue > u128.Zero) {\n      this.context.runtime.set(pointerIndex, toArrayBuffer(newValue));\n    } else {\n      this.context.runtime.set(pointerIndex, new ArrayBuffer(0));\n    }\n    let toSet: ArrayBuffer;\n    toSet = refundPtr.selectIndex(this.refund_pointer_index).unwrap();\n    this.amount += value;\n    this.context.runtime.set(toSet, toArrayBuffer(value));\n    return true;\n  }\n  /**\n   * Refunds an amount from the RUNTIME Balance. If nothing has been deposited,\n   * (ie this RUNTIME is 0), then returns false\n   * @param value amount to refund\n   * @returns true if refund value successful, false if not refunded\n   */\n  refundDeposit(value: u128): bool {\n    if (this.refund_pointer_index == -1) return false;\n    const refundPtr = this.table.OUTPOINT_TO_RUNES.select(\n      this.context.refund_pointer.toArrayBuffer(),\n    )\n      .keyword(\"/balances\")\n      .selectIndex(this.refund_pointer_index);\n    const runePtr = this.table.OUTPOINT_TO_RUNES.select(\n      this.context.refund_pointer.toArrayBuffer(),\n    )\n      .keyword(\"/runes\")\n      .selectIndex(this.refund_pointer_index)\n      .unwrap();\n    const runeId = this.context.runtime.get(runePtr);\n    const currentValue = this.context.runtimeBalance.get(runeId);\n    if (value > currentValue || currentValue + value > this.initialAmount)\n      return false;\n    this.context.runtimeBalance.decrease(runeId, value);\n    let toSet: ArrayBuffer;\n    toSet = refundPtr.selectIndex(this.refund_pointer_index).unwrap();\n    this.amount += value;\n    this.depositAmount -= value;\n    this.context.runtime.set(toSet, toArrayBuffer(value));\n    return true;\n  }\n  forward(value: u128): bool {\n    const refundPtr = this.table.OUTPOINT_TO_RUNES.select(\n      this.context.refund_pointer.toArrayBuffer(),\n    ).keyword(\"/balances\");\n    const refundRunesPtr = this.table.OUTPOINT_TO_RUNES.select(\n      this.context.refund_pointer.toArrayBuffer(),\n    ).keyword(\"/runes\");\n    const ptr = this.table.OUTPOINT_TO_RUNES.select(\n      this.context.pointer.toArrayBuffer(),\n    ).keyword(\"/balances\");\n    const runePtr = this.table.OUTPOINT_TO_RUNES.select(\n      this.context.pointer.toArrayBuffer(),\n    ).keyword(\"/runes\");\n    if (this.refund_pointer_index == -1) return false;\n    const refundIndex = refundPtr\n      .selectIndex(this.refund_pointer_index)\n      .unwrap();\n    const runeName = this.context.runtime.get(\n      refundRunesPtr.selectIndex(this.refund_pointer_index).unwrap(),\n    );\n    const currentValue = fromArrayBuffer(this.context.runtime.get(refundIndex));\n    if (value > this.amount || value > currentValue) return false;\n    const newValue: u128 = currentValue - value;\n    if (newValue > u128.Zero) {\n      this.context.runtime.set(refundIndex, toArrayBuffer(newValue));\n    } else {\n      this.context.runtime.set(refundIndex, new ArrayBuffer(0));\n    }\n    let toSet: ArrayBuffer;\n    if (this.pointer_index == -1) {\n      this.pointer_index = ptr.length();\n      toSet = this.context.runtime.extendIndexPointerList(ptr);\n      this.context.runtime.set(\n        this.context.runtime.extendIndexPointerList(runePtr),\n        runeName,\n      );\n    } else {\n      toSet = ptr.selectIndex(this.pointer_index).unwrap();\n    }\n    this.context.runtime.set(toSet, toArrayBuffer(value));\n    this.amount = this.amount - value;\n    return true;\n  }\n  forwardAll(): void {\n    this.forward(this.amount);\n  }\n  deposit(value: u128): bool {\n    const refundPtr = this.table.OUTPOINT_TO_RUNES.select(\n      this.context.refund_pointer.toArrayBuffer(),\n    ).keyword(\"/balances\");\n    const runePtr = this.table.OUTPOINT_TO_RUNES.select(\n      this.context.refund_pointer.toArrayBuffer(),\n    ).keyword(\"/runes\");\n    if (this.refund_pointer_index == -1) return false;\n    const refundIndex = refundPtr\n      .selectIndex(this.refund_pointer_index)\n      .unwrap();\n    const runeId = this.context.runtime.get(\n      runePtr.selectIndex(this.refund_pointer_index).unwrap(),\n    );\n    const currentValue = fromArrayBuffer(this.context.runtime.get(refundIndex));\n    if (value > this.amount || value > currentValue) return false;\n    const newValue: u128 = currentValue - value;\n    if (newValue > u128.Zero) {\n      this.context.runtime.set(refundIndex, toArrayBuffer(newValue));\n    } else {\n      this.context.runtime.set(refundIndex, new ArrayBuffer(0));\n    }\n    let toSet = this.context.table.RUNTIME_BALANCE.select(runeId);\n    this.context.runtimeBalance.increase(runeId, value);\n    this.amount = this.amount - value;\n    this.depositAmount += value;\n    return true;\n  }\n  depositAll(): bool {\n    return this.deposit(this.amount);\n  }\n}\n","import { IndexPointer } from \"./tables\";\nimport { hash } from \"./index\";\nimport { console } from \"../utils/logging\";\n\nexport class AtomicTransaction {\n  temp: Map<string, ArrayBuffer>;\n  tempKeys: Map<string, ArrayBuffer>;\n  saved: Map<string, ArrayBuffer>;\n  savedKeys: Map<string, ArrayBuffer>;\n\n  constructor() {\n    this.temp = new Map<string, ArrayBuffer>();\n    this.tempKeys = new Map<string, ArrayBuffer>();\n    this.saved = new Map<string, ArrayBuffer>();\n    this.savedKeys = new Map<string, ArrayBuffer>();\n  }\n\n  checkpoint(): void {\n    const keys = this.temp.keys();\n    for (let i = 0; i < keys.length; i++) {\n      this.saved.set(keys[i], this.temp.get(keys[i]));\n      this.savedKeys.set(keys[i], this.tempKeys.get(keys[i]));\n    }\n  }\n\n  commit(): void {\n    const keys = this.savedKeys.keys();\n    console.log(keys.length.toString());\n    for (let i = 0; i < keys.length; i++) {\n      IndexPointer.wrap(this.savedKeys.get(keys[i])).set(\n        this.saved.get(keys[i])\n      );\n    }\n\n    this.saved.clear();\n  }\n\n  rollback(): void {\n    this.temp.clear();\n  }\n\n  set(_key: ArrayBuffer, value: ArrayBuffer): void {\n    const key = hash(_key);\n    this.temp.set(key, value);\n    this.tempKeys.set(key, _key);\n  }\n\n  get(_key: ArrayBuffer): ArrayBuffer {\n    const key = hash(_key);\n    if (this.temp.has(key)) {\n      return this.temp.get(key);\n    }\n    return changetype<ArrayBuffer>(0);\n  }\n\n  setValue<T extends number>(key: ArrayBuffer, value: T): void {\n    const container = new ArrayBuffer(sizeof<T>());\n    store<T>(changetype<usize>(container), value);\n    this.set(key, container);\n  }\n\n  getValue<T>(key: ArrayBuffer): T {\n    const value = this.get(key);\n    const container: ArrayBuffer = new ArrayBuffer(sizeof<T>());\n    memory.copy(\n      changetype<usize>(container),\n      changetype<usize>(value),\n      sizeof<T>()\n    );\n    return load<T>(changetype<usize>(container));\n  }\n\n  setKeyword(key: string, value: ArrayBuffer): void {\n    const container = String.UTF8.encode(key);\n    this.set(container, value);\n  }\n\n  getKeyword(key: string): ArrayBuffer {\n    const container = String.UTF8.encode(key);\n    return this.get(container);\n  }\n  nullify(key: ArrayBuffer): void {\n    this.set(key, new ArrayBuffer(0));\n  }\n  rollbackKey(_key: ArrayBuffer): void {\n    const key = hash(_key);\n    if (this.temp.has(key)) {\n      this.temp.delete(key);\n      this.tempKeys.delete(key);\n    }\n  }\n  has(key: ArrayBuffer): bool {\n    return this.temp.has(hash(key));\n  }\n  nullifyIndexPointerList(ptr: IndexPointer): void {\n    for (let i = 0; i < ptr.length(); i++) {\n      this.nullify(ptr.selectIndex(i).unwrap());\n    }\n    this.nullify(ptr.lengthKey().unwrap());\n  }\n  extendIndexPointerList(ptr: IndexPointer): ArrayBuffer {\n    let length: u32;\n    const lengthKey = ptr.lengthKey();\n    if (this.has(lengthKey.unwrap())) {\n      length = this.getValue<u32>(lengthKey.unwrap());\n    } else {\n      length = lengthKey.getValue<u32>();\n    }\n    this.setValue<u32>(lengthKey.unwrap(), length + 1);\n    return ptr.selectIndex(length).unwrap();\n  }\n  appendIndexPointerList(ptr: IndexPointer, value: ArrayBuffer): void {\n    this.set(this.extendIndexPointerList(ptr), value);\n  }\n}\n"]}